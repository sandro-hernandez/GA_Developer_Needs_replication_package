AnswerId,QuestionId,AnswerCreationDate,AnswerScore,AnswerBody,AnswerAuthorId,AnswerAuthorName
"57639714","57639507","2019-08-24 16:29:54","4","<p>You need to pass the name of the service (<code>&quot;postgres&quot;</code>) as <code>POSTGRES_HOST</code> to the application <em>and</em> set the port <code>POSTGRES_PORT: ${{ job.services.postgres.ports[5432] }}</code> (spaces matter.)</p>
<p>Github CI dynamically routes port and host to it.</p>
<p>I wrote a <a href=""http://rocket-science.ru/hacking/2019/08/19/use-github-ci-for-elixir-projects"" rel=""nofollow noreferrer"">blog post</a> on the subject a couple of days ago.</p>
","2035262",""
"57806894","57806624","2019-09-05 13:43:24","121","<p>If I understand your needs, you need the <code>pub</code> steps to run as if you'd done a <code>cd dart_project</code> first, right? Add the <a href=""https://help.github.com/en/articles/workflow-syntax-for-github-actions#jobsjob_idstepsworking-directory"" rel=""noreferrer""><code>working-directory</code></a> parameter to your steps:</p>
<pre><code>steps:
- uses: actions/checkout@v1
- name: Install dependencies
  run: pub get
  working-directory: dart_project
- name: Run tests
  run: pub run test
  working-directory: dart_project
</code></pre>
<p>If you want to apply it to every step, use the tag <code>defaults</code></p>
<pre class=""lang-yaml prettyprint-override""><code>defaults:
  run:
    working-directory: dart_project
</code></pre>
<p>I believe that should be all you need.</p>
","2314532",""
"69494898","57806624","2021-10-08 11:09:05","36","<p>You can configure a <code>working-directory</code> on the step level for this purpose.
You can also configure a default directory for the steps. Defaults can be on job or global level.</p>
<p>Example on step level.</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  build:
    steps:
      - uses: actions/checkout@v1
      - name: Install dependencies
        run: pub get
        working-directory: dart_project
      - name: Run tests
        run: pub run test
        working-directory: dart_project
</code></pre>
<p>Example on job level. This reduces duplication on the job level. This is suited for a job that is working on a sub-directory.</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  build:
    defaults:
      run:
        working-directory: dart_project
    steps:
      - uses: actions/checkout@v1
      - name: Install dependencies
        run: pub get
      - name: Run tests
        run: pub run test
</code></pre>
<p>Example on global level. This reduces duplication on the global level. This is suited when all jobs in the workflow file are for a project located in a sub-directory.</p>
<pre class=""lang-yaml prettyprint-override""><code>defaults:
  run:
    working-directory: dart_project
jobs:
  build:
    steps:
      - uses: actions/checkout@v1
      - name: Install dependencies
        run: pub get
      - name: Run tests
        run: pub run test
</code></pre>
","1485189",""
"57830377","57808152","2019-09-07 03:14:16","0","<p>@Rezwan provided the link to the image I was looking for.</p>

<p>I'm still not able to run it due to the following issues:</p>

<p><a href=""https://github.com/cirruslabs/docker-images-flutter/issues/27"" rel=""nofollow noreferrer"">https://github.com/cirruslabs/docker-images-flutter/issues/27</a></p>

<p><a href=""https://stackoverflow.com/q/57830375/3231778"">GitHub Actions workflow error: Cannot create file, path = &#39;/github/home/.flutter&#39;</a></p>
","3231778",""
"57838959","57808152","2019-09-08 03:20:56","3","<p>I let my one running without Docker. </p>

<p>You could try to install flutter and run flutter pub get. I used in my example <a href=""https://github.com/marketplace/actions/flutter-action"" rel=""nofollow noreferrer"">subosito/flutter-action@v1</a></p>

<pre><code>name: CI

on:
  pull_request:
    branches:
      - development
      - master

jobs:
  test:
    name: Flutter Tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v1
      - uses: actions/setup-java@v1
        with:
          java-version: '12.x'
      - uses: subosito/flutter-action@v1
        with:
          flutter-version: '1.7.8+hotfix.4'
      - run: flutter doctor
      - run: flutter pub get
      - run: flutter test
</code></pre>
","3690032",""
"59022667","57808152","2019-11-24 21:36:27","16","<p>You don't need to use a flutter specific container, there is a <a href=""https://github.com/marketplace/actions/flutter-action"" rel=""nofollow noreferrer"">Flutter Action</a> available that runs on the default Windows, Linux and macOS containers.</p>
<p>This means that building your flutter app is as simple as using the action and then running the flutter build command. The following example runs an Android apk build:</p>
<pre><code>on: push
jobs: 
  build-and-test: 
    runs-on: ubuntu-latest
    steps:
    - name: Clone repository
      uses: actions/checkout@v4
    - name: Set up Flutter
      uses: subosito/flutter-action@v2
      with:
        channel: stable
    # Get flutter packages
    - run: flutter pub get
    # Build :D 
    - run: flutter build apk
</code></pre>
<p>I wrote a <a href=""https://admcpr.com//continuous-integration-for-flutter-with-github-actions/"" rel=""nofollow noreferrer"">blog post</a> about building and testing flutter using actions if you'd like to learn more.</p>
","2529475",""
"73714978","57808152","2022-09-14 10:01:39","0","<p>I leave here a link to the production project with the app in the stores.</p>
<p>Maybe it saves time for somebody, I would be glad to have it when I implement it.</p>
<ol>
<li>Uses secret keys for signing releases.</li>
<li>Create .apks for different flavors.</li>
<li>Add the build number to the files.</li>
<li>Create a GitHub release.</li>
</ol>
<p><a href=""https://github.com/AgoraDesk-LocalMonero/agoradesk-app-foss/blob/main/.github/workflows/build_from_tags_ci.yml"" rel=""nofollow noreferrer"">https://github.com/AgoraDesk-LocalMonero/agoradesk-app-foss/blob/main/.github/workflows/build_from_tags_ci.yml</a></p>
","7198006",""
"58025355","57889719","2019-09-20 09:13:54","44","<p><strong>Second Update:</strong>
I got an answer in the <a href=""https://github.com/NuGet/Home/issues/8580#issuecomment-714501802"" rel=""noreferrer"">GitHub issue</a> from <code>jcansdale</code> that says (haven't tested this):</p>
<blockquote>
<p>Support for the dotnet nuget push --api-key option has now been added to GitHub Packages. For some reason this works consistently, but using basic auth (password in nuget.config file) fails randomly!</p>
</blockquote>
<p>Example:</p>
<pre><code>  - name: Publish Nuget to GitHub registry
    run: dotnet nuget push ./&lt;project&gt;/out/*.nupkg -k ${GITHUB_TOKEN} -s https://nuget.pkg.github.com/&lt;organization&gt;/index.json --skip-duplicate --no-symbols 
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</code></pre>
<p><strong>Update:</strong>
Based on <a href=""https://github.com/NuGet/Home/issues/8580#issuecomment-599056152"" rel=""noreferrer"">Dids answer on GitHub</a> my configuration works now like this:</p>
<pre><code>name: NuGet Generation

on:
  push:
    branches:
      - master
  pull_request:
    types: [closed]
    branches:
      - master

jobs:
  build:
    runs-on: ubuntu-18.04
    name: Update NuGet package
    steps:

      - name: Checkout repository
        uses: actions/checkout@v1

      - name: Setup .NET Core @ Latest
        uses: actions/setup-dotnet@v1
        with:
          source-url: https://nuget.pkg.github.com/&lt;organization&gt;/index.json
        env:
          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}        
          
      - name: Build solution and generate NuGet package
        run: |  
          cd &lt;project&gt;
          dotnet pack -c Release -o out  

      - name: Push generated package to GitHub registry
        run: dotnet nuget push ./&lt;project&gt;/out/*.nupkg --skip-duplicate --no-symbols true

</code></pre>
<p><strong>Note:</strong> At the time of writing I needed to use <code>--no-symbols true</code> instead of <code>--no-symbols</code> to prevent exceptions in the dotnet NuGet client.</p>
<hr />
<p><strong>Old answer:</strong></p>
<p>I switched to the Windows image and got it to work based on the example of <a href=""https://github.com/NuGet/Home/issues/8580#issuecomment-531997703"" rel=""noreferrer"">@anangaur</a>. This is my final code:</p>
<pre><code>name: NuGet Generation

on:
  push:
    branches:
      - master

jobs:
  build:
    runs-on: windows-latest
    name: Update NuGet 
    steps:

      - name: Checkout repository
        uses: actions/checkout@master

#  latest image has .NET already installed!
#      - name: Setup .NET environment
#        uses: actions/setup-dotnet@v1
#        with:
#          dotnet-version: '2.2.105' 
          
      - name: Build solution and generate NuGet package
        run: |  
          cd SOLUTION_FOLDER
          dotnet pack -c Release -o out  

      - name: Install NuGet client
        uses: warrenbuckley/Setup-Nuget@v1
        
      - name: Add private GitHub registry to NuGet
        run: nuget sources add -name &quot;GPR&quot; -Source https://nuget.pkg.github.com/ORGANIZATION_NAME/index.json -Username ORGANIZATION_NAME -Password ${{ secrets.GITHUB_TOKEN }}
        
      - name: Push generated package to GitHub registry
        run: nuget push .\SOLUTION_FOLDER\PROJECT_FOLDER\out\*.nupkg -Source &quot;GPR&quot; -SkipDuplicate

</code></pre>
","639367",""
"58943251","57889719","2019-11-19 21:43:36","6","<p>Here is a workaround that works on all platforms:</p>

<pre><code>name: prerelease NuGet

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    # also works with windows-latest and macos-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v1
    - name: Build with dotnet
      run: dotnet build --configuration Release --version-suffix prerelease-$(date +%Y%m%d%H%M%S)
      shell: bash
    - name: Publish nuget
      run: |
           for f in ./[repository]/bin/Release/*.nupkg
           do
             curl -vX PUT -u ""[user]:${{ secrets.GHPackagesToken }}"" -F package=@$f https://nuget.pkg.github.com/[user]/
           done
      shell: bash
</code></pre>

<p>Notes:</p>

<ul>
<li>this creates a datestamped prerelease build for every git push and uploads it to nuget

<ul>
<li>for the suffix to work, you need to set <code>&lt;VersionPrefix&gt;</code> instead of <code>&lt;Version&gt;</code> in your <a href=""https://github.com/vslee/IEXSharp/blob/master/IEXSharp/IEXSharp.csproj"" rel=""nofollow noreferrer"">.csproj</a></li>
<li>if you don't want the prerelease suffix, remove the --version-suffix parameter</li>
</ul></li>
<li>the shell is explicitly set as bash in order to allow compatibility with building on windows</li>
<li>you will need to replace [user] and [repository] above with your own specific values

<ul>
<li>you will need to create a <a href=""https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line"" rel=""nofollow noreferrer"">personal access token</a> with the permissions of write:packages</li>
<li>then create a <a href=""https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets"" rel=""nofollow noreferrer"">GitHub Secret</a> named GHPackagesToken and put the token created above in there</li>
<li>using GitHub Secrets eliminates the need for a separate file containing your token</li>
</ul></li>
<li>this assumes you're have <code>&lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;</code> in your .csproj

<ul>
<li>if you don't, then you will need an additional step running <code>dotnet pack</code></li>
</ul></li>
<li>make sure to specify <code>&lt;RepositoryUrl&gt;...&lt;/RepositoryUrl&gt;</code> in your .csproj</li>
<li>for a working example if you can't get the above code working, see <a href=""https://github.com/vslee/IEXSharp/blob/master/.github/workflows/dotnetcore.yml"" rel=""nofollow noreferrer"">https://github.com/vslee/IEXSharp/blob/master/.github/workflows/dotnetcore.yml</a>, which pushes to <a href=""https://github.com/vslee/IEXSharp/packages"" rel=""nofollow noreferrer"">https://github.com/vslee/IEXSharp/packages</a> (ignore all of my extraneous comments there)

<ul>
<li>I posted this bc I tried both the examples from jwillmer above, as well as @anangaur and @marza91 on the GH issue thread but neither worked for me (on any platform)</li>
</ul></li>
<li>once GitHub fixes the issue of not being able to use the API key directly in the <code>dotnet nuget push</code> command (see <a href=""https://github.com/NuGet/Home/issues/8580#issue-492651409"" rel=""nofollow noreferrer"">initial post of GH issue</a>), then we won't need this workaround anymore</li>
</ul>
","2847567",""
"60692976","57889719","2020-03-15 12:40:01","1","<p>My working solution:</p>

<ul>
<li>replace 'usernamecompanyname' with a valid value for your repo</li>
<li>I kept the build and pack separated to allow for easier debugging if something goes wrong</li>
<li>you can set <code>ACTIONS_RUNNER_DEBUG</code> variable in your github secrets to <code>true</code> to allow for more detailed debuging</li>
<li>Change <code>dotnet-version</code> to your desired dotnet-sdk version</li>
<li>No need to specify <code>GITHUB_TOKEN</code> in your github repo secrests, this token is present by default</li>
</ul>

<p><strong>build_and_publish_nuget.yml:</strong></p>

<pre><code>name: Build and publish package

# Controls when the action will run. Triggers the workflow on push or pull request 
# events but only for the master branch
on:
  push:
    branches: [ master ]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called ""build""
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@master

      - name: Setup .NET environment
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: '3.1.102'
          source-url: https://nuget.pkg.github.com/usernamecompanyname/index.json
        env:
          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}

      - name: Build project
        run: dotnet build -c Release

      - name: Generate a NuGet package
        run: dotnet pack --no-build -c Release -o .

      - name: Push to GitHub package registry
        run: dotnet nuget push *.nupkg
</code></pre>
","3084793",""
"61263264","57889719","2020-04-17 02:39:42","5","<p>Make sure you project file has the following</p>

<pre><code>&lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;PackageId&gt;Example.PackageName&lt;/PackageId&gt;
    &lt;Version&gt;1.0.0&lt;/Version&gt;
    &lt;Authors&gt;Author Engineering&lt;/Authors&gt;
    &lt;Company&gt;Company Inc&lt;/Company&gt;
    &lt;PackageDescription&gt;This package for ...!&lt;/PackageDescription&gt;
    &lt;RepositoryUrl&gt;
https://github.com/YOUR_ACCOUNT/Example.PackageName&lt;/RepositoryUrl&gt;
  &lt;/PropertyGroup&gt;
</code></pre>

<p>This should be your main.yaml for building, packaging, publishing, and versioning:</p>

<pre><code>name: Continuous Integration

on:
  push:
    branches:
      - master

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v1
    - name: Setup Dotnet Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.100
        source-url: https://nuget.pkg.github.com/YOUR_ACCOUNT/index.json
      env:
        NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}

    - name: Setup Nuget Config
      run: sed 's/GITHUB_TOKEN/${{ secrets.GITHUB_TOKEN }}/g' .nuget.config &gt; nuget.config

    - name: Build
      run: dotnet build --configuration Release

    - name: Version and Tag
      id: bump_version
      uses: mathieudutour/github-tag-action@v1
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}

    - name: Prep Version String
      run: echo ::set-env name=VERSION_NUMBER::$(echo ${{ steps.bump_version.outputs.new_tag }} | sed 's/[v]//g')

    - name: Define Package Name
      run: echo ::set-env name=PACKAGE_NAME::$""Example.PackageName/bin/Release/Example.PackageName.${{ env.VERSION_NUMBER }}.nupkg""

    - name: Set Nuget Package Version
      uses: roryprimrose/set-vs-sdk-project-version@v1
      with:
        version: ${{ env.VERSION_NUMBER }}

    - name: Pack
      run: dotnet pack --configuration Release Example.PackageName

    - name: Publish Package
      run: dotnet nuget push Example.PackageName/bin/Release/*.nupkg --source https://nuget.pkg.github.com/YOUR_ACCOUNT/index.json

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.bump_version.outputs.new_tag }}
        release_name: Release ${{ github.ref }}

</code></pre>
","6068528",""
"63175926","57889719","2020-07-30 14:59:21","6","<p>You can use the <a href=""https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-nuget-add-source"" rel=""noreferrer""><code>dotnet nuget add source</code> command</a>:</p>
<pre><code>    - name: NuGet push
      run: |
        dotnet nuget add source https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json --name github --username ${{ github.repository_owner }} --password ${{ github.token }} --store-password-in-clear-text
        dotnet nuget push **/*.nupkg --source github
</code></pre>
<p>The <code>--store-password-in-clear-text</code> option was required for me when running in a linux environment.</p>
<p>With this method, there's no need to modify the <code>actions/setup-dotnet</code> task.
Also, this method would allow you to push to multiple NuGet streams if needed.</p>
","1250319",""
"63943965","57889719","2020-09-17 18:11:44","1","<p>GitHub has been having intermittent issues with publish NuGet Packages to GitHub Packages.  I reached out to support and they gave me two options.</p>
<p><strong>Option 1: CURL</strong></p>
<pre><code>curl -vX PUT -u &quot;&lt;username&gt;:&lt;TOKEN&gt;&quot; -F package=@PATH-TO-PKG-FILE.nupkg https://nuget.pkg.github.com/&lt;OWNER&gt;/
</code></pre>
<p><strong>Option 2: DOTNET GPR TOOL</strong><br />
<a href=""https://github.com/jcansdale/gpr"" rel=""nofollow noreferrer"">https://github.com/jcansdale/gpr</a></p>
<pre><code>dotnet tool install gpr -g
gpr push PATH-TO-PKG-FILE.nupkg -k &lt;TOKEN&gt;
</code></pre>
<p>I went with <strong>Option 2</strong> in my GitHub Action Workflow:</p>
<pre><code>$file = Get-ChildItem -Path &lt;where I output my nupkg file to&gt; -Recurse -Filter *.nupkg | Select -First 1
gpr push $file.FullName -k ${{secrets.GITHUB_TOKEN}}          
</code></pre>
","229897",""
"70626630","57889719","2022-01-07 20:08:10","4","<p>The other answers were so long, I don't know why. This is what I do:</p>
<h1>For NuGet.org:</h1>
<pre><code>- name: Push Package to NuGet.org
  run: dotnet nuget push *.nupkg -k ${{ secrets.NUGET_ORG_API_KEY }} -s https://api.nuget.org/v3/index.json
</code></pre>
<h1>For GitHub.com:</h1>
<pre><code>- name: Push Package to GitHub.com
  run: dotnet nuget push *.nupkg -k ${{ secrets.GITHUB_TOKEN }} -s https://nuget.pkg.github.com/USERNAME/index.json
</code></pre>
","1275774",""
"58661967","58643905","2019-11-01 15:37:43","28","<p>Luckily the <code>aws-sdk</code> should <a href=""https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/loading-node-credentials-environment.html"" rel=""noreferrer"">automatically detect credentials</a> set as environment variables and use them for requests</p>
<p>To get access to secrets in your action, you need to set them in the repo. Then you can expose them to the step as an env var.</p>
<p>For more details see <a href=""https://docs.github.com/en/actions/reference/encrypted-secrets"" rel=""noreferrer"">GitHub Encrypted secrets</a></p>
<ol>
<li>On GitHub, navigate to the main page of the repository</li>
<li>Under your repository name, click the ⚙ Settings tab</li>
<li>Repository settings button</li>
<li>In the left sidebar, click Secrets</li>
<li>Type a name for your secret in the &quot;Name&quot; input box</li>
<li>Type the value for your secret</li>
<li>Click Add secret</li>
</ol>
<p>In your case you will want to add secrets for both <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>.</p>
<p>Now that those are set you can pass those values into the action via the workflow yaml:</p>
<pre><code>steps:
...
- name: Unit Test
  uses: ...
  env:
    AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
    AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  run: ...
</code></pre>
","19839",""
"63353159","58643905","2020-08-11 07:06:27","0","<p>If running <code>aws</code> from the command line is acceptable for you, you can set the following ENV vars and just use <code>aws</code> commands without needing to run <code>aws configure</code>:</p>
<pre><code>env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_DEFAULT_REGION: us-east-1
  AWS_DEFAULT_OUTPUT: json
</code></pre>
","2771889",""
"66456314","58643905","2021-03-03 11:38:52","6","<p>Take a look at: <a href=""https://github.com/aws-actions/configure-aws-credentials"" rel=""noreferrer"">https://github.com/aws-actions/configure-aws-credentials</a></p>
<p>It allows you to configure AWS credential and region environment variables for use in other GitHub Actions. The environment variables will be detected by both the AWS SDKs and the AWS CLI to determine the credentials and region to use for AWS API calls.</p>
","3156607",""
"70229928","58643905","2021-12-04 22:13:30","20","<p>Avoid using long term and hard coded credentials.</p>
<p>The <a href=""https://github.com/aws-actions/configure-aws-credentials"" rel=""noreferrer"">configure-aws-credentials</a> action provides a mechanism to configure AWS credential and region environment variables for use in other GitHub Actions. The environment variables will be detected by both the AWS SDKs and the AWS CLI to determine the credentials and region to use for AWS API calls.</p>
<p>I recommend configuring <a href=""https://github.com/aws-actions/configure-aws-credentials"" rel=""noreferrer"">configure-aws-credentials</a> to use OpenID Connect (OIDC). This allows your GitHub Actions workflows to access resources in AWS, without needing to store the AWS credentials as long-lived GitHub secrets. The <a href=""https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services"" rel=""noreferrer"">GitHub Configuring OpenID Connect in AWS</a> post walks through setting this up.</p>
<p>To give you a practical example, I set up a pipeline to upload dummy data to a S3 bucket. First set up an OpenID Connect provider, and a role for github to federate into in your AWS account. The examples in <a href=""https://github.com/aws-actions/configure-aws-credentials"" rel=""noreferrer"">configure-aws-credentials</a> are written in CloudFormation but I've translated them to the Python Cloud-Development-Kit(CDK) below. Make sure to change the role condition to match your repository.</p>
<pre class=""lang-py prettyprint-override""><code>        github_oidc_provider = iam.OpenIdConnectProvider(
            self,
            &quot;GithubOIDC&quot;,
            url=&quot;https://token.actions.githubusercontent.com&quot;,  
            thumbprints=[&quot;a031c46782e6e6c662c2c87c76da9aa62ccabd8e&quot;],
            client_ids=[
                &quot;sts.amazonaws.com&quot; 
            ]
        )

        github_actions_role = iam.Role(
            self,
            &quot;DeployToBucketRole&quot;,
            max_session_duration=cdk.Duration.seconds(3600),
            role_name=&quot;github-actions-role&quot;,
            description=&quot;Github actions deployment role to S3&quot;,
            assumed_by=iam.FederatedPrincipal(
                federated=github_oidc_provider.open_id_connect_provider_arn,
                conditions={
                    &quot;StringLike&quot;: {
                        # &lt;GITHUB USERNAME&gt;/&lt;YOUR REPO NAME&gt;
                        &quot;token.actions.githubusercontent.com:sub&quot;: 'repo:arbitraryrw/cdk-github-actions-demo:*' 
                    }
                },
                assume_role_action=&quot;sts:AssumeRoleWithWebIdentity&quot;
            )
        )

        bucket = s3.Bucket(
            self,
            f&quot;example_bucket&quot;,
            bucket_name=&quot;cdk-github-actions-demo&quot;,
            encryption=s3.BucketEncryption.S3_MANAGED,
            enforce_ssl=True,
            block_public_access=s3.BlockPublicAccess.BLOCK_ALL,
            removal_policy=cdk.RemovalPolicy.DESTROY,
            auto_delete_objects=True
        )

        # Give the role permissions to read / write to the bucket
        bucket.grant_read_write(github_actions_role)
</code></pre>
<p>You can then reference this in your pipeline and run AWS CLI / SDK commands using these credentials. Notice that the snippet references <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets"" rel=""noreferrer"">Github Encrypted Secrets</a>, I recommend leveraging this functionality:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: Example CDK Pipeline

on:
  push:
    branches: [ main ]

jobs:
  build:
    name: Emulate build step
    runs-on: ubuntu-latest

    steps:
    - name: Checking out repository
      uses: actions/checkout@v2
    - name: &quot;Upload artifacts&quot;
      uses: actions/upload-artifact@v2
      with:
        name: build-artifacts
        path: ${{ github.workspace }}/resources

  deploy:
    needs: build
    name: Deploy build artifacts to S3
    runs-on: ubuntu-latest
    # These permissions are needed to interact with GitHub's OIDC Token endpoint.
    permissions:
      id-token: write
      contents: read

    steps:
    - name: &quot;Download build artifacts&quot;
      uses: actions/download-artifact@v2
      with:
        name: build-artifacts
        path: ${{ github.workspace }}/resources

    - name: Configure AWS credentials from Test account
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-region: us-east-1
        role-to-assume: ${{ secrets.AWS_ROLE_FOR_GITHUB }}
        role-session-name: GitHubActions
    - run: aws sts get-caller-identity
    - name: Copy files to the test website with the AWS CLI
      run: |
        aws s3 sync ./resources s3://${{ secrets.BUCKET_NAME }}
</code></pre>
<p>For a full example on how to set this up using the CDK you can take a look at the <a href=""https://github.com/arbitraryrw/cdk-github-actions-demo"" rel=""noreferrer"">cdk-github-actions-demo</a> repo I set up.</p>
","17412658",""
"74890717","58643905","2022-12-22 15:35:44","2","<p>I was hitting my head against the wall on the same thing for a while.
In my case the setting <code>profile = default </code> was the issue.</p>
<p>I was able to remove that from my script and only having env. If I had both it would throw an error.</p>
<pre><code>env:
    AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
    AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    AWS_DEFAULT_REGION: 'us-east-1'
</code></pre>
","12597634",""
"59095924","59060710","2019-11-28 20:43:20","0","<blockquote>
  <p>1) Which images are available for use in the build? Can I use one of my public Docker Hub images as a base image so that I can spare myself installing the linux dependencies and gems?</p>
</blockquote>

<p>Yes ! Feel free to use your image with the keyword <strong>uses in your first step</strong> like that :</p>

<pre><code>- uses: docker://{host}/{image}:{tag}
</code></pre>

<blockquote>
  <p>2) How can I configure MongoDB as a service? Is there an image available for that?</p>
</blockquote>

<p>You can do like that :</p>

<pre><code>services:
  mongodb:
    image: mongo:3.4.23
    ports:
      - 27017:27017
</code></pre>

<p>Also, there is <a href=""https://dev.to/s_abderemane/how-to-use-docker-services-in-github-actions-6ce"" rel=""nofollow noreferrer"">an article</a> about Docker services maybe it can helps you to better understand services in Github Actions.</p>
","7087644",""
"59242979","59240304","2019-12-09 05:25:54","0","<p>The <a href=""https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners#windows-server-2019"" rel=""nofollow noreferrer"">windows environment</a> comes with <a href=""https://chocolatey.org/"" rel=""nofollow noreferrer""><code>chocolatey</code></a> package manager. So just do:</p>

<pre><code>run: choco --yes install k6
</code></pre>

<p>See: <a href=""https://chocolatey.org/packages/k6"" rel=""nofollow noreferrer"">https://chocolatey.org/packages/k6</a></p>
","2089675",""
"59869619","59474920","2020-01-22 23:21:51","0","<ol>
<li>Try and validate your code using <a href=""https://yamlvalidator.com/"" rel=""nofollow noreferrer"">yaml validator</a>.  </li>
<li>Make sure you've added your azure-devops-token onto your GitHub project settings for Secrets page. </li>
<li>Try and lower case the <code>Azure/pipelines@v1</code> to <code>azure/pipelines@v1</code>. </li>
</ol>

<p>Otherwise, your code looks very similar to the same code I run and it's working for me.  </p>
","7988162",""
"59567187","59566458","2020-01-02 17:00:43","1","<p>Using <a href=""https://github.com/marketplace/actions/github-push"" rel=""nofollow noreferrer"">GitHub Push by ad-m</a> fixed my issue. I'm pretty sure that I already tested this action.</p>
","5663348",""
"61238073","60157702","2020-04-15 20:29:55","2","<p>I hope this helps. I used this for my workflow, current branch is dev and I am firing the action when a push to the branch occurs.</p>

<pre><code>name: Staging deployment

on:
  push:
    branches:
      - dev

jobs:
  build:
    runs-on: ubuntu-latest

steps:
  - uses: actions/checkout@v1

  - name: Add api remote origin
    run: |
      git remote add heroku-api https://heroku:${{ secrets.HEROKU_API_KEY }}@git.heroku.com/${{ secrets.HEROKU_SERVE_APP_NAME }}.git
  - name: Deploy api to Heroku
    run: |
      git subtree push --prefix server heroku-api master
  - name: Add frontend remote origin
    run: |
      git remote add heroku-frontend https://heroku:${{ secrets.HEROKU_API_KEY }}@git.heroku.com/${{ secrets.HEROKU_FRONTEND_APP_NAME }}.git
  - name: Deploy frontend to Heroku
    run: |
      git subtree push --prefix frontend heroku-frontend master
</code></pre>

<p>Ideally you could simplify this further by removing the step for setting a remote and use the url to Heroku directly at the deploy step.</p>
","5682092",""
"60826105","60176044","2020-03-24 06:46:48","-4","<p>You need to define your environment variables in ""Secrets"" section of your repository. Then you can simply use your secrets in your workflow.</p>

<p>Example usage:</p>

<pre><code>- uses: some-action@v1
  env:
    API_KEY: ${{ secrets.API_KEY }}
    SECRET_ID: ${{ secrets.SECRET_ID }}
  with:
    password: ${{ secrets.MY_PASSWORD }}

</code></pre>

<p>Here is the documentation:</p>

<p><a href=""https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets"" rel=""nofollow noreferrer"">https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets</a></p>
","470214",""
"61734454","60176044","2020-05-11 16:24:06","10","<p>Edit:
You were using Circleci Contexts, so with that you had a set of secrets of each env. I know they are working to bring secrets to org level, and maybe team level... there is no info if they will create sort of contexts like we have in CCI.</p>

<p>I have thought on adding the env as prefix of the secret name like STAGE_GITHUB_KEY or INTEGRATION_GITHUB_KEY using ${env}_GITHUB_KEY on the yml as a workaround for now... What do you think?</p>

<p>--- Original answer:
If I understand you well, you already have the dotenv files stored somewhere and you want to inject all those secrets into the steps, without having to manually add them to github secrets and do the mapping in each workflow you migrate... right?</p>

<p>There is an action made by someone that reads a dotenv file and put its values into ouputs, so you can use them linked in further steps. Here is the link: <a href=""https://github.com/marketplace/actions/dotenv-action"" rel=""noreferrer"">https://github.com/marketplace/actions/dotenv-action</a></p>

<p>Whatever is present in the .env file will be converted into an output variable. For example .env file with content:</p>

<pre><code>VERSION=1.0
AUTHOR=Mickey Mouse
</code></pre>

<p>You do:</p>

<pre><code>id: dotenv
uses: ./.github/actions/dotenv-action
</code></pre>

<p>Then later you can refer to the alpine version like this ${{ steps.dotenv.outputs.version }}</p>
","7358206",""
"63350136","60176044","2020-08-11 01:13:32","231","<p>A quick solution here could be having a step to manually create the <code>.env</code> file before you need it.</p>
<pre><code>      - name: 'Create env file'
        run: |
          touch .env
          echo API_ENDPOINT=&quot;https://xxx.execute-api.us-west-2.amazonaws.com&quot; &gt;&gt; .env
          echo API_KEY=${{ secrets.API_KEY }} &gt;&gt; .env
          cat .env
</code></pre>
","2444877",""
"64452700","60176044","2020-10-20 20:13:19","41","<p>The easiest way to do this is to create the .env file as a github secret and then create the .env file in your action.<br />
So step 1 is to create the .env files as a secret in github as a base64 encoded string:<br>
<code>openssl base64 -A -in qa.env -out qa.txt</code><br>
or<br>
<code>cat qa.env | base64 -w 0 &gt; qa.txt</code><br>
Then in you action, you can do something like</p>
<pre><code>- name: Do Something with env files
  env:
    QA_ENV_FILE: ${{ secrets.QA_ENV_FILE }}
    PROD_ENV_FILE: ${{ secrets.PROD_ENV_FILE }}
  run: |
    [ &quot;$YOUR_ENVIRONMENT&quot; = qa ] &amp;&amp; echo $QA_ENV_FILE | base64 --decode &gt; .env
    [ &quot;$YOUR_ENVIRONMENT&quot; = prod ] &amp;&amp; echo $PROD_ENV_FILE | base64 --decode &gt; .env
</code></pre>
<p>There are a number of ways for determining <code>$YOUR_ENVIRONMENT</code> but usually this can be extracted from the <code>GITHUB_REF</code> object.  You applications should be able to read from the .env files as needed.</p>
","6895064",""
"65899220","60176044","2021-01-26 10:01:39","4","<p>Another alternative is to use the <a href=""https://docs.github.com/en/actions/reference/environments"" rel=""nofollow noreferrer"">Environments</a> feature from github. Although that isn't available on private repos in the free plan.
You could have scoped variables, at repository, profile/organization level and environment. The configuration variables closer to the repository takes precedence over the others.</p>
","3746240",""
"67543246","60176044","2021-05-15 04:24:30","43","<p>I would suggest 3 pretty simple ways to engage your <code>.env</code> file variables in the GitHub Actions workflow. They differ based on whether you store the file in your repository (the worst practice) or keep it out of it (the best practice).</p>
<ol>
<li><p>You keep your <code>.env</code> file in the repository:</p>
<ul>
<li>There are some <a href=""https://duckduckgo.com/?q=github+actions+dotenv&amp;atb=v242-1&amp;ia=web&amp;iai=r1-1&amp;page=1&amp;sexp=%7B%22biaexp%22%3A%22b%22%2C%22msvrtexp%22%3A%22b%22%2C%22earlydeep%22%3A%22a%22%7D"" rel=""nofollow noreferrer"">ready-made actions</a> that allow to read the <code>.env</code> variables (e.g. <a href=""https://github.com/marketplace/actions/dotenv-action"" rel=""nofollow noreferrer"">Dotenv Action</a>,<a href=""https://github.com/marketplace/actions/simple-dotenv"" rel=""nofollow noreferrer"">Simple Dotenv</a>).</li>
</ul>
</li>
<li><p>(<em>simple, manual, annoying when update <code>.env</code> variables</em>) You keep your file out of your repository (keep there and maintain updated <code>.env.example</code> instead):</p>
<ul>
<li><p>You manually copy the content of the respective <code>.env</code>    files (say <code>.env.stage</code>, <code>.env.production</code>) into the respective GitHub Actions <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets"" rel=""nofollow noreferrer"">secret variables</a> (say <code>WEBSITE_ENV_STAGE</code>, <code>WEBSITE_ENV_PRODUCTION</code>).</p>
</li>
<li><p>Then at your GitHub Actions workflow script create the <code>.env</code> file from the desired variable like this <code>echo &quot;${{secrets.WEBSITE_ENV_STAGE }}&quot; &gt; .env</code> and use it in the workflow.</p>
</li>
</ul>
</li>
<li><p>(<em>a bit more involved though prepare it once, then change your <code>.env</code> variables at the local machine, then sync these at GitHub with one click</em>) As in item 2 above, the file is out of the repository.</p>
<ul>
<li>Now you use the GitHub Actions API to <a href=""https://docs.github.com/en/rest/reference/actions#create-or-update-a-repository-secret"" rel=""nofollow noreferrer"">create or update the secrets</a>. On your local machine in the <code>dev</code> environment you write the NodeJS script that calls the API endpoint and write the <code>.env</code> files to the desired GitHub Actions secret variable (say as above into <code>WEBSITE_ENV_STAGE</code> or to both stage and production variables at once);</li>
</ul>
</li>
</ol>
<p>This is pretty wide choice of ways to engage the <code>.env</code> files's variables in the workflow. Use any matching your preference and circumstances.</p>
<p>Just for information, there is the 4th way which engages some 3rd party services like <a href=""https://www.dotenv.org/vault"" rel=""nofollow noreferrer"">Dotenv Vault</a> or <a href=""https://www.vaultproject.io/"" rel=""nofollow noreferrer"">HasiCorp Vault</a> (there are more of the kind) where you keep you secret variables to read these to create <code>.env</code> file at build time with your CI/CD pipeline. Read there for details.</p>
","6597265",""
"68975466","60176044","2021-08-29 17:39:29","0","<p>I was having the same issue. What I wanted was to upload a .env file to my server instead of defining the env variables in my Github repo. Since I was not tracking my .env file so every time my workflow ran the .env file got deleted. So what I did was :</p>
<ol>
<li>Added the <code>.env</code> file in the project root directory in my server.</li>
<li>Added <code>clean: false</code> under <code>with</code> key in my <code>actions/checkout@v2</code> in my workflow</li>
</ol>
<p>eg:</p>
<pre><code>jobs:
  build:

    runs-on: self-hosted

    strategy:
      matrix:
        node-version: [14.x]
       
    - uses: actions/checkout@v2
      with: 
        clean: 'false'
</code></pre>
<p>This prevents git from deleting untracked files like .env. For more info see: <a href=""https://github.com/actions/checkout"" rel=""nofollow noreferrer"">actions/checkout</a></p>
","16781183",""
"71030893","60176044","2022-02-08 08:46:36","13","<p>You can also use a dedicated <code>github action</code> from github-marketplace to create <code>.env</code> files.</p>
<p>Example usage:</p>
<pre><code>name: Create envfile

on: [push]

jobs:

  create-envfile:
 
    runs-on: ubuntu-18.04
 
    steps:
    - name: Make envfile
      uses: SpicyPizza/create-envfile@v1
      with:
        envkey_DEBUG: false
        envkey_SOME_API_KEY: &quot;123456abcdef&quot;
        envkey_SECRET_KEY: ${{ secrets.SECRET_KEY }}
        file_name: .env
</code></pre>
<p>Depending on your values defined for secrets in github repo, this will create a <code>.env</code> file like below:</p>
<pre><code>DEBUG: false
SOME_API_KEY: &quot;123456abcdef&quot;
SECRET_KEY: password123
</code></pre>
<p>More info: <a href=""https://github.com/marketplace/actions/create-env-file"" rel=""noreferrer"">https://github.com/marketplace/actions/create-env-file</a></p>
","2339586",""
"71166556","60176044","2022-02-17 23:15:54","3","<p>I tried using the accepted solution but GitHub actions were complaining about the shell commands. I kept getting this error: <code>line 3: unexpected EOF while looking for matching ``'</code></p>
<p>Instead of referencing the secrets directly in the shell script, I had to pass them in separately.</p>
<pre><code>  - name: Create env file
    run: |
      touch .env
      echo POSTGRES_USER=${POSTGRES_USER} &gt;&gt; .env
      echo POSTGRES_PASSWORD=${POSTGRES_PASSWORD} &gt;&gt; .env
      cat .env
    env: 
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }} 
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }} 
</code></pre>
","7776992",""
"71351918","60176044","2022-03-04 13:08:23","1","<p>One more approach would be doing something as described in <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets#limits-for-secrets"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/security-guides/encrypted-secrets#limits-for-secrets</a></p>
<p>So basically treating your <code>.env</code> file as a &quot;large secret&quot;. In this case, the encrypted <code>.env</code> file is kept commited in your repo, which should be fine. Then in your action have a step to decrypt the <code>.env</code> file.</p>
<p>This removes the overhead of having to create each individual secret inside your <code>.env</code> as a Github secret. The only Github secret to maintain in this case, is one for the encryption password. If you have multiple <code>.env</code> files such as <code>qa.env</code>, <code>prod.env</code>, etc... I would strongly suggest using a different encryption password for each, and then store each encryption passwords as an &quot;environment secret&quot; in Github instead of &quot;repo secret&quot; (if using Github environments is your thing. See <a href=""https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment</a>).</p>
<p>If you don't want to commit the (encrypted) <code>.env</code> file in you repo, then I would go with the base64 approach described in <a href=""https://stackoverflow.com/a/64452700/1806782"">https://stackoverflow.com/a/64452700/1806782</a> (which is simmilar to what's in <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets#storing-base64-binary-blobs-as-secrets"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/security-guides/encrypted-secrets#storing-base64-binary-blobs-as-secrets</a>) and then create a new Github secret to host the encoded contents.</p>
<p>For those like me with aversion to manual repetitive tasks, Github secret creation can these days easily be scripted with the Github CLI tool. See
<a href=""https://cli.github.com/manual/gh_secret_set"" rel=""nofollow noreferrer"">https://cli.github.com/manual/gh_secret_set</a> . It also supports 'batch' creation of secrets from env files (see the <code>-f</code>, <code>--env-file</code> flags)</p>
","1806782",""
"72699083","60176044","2022-06-21 10:20:11","6","<p>You can export all secrets to environment variables and do everything from a script.</p>
<p>I created an action exactly for that - takes all the secrets and exports them to environment variables.</p>
<p>An example would be:</p>
<pre><code>- run: echo &quot;Value of MY_SECRET1: $MY_SECRET1&quot;
  env:
    MY_SECRET1: ${{ secrets.MY_SECRET1 }}
    MY_SECRET2: ${{ secrets.MY_SECRET2 }}
    MY_SECRET3: ${{ secrets.MY_SECRET3 }}
    MY_SECRET4: ${{ secrets.MY_SECRET4 }}
    MY_SECRET5: ${{ secrets.MY_SECRET5 }}
    MY_SECRET6: ${{ secrets.MY_SECRET6 }}
    ...
</code></pre>
<p>You could convert it to:</p>
<pre><code>- uses: oNaiPs/secrets-to-env-action@v1
  with:
    secrets: ${{ toJSON(secrets) }}
- run: echo &quot;Value of MY_SECRET1: $MY_SECRET1&quot;
</code></pre>
<p>Link to the action, which contains more documentation about configuration: <a href=""https://github.com/oNaiPs/secrets-to-env-action"" rel=""noreferrer"">https://github.com/oNaiPs/secrets-to-env-action</a></p>
","1380301",""
"73359709","60176044","2022-08-15 10:26:39","0","<p>inspired by <a href=""https://stackoverflow.com/a/67543246/1238150"">Valentine Shis answer above</a>, I created a GitHub Action for this use-case and the one I had at the time while reading this thread.</p>
<p>GitHub Action: <a href=""https://github.com/marketplace/actions/next-env"" rel=""nofollow noreferrer"">next-env</a></p>
<blockquote>
<p>GitHub Action to read .env.[development|test|production][.local] files in Next.js (but also non Next.js) projects and add variables as secrets to GITHUB_ENV.</p>
</blockquote>
<p>Despite the name, it also works in non-Next.js projects as it uses a decoupled package of the Next ecosystem.</p>
","1238150",""
"77150212","60176044","2023-09-21 12:24:45","3","<p>Btw you can also do <code>gh secret set -f .env</code> if you have the github cli!</p>
","3105372",""
"77376038","60176044","2023-10-27 17:27:44","5","<p>The most modern alternative is to use a <code>.env.vault</code> file.</p>
<p>Here's a <a href=""https://www.dotenv.org/docs/languages/nodejs/github-actions"" rel=""noreferrer"">NodeJS Guide on how to use a <code>.env.vault</code> file with GitHub Actions</a></p>
<p>It boils down to 3 steps:</p>
<ol>
<li>Build your encrypted <code>.env.vault</code> file and commit that safely to code. This contains an encrypted copy of your CI secrets.</li>
<li>Set a single <code>DOTENV_KEY</code> environment variable on GitHub Actions</li>
<li>When the CI runs it will use the <code>DOTENV_KEY</code> to decrypt the contents of your <code>.env.vault</code> and inject your environment variables just in time.</li>
</ol>
<p>This approach is a little more work to initially set up (familiarizing yourself with the new .env.vault file format), but then it has the following benefits:</p>
<ul>
<li>No more scattering your secrets across multiple third parties like GitHub Actions that could leak them someday (like what happened with <a href=""https://techcrunch.com/2023/01/05/circleci-breach/"" rel=""noreferrer"">CircleCi breach</a>)</li>
<li>You can manage and check your secrets from one central place (rather than having to check GitHub Actions UI to see the value of a secret)</li>
<li>If you move CIs everything still just works. You just have to set again that single <code>DOTENV_KEY</code>, not a hundred others on the ci server. All your secrets and config are still encrypted inside your <code>.env.vault</code> file which lives safely in your repository.</li>
<li>An attacker needs access to both your <code>DOTENV_KEY</code> and your <code>.env.vault</code> file to gain access to your secrets/config. So if GitHub Actions ever has a leak of their CI secrets, your secrets will still be safe because the attacker will only have your <code>DOTENV_KEY</code> and not your <code>.env.vault</code> file. This will save you the time and annoyance of having to rotate all your secrets.</li>
</ul>
<p>Hope this is useful. Full disclosure: I am the pioneer of <a href=""https://github.com/motdotla/dotenv"" rel=""noreferrer"">dotenv</a> and also run the <a href=""https://dotenv.org"" rel=""noreferrer"">Dotenv.org</a> service. That said, the mechanism to generate your <code>.env.vault</code> file is completely open, local, and free. It's just a file format that uses AES-256 GCM encryption. I wanted the same (or close to) elegance of a .env file but with added security for production and ci deployments. <a href=""https://github.com/dotenv-org/dotenv-vault#how-do-i-use--locally-managed-dotenv-vault"" rel=""noreferrer"">See here for how to use the local only commands</a> or use <a href=""https://dotenv.org"" rel=""noreferrer"">dotenv.org for the hosted solution</a>.</p>
","18103496",""
"78142067","60176044","2024-03-11 16:13:37","1","<p>I created a GitHub Action specifically designed for utilizing your environment variables within your .env files, eliminating the need to set up secrets in GitHub project settings. Check it out here: <a href=""https://github.com/zdeneklapes/dotenv-vault-action"" rel=""nofollow noreferrer"">https://github.com/zdeneklapes/dotenv-vault-action</a>.</p>
<p>It can download the .env file of your choice and will delete all downloaded .env files as a Post Job (after all jobs are completed)!</p>
<p>You still need to set at least 1 secret, it is your <code>DOTENV_ME</code>.</p>
<h2>How to load <code>.env</code> variables into the environment?</h2>
<p>When the <code>.env</code> file is downloaded don't forget to load your environment variables using the command <code>source .env</code>.</p>
<h4>Example:</h4>
<pre class=""lang-yaml prettyprint-override""><code>- uses: zdeneklapes/dotenv-vault-action@v1
        with:
          dotenvMe: ${{ secrets.DOTENV_ME }}
          stage: &quot;ci&quot;
          move: &quot;false&quot;
- run: |
    source .env.ci
    ssh &quot;${SSH_USER}@${SSH_HOST}&quot; &quot;
    cd ${DIR_SSH_PROJECT_PRODUCTION} || exit
    docker compose -f docker-compose.prod.yml up --build
    cd - || exit
    &quot;
</code></pre>
","14471542",""
"78412095","60176044","2024-05-01 05:06:00","0","<p>Sorry I'm late, but another solution could be to preserve the basic structure of the .env file in your prod branch if you want to avoid setting a large number of variables individually and you want to prevent putting your entire .env content into a single GitHub secret variable.</p>
<p>Example of your basic .env file located in the prod branch:</p>
<pre><code>APP_NAME=App
APP_URL=http://localhost
APP_ENVIROMENT=local
APP_DEBUG=true
DB_DRIVER=mysql
CACHE_DRIVER=redis
SESSION_DRIVER=redis
</code></pre>
<p>Then only edit the variables that you want to change for prod in your actions workflow.</p>
<ul>
<li><p>Remember to add the env variables you want to change to your secrets tab on GitHub for actions.</p>
<pre><code>- name: 'Update env file for prod'
  run: |
    sed -i 's|APP_URL=http://localhost|APP_URL=${{ secrets.APP_URL }}|' .env
    sed -i 's|APP_ENVIROMENT=local/APP_ENVIROMENT=${{ secrets.APP_ENVIROMENT }}|' .env
    sed -i 's|APP_DEBUG=true/APP_DEBUG=${{ secrets.APP_DEBUG }}|' .env
</code></pre>
</li>
</ul>
<p>NOTE: The Linux sed command for editing an .env file has not been tested. You can use your own if it does not work as expected.</p>
","8773111",""
"65351316","60840243","2020-12-18 03:08:22","12","<p>Using base64 we encode the service account JSON and pass it via environment variable. Then before calling the <code>activate-service-account</code> decode using the shell script.</p>
<p><strong>Sample code:</strong></p>
<pre class=""lang-bash prettyprint-override""><code>echo &quot;$GCP_CREDENTIALS&quot; &gt; gcp_credentials_enc.json
cat gcp_credentials_enc.json | base64 -d &gt; gcp_credentials.json
</code></pre>
","1173495",""
"75107847","60840243","2023-01-13 10:21:06","10","<p>You need to ensure it's handled correctly either at the YAML level (can be done using <code>|</code>):</p>
<pre><code>  - env:
      SSH_KEY: |
        ${{ secrets.SSH_KEY }}
</code></pre>
<p>Or if a command in bash ensure it's correctly interpreted. For example if you are doing:</p>
<p><code>echo ${{ secret.SSH_KEY }} </code></p>
<p>this should instead be quoted so it becomes:</p>
<p><code>echo &quot;${{ secret.SSH_KEY }}&quot;</code></p>
","1663462",""
"61049404","61048334","2020-04-05 20:57:09","1","<p>I found the easiest solution for my issue was to change the account the GitHub Actions service ran under.</p>

<p>I achieved this by using <code>powershell ""(Get-Service actions.runner.*).name""</code>to find the name of the GitHub Actions service.</p>

<p>And then running <code>sc config ""NAME_OF_YOUR_SERVICE"" obj= ""NT AUTHORITY\SYSTEM"" type= own</code> to update it to run as the system.</p>

<p><strong>EDIT:</strong></p>

<p>As @Lex Li says </p>

<blockquote>
  <p>A CI agent (for Azure Pipelines or GitHub Actions) should run under a
  dedicated account (on Windows usually a service account from Active
  Directory), so that you can tune its permissions on various resources.</p>
</blockquote>
","10642173",""
"61748039","61096521","2020-05-12 09:18:31","35","<p>As GitHub Actions is basically a container that runs commands, have you considered <em>define your key as a secret on your project and then importing it in your Github Action definition</em>?</p>
<p>Here are the steps I previously used on a project to publish the generated artifacts to Sonatype's staging repository:</p>
<ul>
<li>Open a terminal window.</li>
<li>If you don't know your key ID, search it by e-mail: <code>gpg --list-secret-keys user@example.com</code></li>
<li>Export your key as Base64: <code>gpg --export-secret-keys YOUR_ID_HERE | base64 &gt; private.key</code></li>
<li>In your Github project, create a new Secret named <strong>GPG_SIGNING_KEY</strong> and paste the Base64 content of your key.</li>
<li>In your yml workflow file, include a step to import the key from your just defined secret.</li>
</ul>
<pre><code>- name: Configure GPG Key
  run: |
    echo -n &quot;$GPG_SIGNING_KEY&quot; | base64 --decode | gpg --import
  env:
    GPG_SIGNING_KEY: ${{ secrets.GPG_SIGNING_KEY }}
</code></pre>
<p>So far, it works very well although there are a few limitations I couldn't solve:</p>
<ul>
<li>Your GPG Key should not be protected by a password. I couldn't figure out a way to import the protected keys without being asked for their secret.</li>
<li>I couldn't find a way to use my GitHub GPG Key for this process.</li>
</ul>
<p>Just in case, <a href=""https://github.com/Skullabs/injector/blob/master/.github/workflows/release.yml"" rel=""noreferrer"">here</a> is a working example of a project using this approach to publish Maven <em>artifacts</em>. The only difference from the steps above, though, is that the commands were externalized into <a href=""https://github.com/Skullabs/injector/blob/master/builder.sh#L38"" rel=""noreferrer"">a bash script file</a>.</p>
","548685",""
"65658014","61096521","2021-01-10 20:13:09","2","<p>You can also use another plugin <a href=""https://www.simplify4u.org/sign-maven-plugin/"" rel=""nofollow noreferrer"">https://www.simplify4u.org/sign-maven-plugin/</a> for signing artifacts.</p>
<p><code>sign-maven-plugin</code> simply takes signing key and rest configuration items from environment variables without special configuration.</p>
<p>Another advantage of <code>sign-maven-plugin</code> is that you need not use profiles for activate or deactivate plugin, because when signing key is not preset for plugin, plugin skip execution without error.</p>
","3149528",""
"66218731","61096521","2021-02-16 04:34:02","25","<p>Adding a new answer, since this question is about using the GPG key in maven deployments in particular.</p>
<h1>No Manual Import is Required when Using Maven</h1>
<h2>Either use <code>maven-gpg-plugin</code> 3.2.0 or Newer</h2>
<p><a href=""https://issues.apache.org/jira/browse/MGPG-106"" rel=""nofollow noreferrer"">Since version 3.2.0</a>, you can configure the plugin to use a Bouncy Castle based signer that does not depend on external gpg processes. You can configure the plugin to use this signer like so:</p>
<pre class=""lang-xml prettyprint-override""><code>&lt;plugin&gt;
    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.4&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;sign-artifacts&lt;/id&gt;
            &lt;phase&gt;verify&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;sign&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;signer&gt;bc&lt;/signer&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>Now, all you need to do in you GitHub Actions is to define a couple of environment variables:</p>
<pre class=""lang-yaml prettyprint-override""><code>- name: Publish to Apache Maven Central
  run: mvn deploy
  env:
    OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
    OSSRH_TOKEN: ${{ secrets.OSSRH_TOKEN }}
    MAVEN_GPG_PASSPHRASE: ${{ secrets.RELEASES_GPG_PASSPHRASE }}
    MAVEN_GPG_KEY: ${{ secrets.RELEASES_GPG_PRIVATE_KEY }}
</code></pre>
<h2>Alternatively, the <code>setup-java</code> Action Can Set up Your GPG Agent</h2>
<p>But even when you need to use older versions of the <code>maven-gpg-plugin</code>, the <code>setup-java</code> action supports everything out of the box. There is an <a href=""https://github.com/actions/setup-java/blob/v3.11.0/docs/advanced-usage.md#Publishing-using-Apache-Maven"" rel=""nofollow noreferrer"">example in the docs</a>:</p>
<pre class=""lang-xml prettyprint-override""><code>&lt;plugin&gt;
    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.4&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;sign-artifacts&lt;/id&gt;
            &lt;phase&gt;verify&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;sign&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;gpgArguments&gt;
                    &lt;arg&gt;--pinentry-mode&lt;/arg&gt;
                    &lt;arg&gt;loopback&lt;/arg&gt;
                &lt;/gpgArguments&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<pre class=""lang-yaml prettyprint-override""><code>    - name: Set up Apache Maven Central
      uses: actions/setup-java@v3
      with: # running setup-java again overwrites the settings.xml
        java-version: 21
        distribution: 'temurin'
        cache: 'maven'
        server-id: ossrh # Value of the distributionManagement/repository/id field of the pom.xml
        server-username: OSSRH_USERNAME # env variable for username in deploy
        server-password: OSSRH_TOKEN # env variable for token in deploy
        gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }} # Value of the GPG private key to import
        gpg-passphrase: MAVEN_GPG_PASSPHRASE # env variable for GPG private key passphrase

    - name: Publish to Apache Maven Central
      run: mvn deploy
      env:
        OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
        OSSRH_TOKEN: ${{ secrets.OSSRH_TOKEN }}
        MAVEN_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
</code></pre>
<p>Note that the <code>setup-java</code> action configures Maven's <code>settings.xml</code> file for you automatically <em>and</em> imports the GPG key from the given stored secret.</p>
<p>Be aware, that during <code>setup-java</code> you only configure the <em>names</em> of the environment variables. I.e. you need to provide the (secret) values for these env variables in later steps, where you want to use them.</p>
","4014509",""
"66457517","61096521","2021-03-03 12:53:59","22","<p>Thank You everyone for your response. I now use this GitHub actions which makes the process much more simpler:</p>
<p>Step 1: Extract the secret key</p>
<pre><code>gpg --list-secret-keys --keyid-format LONG
gpg --export-secret-keys --armor {your_keyId}
</code></pre>
<p>Step 2: Store the extracted GPG key and passphrase as secrets</p>
<p>step 3: Include this step in your workflow</p>
<pre><code>- name: Import GPG Key
  uses: crazy-max/ghaction-import-gpg@v1
  env:
     GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
     PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
</code></pre>
","9590601",""
"75568891","61096521","2023-02-25 22:42:10","0","<p>I came up with the following solution (see <a href=""https://gist.github.com/vansergen/88eb7e71fea2e3bdaf6aa3e752371eb7"" rel=""nofollow noreferrer"">here</a>)</p>
<pre class=""lang-yaml prettyprint-override""><code>steps:
  - name: Import GPG key
    run: echo $GPG_KEY | base64 --decode | gpg --batch --import
    env:
      GPG_KEY: ${{ secrets.GPG_KEY }}

  - name: Add the custom gpg siging program that passes the passphrase to the gpg CLI
    run: |
      rm -rf /tmp/gpg.sh
      echo '#!/bin/bash' &gt;&gt; /tmp/gpg.sh
      echo 'gpg --batch --pinentry-mode=loopback --passphrase $GPG_KEY_PASSPHRASE $@' &gt;&gt; /tmp/gpg.sh
      chmod +x /tmp/gpg.sh

  - name: Setup git
    run: |
      git config commit.gpgsign true
      git config user.signingkey $GPG_KEY_ID
      git config gpg.program /tmp/gpg.sh
    env:
      GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
</code></pre>
","20644816",""
"61268185","61268184","2020-04-17 09:26:31","1","<p>I've created a simple CLI that can help you achieve that - <a href=""https://github.com/unfor19/githubsecrets"" rel=""nofollow noreferrer"">https://github.com/unfor19/githubsecrets</a> </p>

<p>This CLI is based on the official <a href=""https://developer.github.com/v3/actions/secrets/#secrets"" rel=""nofollow noreferrer"">GitHub Actions Secrets API</a></p>

<p>Install with pip</p>

<pre class=""lang-sh prettyprint-override""><code>$ pip install githubsecrets
...
$ ghs --help
...
</code></pre>

<p>Or use with Docker; you must supply all arguments, prompts are not available in Docker mode</p>

<p>macOS and Linux</p>

<pre class=""lang-sh prettyprint-override""><code>$ docker run -v $HOME:/root unfor19/githubsecrets --help
Usage: ghs [OPTIONS] COMMAND [ARGS]...
</code></pre>

<p>Windows</p>

<pre class=""lang-sh prettyprint-override""><code>$ docker run --rm -v c:/Temp:/root unfor19/githubsecrets --help
Usage: ghs [OPTIONS] COMMAND [ARGS]...
</code></pre>

<p><img src=""https://githubsecrets.s3-eu-west-1.amazonaws.com/githubsecrets-demo.gif"" alt=""Usage-Demo""></p>
","5285732",""
"61268481","61268184","2020-04-17 09:43:29","1","<p>Another one, in ruby:</p>

<pre><code>$ gem install secret_hub
</code></pre>

<p>also using the official Github API, and supports bulk operations.</p>

<p><a href=""https://github.com/dannyben/secret_hub"" rel=""nofollow noreferrer"">https://github.com/dannyben/secret_hub</a></p>

<p>Full disclosure: I wrote it, following <a href=""https://github.community/t5/GitHub-Actions/Secrets-on-Team-and-Organization-level/td-p/29745"" rel=""nofollow noreferrer"">this discussion</a> about the missing feature in GitHub to have organization-level secrets.</p>
","413924",""
"66294974","61289322","2021-02-20 18:12:16","0","<p>Example file below which I managed to use to complete this task.</p>
<pre class=""lang-yaml prettyprint-override""><code>on:
  pull_request:
    types: [closed]
    branches: [master]
  
name: Create Release with merge file

jobs:
  build:
    runs-on: windows-latest
    if: github.event.pull_request.merged == true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Set up Python 3.7.9
        uses: actions/setup-python@v1
        with:
          python-version: 3.7.9
          architecture: 'x64'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pynsist==2.5
          pip install six==1.14.0
          pip install retrying==1.3.3
          pip install numpy==1.18.1
          pip install requests==2.22.0
          pip install urllib3==1.25.8
          pip install chardet==3.0.4
          pip install certifi==2019.11.28
          pip install idna==2.8
      - name: Install 7Zip
        run: |
          choco install 7zip
      - name: Run the build script
        run: |
          python App001_Build.py
</code></pre>
","12446456",""
"61827072","61823476","2020-05-15 19:39:03","1","<p>A quick Google search led me to this action: <a href=""https://github.com/marketplace/actions/run-java-checkstyle"" rel=""nofollow noreferrer"">https://github.com/marketplace/actions/run-java-checkstyle</a></p>

<p>Haven't tried it myself, but worth a shot to use as a base if it doesn't work out.</p>
","2382650",""
"64233861","61954361","2020-10-06 21:12:30","2","<p>Use</p>
<pre class=""lang-sh prettyprint-override""><code>curl \
  -H &quot;Accept: application/vnd.github.v3+json&quot; \
  https://api.github.com/repos/&lt;github-user&gt;/&lt;repository&gt;/actions/workflows/&lt;workflow.yaml&gt;/runs
</code></pre>
<p><a href=""https://docs.github.com/en/free-pro-team@latest/rest/reference/actions#list-workflow-runs"" rel=""nofollow noreferrer"">https://docs.github.com/en/free-pro-team@latest/rest/reference/actions#list-workflow-runs</a></p>
<p>This will return a JSON with the following structure:</p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;total_count&quot;: 1,
  &quot;workflow_runs&quot;: [
    {
      &quot;id&quot;: 30433642,
      &quot;node_id&quot;: &quot;MDEyOldvcmtmbG93IFJ1bjI2OTI4OQ==&quot;,
      &quot;head_branch&quot;: &quot;master&quot;,
      &quot;head_sha&quot;: &quot;acb5820ced9479c074f688cc328bf03f341a511d&quot;,
      &quot;run_number&quot;: 562,
      &quot;event&quot;: &quot;push&quot;,
      &quot;status&quot;: &quot;queued&quot;,
      &quot;conclusion&quot;: null,
      &quot;workflow_id&quot;: 159038,
      &quot;url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642&quot;,
      &quot;html_url&quot;: &quot;https://github.com/octo-org/octo-repo/actions/runs/30433642&quot;,
      &quot;pull_requests&quot;: [],
      &quot;created_at&quot;: &quot;2020-01-22T19:33:08Z&quot;,
      &quot;updated_at&quot;: &quot;2020-01-22T19:33:08Z&quot;,
      &quot;jobs_url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/jobs&quot;,
      &quot;logs_url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/logs&quot;,
      &quot;check_suite_url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/check-suites/414944374&quot;,
      &quot;artifacts_url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/artifacts&quot;,
      &quot;cancel_url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/cancel&quot;,
      &quot;rerun_url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/rerun&quot;,
      &quot;workflow_url&quot;: &quot;https://api.github.com/repos/octo-org/octo-repo/actions/workflows/159038&quot;,
      &quot;head_commit&quot;: {...},
      &quot;repository&quot;: {...},
      &quot;head_repository&quot;: {...}
  ]
}
</code></pre>
<p>Access the <code>jobs_url</code> with a PAT that has repository admin rights.</p>
","3241243",""
"67113703","61954361","2021-04-15 17:59:35","9","<p>With the latest <a href=""https://cli.github.com/"" rel=""noreferrer""><code>cli/cli</code> tool named <code>gh</code></a> (1.9.0+), you can simply do<br />
(from your terminal, <em>without</em> going to <code>github.com</code>):</p>
<pre><code>gh run view &lt;jobId&gt; --log 
# or
gh run view &lt;jobId&gt; --log-failed
</code></pre>
<p>See &quot;<a href=""https://github.blog/2021-04-15-work-with-github-actions-in-your-terminal-with-github-cli/"" rel=""noreferrer"">Work with GitHub Actions in your terminal with GitHub CLI</a>&quot;</p>
<blockquote>
<p>With the new <strong><code>gh run list</code></strong>, you receive an overview of all types of workflow runs whether they were triggered via a push, pull request, webhook, or manual event.</p>
<p>To drill down into the details of a single run, you can use <strong><code>gh run view</code></strong>, optionally going into as much detail as the individual steps of a job.</p>
<p>For more mysterious failures, you can combine a tool like grep with <strong><code>gh run view --log</code></strong> to search across a run’s entire log output.</p>
<p>If <code>--log</code> is too much information, <strong><code>gh run --log-failed</code></strong> will output only the log lines for individual steps that failed.<br />
This is great for getting right to the logs for a failed step instead of having to run <code>grep</code> yourself.</p>
</blockquote>
<p>And with <a href=""https://github.com/cli/cli/releases/tag/v2.4.0"" rel=""noreferrer"">GitHub CLI 2.4.0</a> (Dec. 2021), <code>gh run list</code> comes with a <code>--json</code> flag for JSON export.</p>
","6309",""
"61985092","61979870","2020-05-24 11:12:01","0","<p>Generally, it is not possible to write out YAML exactly the way it was written when you loaded it, see <a href=""https://stackoverflow.com/q/60891174/347964"">this question</a>.</p>

<p>You can follow the advice in the answer there: Load to node graph instead of native objects. It looks like this in PyYAML:</p>

<pre class=""lang-py prettyprint-override""><code>import yaml
import io

input = """"""
xx: [x1, x2]
yy: [y1, y2, y3]
""""""

loader = yaml.Loader(input)
node = loader.get_single_node()

stream = io.StringIO()
dumper = yaml.Dumper(stream)
dumper.open()
dumper.serialize(node)
dumper.close()
print(stream.getvalue())
</code></pre>

<p>Output will be:</p>

<pre class=""lang-yaml prettyprint-override""><code>xx: [x1, x2]
yy: [y1, y2, y3]
</code></pre>

<p>This works because a <em>node</em> still remembers its original style (while the native data doesn't). It is still possible to alter the YAML structure, but you now need to create data as nodes instead of just manipulating the loaded Python data.</p>

<p>If you want to create your data in Python and dump in your preferred format, the easiest way to do that would probably be:</p>

<ul>
<li>create the data</li>
<li>dump it to a YAML string</li>
<li>load that string as node graph</li>
<li>walk the node graph and alter the <code>style</code> attribute of the nodes to your liking</li>
<li>represent the node graph as YAML again</li>
</ul>
","347964",""
"62364531","61979870","2020-06-13 19:14:37","5","<p>As pointed out by @Tsyvarev my desired behavior can be triggered by</p>
<pre><code>yaml.dump({&quot;A&quot;:[1,2,3],&quot;B&quot;:[4,5,6]}, default_flow_style=None)
</code></pre>
<p>The <a href=""https://pyyaml.org/wiki/PyYAMLDocumentation"" rel=""noreferrer"">official documentation</a> doesn't seem to define this <code>None</code> behavior though:</p>
<blockquote>
<p>By default, PyYAML chooses the style of a collection depending on whether it has nested collections. If a collection has nested collections, it will be assigned the block style. Otherwise it will have the flow style.</p>
<p>If you want collections to be always serialized in the block style, set the parameter <code>default_flow_style of dump()</code> to <code>False</code>.</p>
</blockquote>
","534298",""
"62633747","62591569","2020-06-29 08:08:33","1","<blockquote>
<p>Migrating Azure Pipelines Deployments to GitHub Actions</p>
</blockquote>
<p>Indeed, there is no such multi-stage feature for Github action at this moment.</p>
<p>Just as you suspect, we could create a deployment job to deploy the artifact. We could try to create a new job which <strong>needs</strong> the existing build job, in the new job, download the artifacts and push them to azure artifact, github packages, nuget:</p>
<pre><code>jobs:
  job_1:
    name: Build

  job_2:
    name: Deploy
    needs: job_1
    runs-on: windows-latest
    steps:
      - name: Download math result for job 1
      uses: actions/download-artifact@v1
      with:
        name: xxx
</code></pre>
<p>You could check the Github action <a href=""https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idneeds"" rel=""nofollow noreferrer"">jobs.&lt;job_id&gt;.needs</a> and <a href=""https://help.github.com/en/actions/configuring-and-managing-workflows/persisting-workflow-data-using-artifacts"" rel=""nofollow noreferrer"">the sample</a> for some more details.</p>
<p>Hope this helps.</p>
","7460777",""
"62784946","62784756","2020-07-07 22:39:38","3","<p><code>macOS</code> is what you looking for:</p>
<pre><code>- name: doing something on macOS
  if: runner.os == 'macOS'
</code></pre>
<p>You can refer the different <code>os</code> type in <a href=""https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#runner-context"" rel=""nofollow noreferrer""><code>runner</code> context doc</a>.</p>
","791609",""
"63648621","62908594","2020-08-29 15:22:07","3","<p>Try the --name option</p>
<pre><code>options: &gt;-
  --health-cmd pg_isready
  --health-interval 10s
  --health-timeout 5s
  --health-retries 5
  --name postgres 
</code></pre>
<p><a href=""https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idservices"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idservices</a></p>
<p>jobs.&lt;job_id&gt;.services.options: Additional Docker container resource options. For a list of options, see &quot;docker create options.&quot;</p>
<p>Another solution I've seen is using last created container</p>
<pre><code>docker exec -it $(docker ps --latest --quiet) bash
</code></pre>
","449683",""
"63229609","63226588","2020-08-03 12:39:36","1","<p>While <a href=""https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem"" rel=""nofollow noreferrer""><code>Get-ChildItem</code></a> does have an <code>-Exclude</code> parameter, it only operates on the <em>file-name</em> part, not on the full path.</p>
<p>Therefore, you must perform the exclusion filtering after the fact, using the negated form of <code>-like</code>, the <a href=""https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Comparison_Operators#-like"" rel=""nofollow noreferrer"">wildcard matching operator</a></p>
<pre><code>pylint ((Get-ChildItem -Recurse -Name -Filter *.py) -notlike 'exclude_dir/*')
</code></pre>
<p><sup>Note the use of <code>-Filter</code> rather than <code>-Include</code>, which speeds up the operation, because filtering happens at the source rather than being applied by PowerShell after the fact.</sup></p>
<p>However, given that you're seemingly only excluding a <em>single top-level</em> folder, you could try:</p>
<pre><code>pylint (Get-ChildItem -Recurse -Path * -Filter *.py -Exclude exclude_dir)
</code></pre>
<p>Note that I've omitted <code>-Name</code> in this case, because it wouldn't work properly in this scenario. As a result, the matching files are implicitly passed as full paths to <code>pylint</code>.</p>
<p>As of PowerShell 7.0, <code>-Name</code> exhibits several problematic behaviors, which are summarized in <a href=""https://stackoverflow.com/a/60040617/45375"">this answer</a>.</p>
","45375",""
"63293712","63288356","2020-08-07 00:51:56","7","<p>I don't think you can use <code>workflow_dispatch</code> to add/update checks on a PR. This seems to be confirmed by <a href=""https://github.community/t/workflow-dispatch-does-not-update-commit-status/125981/2"" rel=""noreferrer"">this response</a> to a similar question on the community forums.</p>
<p>Checks are only added/updated for the following events:</p>
<ul>
<li>pull_request</li>
<li>pull_request_review</li>
<li>pull_request_review_comment</li>
<li>pull_request_target</li>
<li>push</li>
</ul>
<p>So your manual operation needs to trigger one of these events to run. There are probably a number of different ways you can do this, depending on your use case. Just as an example, you could call the API to add a label and allow a <code>pull_request</code> workflow to execute on that type.</p>
<pre><code>on:
  pull_request:
    types: [labeled, opened, synchronize, reopened]
</code></pre>
<p>The other thing to note is that the API call (or git push) must use a PAT instead of <code>GITHUB_TOKEN</code>. This is to <a href=""https://docs.github.com/en/actions/reference/events-that-trigger-workflows#triggering-new-workflows-using-a-personal-access-token"" rel=""noreferrer"">allow further workflows</a> to execute.</p>
","11934042",""
"75510242","63288356","2023-02-20 14:04:56","3","<p>It is possible with some workaround. First, you have to identify the PR that invoked your workflow. If you need to use the <code>workflow_dispatch</code> trigger event, you can pass this PR number as input parameter. Otherwise, you mentioned you trigger this workflow on a specific comment so you could also use the <code>issue_comment</code> event which will give you the PR number as <code>github.event.issue.pull_request</code>.</p>
<p>Next, you have to find out the latest commit of this Pull Request. This depends on how your workflow got invoked:</p>
<ul>
<li>if you use the <code>issue_comment</code> event, you can use the <a href=""https://github.com/xt0rted/pull-request-comment-branch"" rel=""nofollow noreferrer"">xt0rted/pull-request-comment-branch</a> action to determine the right branch and commit</li>
<li>if you use the <code>workflow_dispatch</code> event, you can use the <a href=""https://github.com/actions/github-script"" rel=""nofollow noreferrer"">actions/github-script</a> action to run some query to get the right commit for a given PR number</li>
</ul>
<p>Finally, you can use the <a href=""https://github.com/myrotvorets/set-commit-status-action"" rel=""nofollow noreferrer"">myrotvorets/set-commit-status-action</a> action to attach the workflow result as check on the latest commit of the PR.</p>
<p>I wrote a blog post that describes this process in some more details: <a href=""https://dev.to/zirkelc/trigger-github-workflow-for-comment-on-pull-request-45l2"" rel=""nofollow noreferrer"">Trigger GitHub Workflow for Comments on Pull Request</a></p>
","1967693",""
"63681598","63672189","2020-09-01 04:55:32","3","<p>This is tricky because actions/cache depends on you putting the libraries in a specific folder that then can be cached and retrieved. And system files have a lot of dependencies which makes each library unique when it comes to this process.</p>
<p>Here are three options that you can take to accomplish this</p>
<p><strong>Path 1:</strong></p>
<p>We could look into installing the brew packages into a specific folder but we cannot do that per package but instead for the whole OS. But according to homebrew <a href=""https://github.com/Homebrew/brew/blob/664d0c67d5947605c914c4c56ebcfaa80cb6eca0/docs/Installation.md#untar-anywhere"" rel=""nofollow noreferrer"">https://github.com/Homebrew/brew/blob/664d0c67d5947605c914c4c56ebcfaa80cb6eca0/docs/Installation.md#untar-anywhere</a> it's not a good idea as there could be issues with packages not installing properly. Also this would basically be caching everything which at the end of the day we don't know if it'll be faster than just installing the latest packages you need.</p>
<p><strong>Path 2:</strong></p>
<p>Install the package as you normally would with brew and then copy binaries. The caveat here is that you will need to do this on a per library basis as dependencies some times can get out of hand.
Here is an example <a href=""https://stackoverflow.com/questions/59269850/caching-apt-packages-in-github-actions-workflow"">Caching APT packages in GitHub Actions workflow</a>
by going through this process with apt-get in linux, but you can follow same process with brew</p>
<p><strong>Path 3:</strong></p>
<p>Find or create your own docker file image that for which you keep up to date with the latest packages that you want. This would allow you to always have the latest and this will allow you to initialize your steps inside a container build from your docker image. This will then satisfy your system dependencies.</p>
<pre><code> jobs:
   ci:
     runs-on: ubuntu-latest
     container:
       image: &lt;your-personalized-docker-image&gt;
</code></pre>
","14167216",""
"65056232","63672189","2020-11-29 01:48:21","4","<p>In your workflow job configuration:</p>
<pre class=""lang-yaml prettyprint-override""><code>    steps:
    - name: Update Homebrew
      run: |
        brew update --preinstall
        cat &quot;$(brew --repository)/Library/Taps/homebrew/homebrew-core/Formula/foo.rb&quot; &gt; .github/brew-formulae
    - name: Configure Homebrew cache
      uses: actions/cache@v2
      with:
        path: |
          ~/Library/Caches/Homebrew/foo--*
          ~/Library/Caches/Homebrew/downloads/*--foo-*
        key: brew-${{ hashFiles('.github/brew-formulae') }}
        restore-keys: brew-
    - name: Install Homebrew dependencies
      run: |
        env HOMEBREW_NO_AUTO_UPDATE=1 brew install foo
</code></pre>
<p>Here <code>~/Library/Caches/Homebrew</code> corresponds to the output of <code>brew --cache</code>.</p>
<p>Rather than store the entire directory to the GitHub Actions cache, the above configuration will only store the files related to the &quot;foo&quot; package.  This is because the Homebrew cache directory on the macOS images provided by GitHub already contains files for the base Homebrew install (which you don't need to store again).</p>
<p>You should note that this cache is unlikely to speed up your workflow.  Installing Homebrew bottles (the default) will usually have similar performance to downloading from GitHub/Azure's own storage cache since the bottle files are served on bintray's CDN.</p>
","135385",""
"63678192","63676119","2020-08-31 21:06:40","4","<p>Your service doesn't have access to the local file. Make sure to create a volume and then you will be able to run your command. The below solution assumes file setup.cql exists at the root of your repo directory</p>
<p><strong>Repo Structure Assumption</strong></p>
<pre><code>repo/
  .github/workflows/your-worflow.yaml
  setup.cql
  ... any other files/dirs
</code></pre>
<p><strong>Workflow Update</strong></p>
<pre><code>services:
  cassandra:
    image: cassandra
    ports:
      - 9042:9042
    options: --health-cmd &quot;cqlsh --debug&quot; --health-interval 5s --health-retries 10
    volumes: 
       - ${{ github.workspace }}:/workspace
steps:
  - uses: actions/checkout@v2
  - run: docker exec -i ${{ job.services.cassandra.id }} cqlsh -f /workspace/setup.cql
</code></pre>
","14167216",""
"63692013","63691962","2020-09-01 16:44:18","0","<p>U need to host an external redis database because containers in GitHub Actions are isolated.
For other hand u can prepare a docker container with all you need for testing and then u can run the tests inside.</p>
<p>Un can take a look here <a href=""https://github.com/gonsandia/github-action-deploy"" rel=""nofollow noreferrer"">https://github.com/gonsandia/github-action-deploy</a>
Its a custom action where u define the dockerfile and the scripts to runs</p>
","6140038",""
"63694268","63691962","2020-09-01 19:32:54","2","<p>So I figured out what was the problem.
Docker network works only if you run your job inside container. And I had not.</p>
<p>Here is example <a href=""https://github.com/actions/example-services/blob/989ef69ed164330bee413f11ce9332d76f943af7/.github/workflows/mongodb-service.yml#L19"" rel=""nofollow noreferrer"">https://github.com/actions/example-services/blob/989ef69ed164330bee413f11ce9332d76f943af7/.github/workflows/mongodb-service.yml#L19</a></p>
<p>And a quote:</p>
<blockquote>
<p>runs all of the steps inside the specified container rather than on the VM host.
Because of this the network configuration changes from host based network to a container network.</p>
</blockquote>
","3110970",""
"63817068","63803136","2020-09-09 17:56:36","62","<p>To get event data, you can use a GitHub action to print the event to the log.</p>
<pre><code># change this to the event type you want to get the data for
on:
  pull_request:
    types: [opened, closed, reopened]

jobs:
  printJob:    
    name: Print event
    runs-on: ubuntu-latest
    steps:
    - name: Dump GitHub context
      env:
        GITHUB_CONTEXT: ${{ toJson(github) }}
      run: |
        echo &quot;$GITHUB_CONTEXT&quot;
</code></pre>
<p>Alternatively, you can find example event data in the documentation:
<a href=""https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#webhook-payload-example-30"" rel=""noreferrer"">https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#webhook-payload-example-30</a></p>
","3241243",""
"69397197","64078671","2021-09-30 18:24:04","0","<p>Unfortunately, my solution was not at all tidy. I had to path into the gem installation directory and directly reference the gem executable. Thankfully, the relative path doesn't change, so I could just hardcode it into the test script. Maybe there's a more elegant solution, but once I got it working, I just dropped it.</p>
<p>And sorry if you're trying to reproduce this, but it was over a year ago and I left the company, so I don't have access to what the path was.</p>
","630517",""
"71230969","64078671","2022-02-23 03:13:45","0","<p>Jenkins -&gt; Manage Jenkins -&gt; Configure System -&gt; Global properties -&gt; Environment variables -&gt; Name: LC_ALL, Value: en_US.UTF-8</p>
","7718603",""
"73059178","64078671","2022-07-20 23:36:26","1","<ol>
<li>I was facing the same issue while setting up <code>fastlane</code> to run my Xcode tests.</li>
<li>Finally, solved the issue by adding PATH in <code>Jenkinsfile</code> as below.</li>
<li>Note that <code>SampleProject-TestCase-Executions</code> is Sample app on my Desktop.</li>
<li>Please find <a href=""https://github.com/BudhabhooshanPatil/Jenkin-demo-app"" rel=""nofollow noreferrer"">GitHub Demo App</a> for more info.</li>
</ol>
<pre><code>node {
    stage &quot;Run Fast file&quot;    
    sh '''
    cd /Users/bhooshanpatil/Desktop/SampleProject-TestCase-Executions
    export PATH=&quot;$PATH:/usr/local/bin:/usr/local/bin:/usr/local/sbin$:&quot;
    fastlane scan
    '''
}
</code></pre>
","10279508",""
"64173273","64169578","2020-10-02 14:27:46","2","<p>The error you are getting is because you aren't listening for incoming HTTP requests in your code or you're listening for incoming requests on the wrong port.</p>
<p>As you can see documented in the <a href=""https://cloud.google.com/run/docs/reference/container-contract#port"" rel=""nofollow noreferrer"">Cloud Run container runtime</a>, your container must listen for incoming HTTP requests on the port that is defined by Cloud Run and provided in the <code>$PORT</code> environment variable.</p>
<p>If this fails, the health check will fail to, and it would switch to an error state and the traffic will not be routed to the correct PORT.</p>
<p>I would post an example for Node.js and as I can see you do not have specified anything related to the port:</p>
<pre><code>const port = process.env.PORT || 8080;
app.listen(port, () =&gt; {
  console.log('Hello world listening on port', port);
});
</code></pre>
","12391391",""
"64571964","64553739","2020-10-28 11:32:44","2","<p>As far as I know, you cannot. This is how the runners and GitHub Actions was designed to work. If you have a public repository then having a self-hosted runner is really not a good idea. Even the documentation in <a href=""https://docs.github.com/en/free-pro-team@latest/actions/hosting-your-own-runners/about-self-hosted-runners#self-hosted-runner-security-with-public-repositories"" rel=""nofollow noreferrer"">§Self-hosted runner security with public repositories</a> section mentions:</p>
<blockquote>
<p>We recommend that you do not use self-hosted runners with public repositories.</p>
</blockquote>
<blockquote>
<p>Forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.</p>
</blockquote>
<blockquote>
<p>This is not an issue with GitHub-hosted runners because each GitHub-hosted runner is always a clean isolated virtual machine, and it is destroyed at the end of the job execution.</p>
</blockquote>
<p>Having that in mind, you have two options:</p>
<ol>
<li><p>Do not use the self-hosted runner unless you really need it. If you need it then make your repo private.</p>
</li>
<li><p>Switch to GitHub-hosted runners.</p>
</li>
</ol>
","2443502",""
"64591014","64553739","2020-10-29 12:21:00","1","<p>From what I can tell:</p>
<ul>
<li>It is not possible to disable this on a public repository (free tier)</li>
<li>On a private repository it's not possible to run an Action on a pull request by default</li>
<li>If you have GitHub Enterprise, then you can enable workflows from forks</li>
</ul>
","3114742",""
"73146898","64553739","2022-07-28 03:22:53","5","<p>A configuration option was added to help secure self-hosted runners.  If you have a public repository and a self-hosted runner, then you should always enable the option &quot;<strong>Require approval for all outside collaborators</strong>&quot; as seen in the Actions configuration screen below.</p>
<p>The new default is to require approval for all first-time contributors to run workflows.</p>
<p>However, GitHub still recommends that you do not use self-hosted runners with public repositories.  They specifically state <a href=""https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#hardening-for-self-hosted-runners"" rel=""noreferrer"">self-hosted runners should almost never be used for public repositories on Github</a>  As also mentioned on that page is to use <a href=""https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners"" rel=""noreferrer"">CodeOwners</a> to monitor changes to the directory that your workflow files are stored in (.github/workflows).</p>
<p><a href=""https://i.sstatic.net/HAttl.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/HAttl.png"" alt=""GitHub Action Configuration"" /></a></p>
","35696",""
"77895239","64553739","2024-01-28 15:03:59","4","<p>As detailed in the <a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idif"" rel=""nofollow noreferrer"">GitHub Docs</a>, you can prevent Actions from running on forked repos by using this in your <code>.yml</code> file:</p>
<pre class=""lang-yaml prettyprint-override""><code>if: github.repository == 'ORG-NAME/REPO-NAME'
</code></pre>
<p>Here's a full <code>.yml</code> example:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: '14'
      - run: npm install -g bats
</code></pre>
<p>This uses the <code>jobs.&lt;job_id&gt;.if</code> conditional to make it work.</p>
<p>This won't prevent people from removing that conditional to make the code run anyway if that's what they want to do, but it can help them from accidentally running that workflow after they've cloned a repo if they have Actions enabled. (I've personally used this in one of my repo's <code>.yml</code> files to prevent forkers from activating a script that deploys ReadMe files as a Jekyll site to GitHub Pages for a job that isn't configured for outside repos.)</p>
","7058266",""
"64724369","64721253","2020-11-07 04:17:30","21","<p>I went down the road that <a href=""https://stackoverflow.com/users/3266847/benjamin-w"">Benjamin W.</a> was talking about with having <code>VERSION</code> in my environment vs just in that specific step.</p>
<p>This worked for me to set the variable in one step, then use it in separate steps.</p>
<pre><code>- name: Set variables
  run: |
    VER=$(cat VERSION)
    echo &quot;VERSION=$VER&quot; &gt;&gt; $GITHUB_ENV

- name: Build Docker Image
  uses: docker/build-push-action@v2
  with:
    context: .
    file: ${{ env.BASE_DIR }}/Dockerfile
    load: true
    tags: |
      ${{ env.USER }}/${{ env.REPO }}:${{ env.VERSION }}
      ${{ env.USER }}/${{ env.REPO }}:latest
</code></pre>
","10984961",""
"68092042","64721253","2021-06-23 00:13:37","1","<p>As I want to re-use ENV_VAR between jobs, this is how I do it. I wish I could find a way to minimize this code.</p>
<p>In this example, I use VARs from my Dockerfile. But it will work from any file.</p>
<pre><code>  pre_build:
    runs-on: ubuntu-20.04
    steps:
        ...
      -
        name: Save variables to disk
        run: |
          cat $(echo ${{ env.DOCKERFILE }}) | grep DOCKERHUB_USER= | head -n 1 | grep -o '&quot;.*&quot;' | sed 's/&quot;//g' &gt; ~/varz/DOCKERHUB_USER
          cat $(echo ${{ env.DOCKERFILE }}) | grep GITHUB_ORG= | head -n 1 | grep -o '&quot;.*&quot;' | sed 's/&quot;//g' &gt; ~/varz/GITHUB_ORG
          cat $(echo ${{ env.DOCKERFILE }}) | grep GITHUB_REGISTRY= | head -n 1 | grep -o '&quot;.*&quot;' | sed 's/&quot;//g' &gt; ~/varz/GITHUB_REGISTRY
          echo &quot;$(cat ~/varz/DOCKERHUB_USER)/$(cat ~/varz/APP_NAME)&quot; &gt; ~/varz/DKR_PREFIX
      - 
        name: Set ALL variables for this job | à la sauce GitHub Actions
        run: |
          echo &quot;VERSION_HASH_DATE=$(cat ~/varz/VERSION_HASH_DATE)&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;VERSION_HASH_ONLY=$(cat ~/varz/VERSION_HASH_ONLY)&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;VERSION_CI=$(cat ~/varz/VERSION_CI)&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;VERSION_BRANCH=$(cat ~/varz/VERSION_BRANCH)&quot; &gt;&gt; $GITHUB_ENV
      -
        name: Show variables
        run: |
          echo &quot;${{ env.VERSION_HASH_DATE }} &lt; VERSION_HASH_DATE&quot;
          echo &quot;${{ env.VERSION_HASH_ONLY }} &lt; VERSION_HASH_ONLY&quot;
          echo &quot;${{ env.VERSION_CI }} &lt; VERSION_CI&quot;
          echo &quot;${{ env.VERSION_BRANCH }} &lt; VERSION_BRANCH&quot;
      - 
        name: Upload variables as artifact
        uses: actions/upload-artifact@master
        with:
          name: variables_on_disk
          path: ~/varz

  test_build:
    needs: [pre_build]
    runs-on: ubuntu-20.04
    steps:
       ...
      - 
        name: Job preparation | Download variables from artifact
        uses: actions/download-artifact@master
        with:
          name: variables_on_disk
          path: ~/varz
      - 
        name: Job preparation | Set variables for this job | à la sauce GitHub Actions
        run: |
          echo &quot;VERSION_HASH_DATE=$(cat ~/varz/VERSION_HASH_DATE)&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;VERSION_HASH_ONLY=$(cat ~/varz/VERSION_HASH_ONLY)&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;VERSION_BRANCH=$(cat ~/varz/VERSION_BRANCH)&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;BRANCH_NAME=$(cat ~/varz/BRANCH_NAME)&quot; &gt;&gt; $GITHUB_ENV
</code></pre>
","5596289",""
"64727984","64727916","2020-11-07 13:07:06","5","<p>According to the <a href=""http://maven.apache.org/ref/3.6.3/maven-embedder/cli.html"" rel=""noreferrer"">Apache Maven CLI Options Reference</a>:</p>
<blockquote>
<p><code>-B</code>,<code>--batch-mode</code>   Run in non-interactive (batch) mode (disables output color)</p>
</blockquote>
","2988",""
"64777665","64745031","2020-11-10 22:24:56","1","<p>You can build standalone apps with expo on GH Actions. It's still turtle-cli build, but run on macos-latest runner;</p>
<p>You have to remember that your exported sources should be uploaded to some public server previously for further OTA updates.</p>
<p>Here you can find a simple workflow, how to do this with GH Actions with example on GH repository: <a href=""https://www.daily-coding.net/posts/building-standalone-expo-apps-with-github-actions"" rel=""nofollow noreferrer"">https://www.daily-coding.net/posts/building-standalone-expo-apps-with-github-actions</a>. In README you can also find an explanation, which credentials and secrets are needed.</p>
","5582738",""
"64902090","64883366","2020-11-18 22:03:27","9","<blockquote>
<p>Ultimately I want my env config to look like this:</p>
<pre><code>env:
   GIT_SHA: &lt;git commit sha&gt;
   GIT_BRANCH: &lt;current git branch&gt;
</code></pre>
</blockquote>
<p>You can achieve the same effect (setting the environment variables) not only in the workflow definition but by setting the variables dynamically in a dedicated workflow step. You can do it by <a href=""https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable"" rel=""noreferrer"">environment files</a> and <a href=""https://docs.github.com/en/free-pro-team@latest/actions/reference/environment-variables#default-environment-variables"" rel=""noreferrer"">built-in <code>GITHUB_SHA</code> and <code>GITHUB_BRANCH</code> variables</a>:</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  set-env:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variables
        run: |
          echo &quot;GIT_SHA=${GITHUB_SHA}&quot; &gt;&gt; $GITHUB_ENV
          echo &quot;GIT_BRANCH=${GITHUB_REF##*/}&quot; &gt;&gt; $GITHUB_ENV
      - name: Use environment variables
        run: |
          echo &quot;GIT_SHA=${GIT_SHA}&quot;
          echo &quot;GIT_BRANCH=${GIT_BRANCH}&quot;
</code></pre>
<p>Executing the workflow should give you the output:</p>
<p><a href=""https://i.sstatic.net/JNJCL.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/JNJCL.png"" alt=""enter image description here"" /></a></p>
","2443502",""
"69570397","64883366","2021-10-14 12:05:48","3","<p>Indeed, rather than using GITHUB_REF, it could be useful to use GITHUB_HEAD_REF or GITHUB_BASE_REF to figure out the real branch names (above all, if workflow is associated to a PR):</p>
<p>Examples of output:</p>
<pre><code>    GITHUB_REF=&quot;refs/pull/4/merge&quot;
    GITHUB_BASE_REF=&quot;main&quot;
    GITHUB_HEAD_REF=&quot;key_advertisement&quot;
</code></pre>
<p>More information here:
<a href=""https://docs.github.com/en/actions/learn-github-actions/contexts#github-context"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/learn-github-actions/contexts#github-context</a></p>
","17150148",""
"65355741","65205928","2020-12-18 10:51:56","1","<p>I've solved my issues and this is an example github workflow for the github actions:</p>
<pre><code>name: Multiple Environments Example

on: [push, pull_request]

jobs:
  e2e-test-on-ubuntu-with-local-chrome:
    runs-on: ubuntu-latest
    #runs-on: macos-latest
    #runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Setup
        run: npm install
      - name: Test
        run: npm run clear-test -- &quot;wdio-configs/wdio.conf.chrome.chromedriver.headless.js --cucumberOpts.tagExpression=@myTests&quot;
        env:
          ENV_PATH: environment/QS
      - name: Upload Test Reports
        uses: actions/upload-artifact@v2
        with:
          name: reports
          path: tests/reports/
      - name: Upload Logs
        uses: actions/upload-artifact@v2
        with:
          name: logs
          path: log/
</code></pre>
","4062803",""
"65461907","65461758","2020-12-27 00:13:55","2","<p>Considering the <a href=""https://github.com/actions/checkout#push-a-commit-using-the-built-in-token"" rel=""nofollow noreferrer"">checkout action allows to run commands</a> in the checked out working tree, you could use <a href=""https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable"" rel=""nofollow noreferrer""><code>$GITHUB_ENV</code> environment variables</a>, since <a href=""https://github.blog/changelog/2020-10-01-github-actions-deprecating-set-env-and-add-path-commands/"" rel=""nofollow noreferrer""><code>set-env</code> is deprecated</a> since Oct. 2020:</p>
<pre class=""lang-yaml prettyprint-override""><code>on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: |
          echo &quot;GURL=$(git remote get-url origin)&quot;&gt;&gt;$GITHUB_ENV
      - name: Create project dir
          git clone $GURL
      
</code></pre>
<p><a href=""https://chat.stackoverflow.com/transcript/message/51240931#51240931"">As discussed</a>, though, this does not seem to work within a step using <code>ssh-action</code>, hence <a href=""https://github.com/appleboy/ssh-action/issues/99"" rel=""nofollow noreferrer""><code>appleboy/ssh-action</code> issue 99</a> (Q4 2020).</p>
<p>Q1 2021: this was resolved with <a href=""https://github.com/appleboy/ssh-action/issues/99#issuecomment-756410183"" rel=""nofollow noreferrer"">the comment</a>:</p>
<blockquote>
<p>The best way to do this is to build the clone URL yourself, something like this (untested):</p>
</blockquote>
<pre class=""lang-yaml prettyprint-override""><code>uses: appleboy/ssh-action@master
env:
  REPO: ${{ github.repository }} # e.g. &quot;appleboy/ssh-action&quot;
  TOKEN: ${{ github.token }}
with:
  envs: REPO,TOKEN
  script: |
    git clone https://$TOKEN@github.com/$REPO.git
</code></pre>
<p>See also &quot;<a href=""https://github.blog/2012-09-21-easier-builds-and-deployments-using-git-over-https-and-oauth/"" rel=""nofollow noreferrer"">Easier builds and deployments using Git over HTTPS and OAuth</a>&quot; from <a href=""https://twitter.com/pengwynn"" rel=""nofollow noreferrer"">Wynn Netherland</a>.</p>
","6309",""
"66347175","66335124","2021-02-24 08:30:11","0","<p>OK, I found this one out myself. Apparently there's an action you can use that will download the publish profile for you. This means that you don't have to have the publish profile up front. The step looks like this:</p>
<pre><code>- name: Get WebApp/FunctionApp publish profile
  id: webapp-dev
  uses: aliencube/publish-profile-actions@v1
  env:
    AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
  with:
    resourceGroupName: 'your-resource-group-name'
    appName: 'your-app-name'
</code></pre>
<p>This leaves you with an output variable called `profile' which can be used in following steps like so:</p>
<pre><code>- name: 'Run Azure webapp deploy action using publish profile credentials'
  uses: azure/webapps-deploy@v1
  with: 
    app-name: 'your-app-name'
    publish-profile: ${{ steps.webapp-dev.outputs.profile }}
    package: './'
</code></pre>
<p>This means you can now provision resources using ARM templates, get the publish profile (just-in-time) and use that to deploy your system... Everybody happy...</p>
","1211879",""
"66922092","66918575","2021-04-02 16:09:15","33","<p>When you want to execute files from the current repository, you need to use the <a href=""https://github.com/actions/checkout"" rel=""noreferrer"">actions/checkout</a></p>
<p>This will allow you to access the repository <code>$github_workspace</code> (one of <a href=""https://docs.github.com/en/actions/reference/environment-variables"" rel=""noreferrer"">Github environment variables</a>) in your workflow.</p>
<p>For example, considering that your <code>Makefile</code> file is at the root of the repository, you would use something like this:</p>
<pre><code>   name: python-app

   on:
     push:
       branches: [ master ]
     pull_request:
       branches: [ master ]

   jobs:
    build:
      runs-on: ubuntu-latest
      steps:
      - name: checkout repo
        uses: actions/checkout@main
      - name: build application
        run: make build
</code></pre>
<p><a href=""https://github.com/GuillaumeFalourd/poc-github-actions/blob/main/.github/workflows/03-python-script-workflow.yml"" rel=""noreferrer"">Here</a> is another workflow example from a personal repository, following the same logic if you want to execute a specific script to perform any operation.</p>
","8496462",""
"68694219","68692017","2021-08-07 16:29:51","8","<p>You can add this <a href=""https://github.com/webfactory/ssh-agent"" rel=""noreferrer"">action</a> after your checkout step and GitHub can access your private repo dependancy.</p>
<p>Note:- Make sure to add a server's private key as a secret, public key to GitHub SSH keys and Please replace your private repo URL from https+auth_token to SSH.
<code>ssh://git@github.com/your_group/your_project.git</code></p>
","16414425",""
"76191835","68692017","2023-05-07 01:16:24","7","<p>An easiest way to solve this problem is using the git <code>url.insteadOf</code> feature.</p>
<p>First of all, create a <code>.cargo/config.toml</code> file in your project root and add this (this force cargo to use git cli instead of libgit2):</p>
<pre><code># .cargo/config.toml
[net]
git-fetch-with-cli = true
</code></pre>
<p>Now, assuming that you have created a personal access token and added it to the (for example) <code>GIT_CREDENTIALS</code> repository environment variable:</p>
<pre><code># Cargo.toml
[dependencies]
b = { git = &quot;https://github.com/me/b.git&quot; }
</code></pre>
<p>You can do this inside your CI before any cargo command:</p>
<pre><code># my_action.yaml
git config --global url.&quot;https://${{ secrets.GIT_CREDENTIALS }}@github.com&quot;.insteadOf https://github.com
</code></pre>
<p><em>OR:</em></p>
<p>Alternatively, commonly is better for the developer to use ssh instead of https to fetch git dependencies. In this case, you can do:</p>
<pre><code># Cargo.toml
[dependencies]
b = { git = &quot;ssh://git@github.com/me/b.git&quot; }
</code></pre>
<p>In CI will be:</p>
<pre><code># my_action.yaml
git config --global url.&quot;https://${{ secrets.GIT_CREDENTIALS }}@github.com&quot;.insteadOf ssh://git@github.com
</code></pre>
<p>This will override the url adding the token and allowing you to fetch the dependencies using https. <strong>Reminder</strong>: don't forget the <code>git-fetch-with-cli = true</code> configuration.</p>
","9607657",""
"68947628","68938010","2021-08-27 03:17:41","0","<blockquote>
<p>I don't how to fix that to push the commit to the branch itself connected to the tag as i need to update the kustomize.yaml there after each building</p>
</blockquote>
<p>As far as Git itself is concerned, there is no connection between a branch name and a tag name.</p>
<p>At the Git level, <em>any</em> name—any reference—is simply a name that stores a hash ID.  <em>Branch</em> names in particular are constrained to store only <em>commit</em> hash IDs, while tag names can store the hash ID of any internal Git object.  A tag is said to be a <em>lightweight</em> tag if it stores a commit hash ID, or an <em>annotated</em> tag if it stores the hash ID of a tag object.  This tag object then typically stores the hash ID of some commit.</p>
<p>You can use <code>git branch --points-at</code> to find branch names that select some particular commit, and <code>git tag --points-at</code> to find tag names that select some particular commit.  For details, see the <a href=""https://git-scm.com/docs/git-branch"" rel=""nofollow noreferrer""><code>git branch</code></a> and <a href=""https://git-scm.com/docs/git-tag"" rel=""nofollow noreferrer""><code>git tag</code></a> documentation.</p>
<p>Note that you can give <code>git tag</code> the <em>commit</em> hash ID here, and it still finds annotated tags.  Technically, it finds the annotated tag regardless of whether you name the tag object itself, or its target commit:</p>
<pre class=""lang-none prettyprint-override""><code>$ git rev-parse v2.3.0
42de6ed0c4c5c2a184b25ffeb4936af8226ccad1
$ git rev-parse v2.3.0^{commit}
9874fca7122563e28d699a911404fc49d2a24f1c
$ git tag --points-at 42de6ed0c4c5c2a184b25ffeb4936af8226ccad1
v2.3.0
$ git tag --points-at 9874fca7122563e28d699a911404fc49d2a24f1c
v2.3.0
</code></pre>
<p>But if you're trying to find which <em>branch</em> names—there may be anywhere from none to many—identify some particular <em>commit</em> that you find by a tag, you'll definitely need to resolve the tag name to a commit hash ID first, before running <code>git branch --points-at</code>.</p>
<p>Regardless of all of that, your overall plan seems rather ill-founded to me.  Remember that the <em>purpose</em> of a <em>tag name</em> is to identify one specific commit for all time.  A raw hash ID will do that too, but the tag name provides two important features that the raw hash ID doesn't:</p>
<ul>
<li><p>It is at least potentially human-readable, and can have semantics, such as a <a href=""https://semver.org/"" rel=""nofollow noreferrer"">semver</a> part.</p>
</li>
<li><p>It gives you the ability to <em>sign</em> the commit without actually signing each commit.  That is, you can provide a GPG or other digital signature for the <em>tagged</em> commit, without having to use GPG or other digital signatures on every commit (which is in most cases more harmful than useful: signing just the tags, while in some sense less secure, is far more <em>usable</em>, and a key to getting effective security is to balance the pain level with the getting-work-done level, so that people actually <em>use</em> it).</p>
</li>
</ul>
<p>Meanwhile, the <em>purpose</em> of a <em>branch</em> name is to allow something—humans, computers, or sometimes both—to find some particular but <em>changeable</em> commit.  So we assign a branch name to the <em>tip commit</em> of some chain of commits, to say <em>this is our best commit so far</em>.  Then, as we improve things, we add <em>new</em> commits to the chain, and <em>move the branch name</em>.</p>
<p>What this all means for a formal release process is that you would not <em>tag</em> a <em>release candidate</em> unless it's going to a wider audience.  You would mark this release candidate with a <em>branch name</em>.  You would then build it and test it, and if it passes internal testing, you might <em>then</em> tag it as a release candidate, perhaps <em>after</em> updating some sort of build customization.</p>
<p>In other words, <em>you would never customize a tagged version</em>.  You always customize from a <em>branch</em>—perhaps a particular branch pattern, but a branch.  Then you might tag the customized version, provided it's ready for candidacy.  If it's sufficiently good, it gets authorized as a release or &quot;wide RC&quot; (something that goes outside the local organization) that is signed and verified (so that those outside the organization can see that it is trusted, and by whom).  And of course, whoever adds a signature should make sure that the trust chain—the verification made at each step—is valid and unbroken.</p>
","1256452",""
"68980803","68978306","2021-08-30 08:08:07","10","<p>You are correct, you <a href=""https://github.community/t/using-github-action-environment-variables-in-shell-script/18330/2"" rel=""noreferrer"">can't use</a> <code>${{ secrets.my_secret }}</code> in the bash scripts.</p>
<blockquote>
<p>That won’t work, because “${{  }}” and the “secrets” variable are GitHub Actions constructs that Bash doesn’t understand. You’ll have to pass the secret to your step as an environment variable:</p>
</blockquote>
<p>However, you may also use env mapping like you have in your last step. It would be like this:</p>
<pre class=""lang-yaml prettyprint-override""><code>      - name: Create and populate .Renviron file
        run: |
          echo aws_host=&quot;$MAPPED_AWS_HOST&quot; &gt;&gt; ~/.Renviron
          echo aws_port=&quot;$MAPPED_AWS_PORT &quot; &gt;&gt; ~/.Renviron
          echo aws_pw=&quot;$MAPPED_AWS_PW&quot; &gt;&gt; ~/.Renviron
          echo aws_user=&quot;$MAPPED_AWS_USER&quot; &gt;&gt; ~/.Renviron
          echo dbname=&quot;$MAPPED_DBNAME&quot; &gt;&gt; ~/.Renviron
        shell: bash
        env:
          MAPPED_AWS_HOST: ${{ secrets.AWS_HOST}}
          MAPPED_AWS_PORT : ${{ secrets.AWS_PORT }}
          MAPPED_AWS_PW: ${{ secrets.AWS_PW }}
          MAPPED_AWS_USER: ${{ secrets.AWS_USER}}
          MAPPED_DBNAME: ${{ secrets.DBNAME}}
</code></pre>
","2347999",""
"69206611","69177488","2021-09-16 10:17:19","34","<p>You can still find your status check at search by name of the GitHub action job.</p>
<pre><code>name: .NET

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:

    etc...
</code></pre>
<p>Here is name of the job is <strong>build</strong>.</p>
<p><img src=""https://i.sstatic.net/XiI7T.png"" alt=""Search example"" /></p>
","16927073",""
"75533085","69177488","2023-02-22 13:03:41","5","<p>Give a name to a Job</p>
<pre><code>jobs:
  build:
    name: Code Formatting
</code></pre>
<p>otherwise, it gives a <code>build</code> as a default name</p>
<p>And on the setting page, it gives suggestions whenever you start searching by job name.</p>
","4231809",""
"69403634","69396004","2021-10-01 09:31:51","2","<p>My question was partially based on wrong assumptions about BuildX and its role in the example workflow. (I thought you must use BuildX to use BuildKit in the action and our Dockerfile used a few BuildKit features)</p>
<p>I found answer to my question partially in <a href=""https://stackoverflow.com/questions/64403659/docker-buildx-image-not-showing-in-docker-image-ls"">Docker BuildX image not showing in docker image ls</a> and a <a href=""https://www.docker.com/blog/multi-arch-build-and-images-the-simple-way/"" rel=""nofollow noreferrer"">blog post Multi-arch build and images, the simple way</a>.</p>
<p>By using <code>setup-buildx-action</code> step, BuildKit builds multi-platform images that does not get directly loaded into docker (since you need a single-platform image to be loaded). We currently don't need multi-platform builds and we prefer the speed of our CI. So removing <code>setup-buildx-action</code> from the workflow caused, that the single-platform image appears in <code>docker images</code> and it can be immediately used for running the tests (with no obvious time overhead for loading single-platform images to the docker).</p>
<p>I.e. commenting out this step helped:</p>
<pre class=""lang-yaml prettyprint-override""><code>- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v1
</code></pre>
<p>Once our pipeline gets more complicated and lengthy, we may start building multi-platform images again, but for now, saving 6 minutes on the run makes more sense.</p>
<p>Note: Feel free to add your answers/comments. I believe there is a better solution than removing buildx setup and also I wonder if there is a smart solution for building multi-platform solutions and getting the image loaded to <code>docker images</code> fast.</p>
","2179215",""
"71418457","70130613","2022-03-10 03:22:05","-1","<p>I've tested the option that you've mentioned but unfortunately it is not working.
Planning to get support from GitHub to try and figure out if it's possible. (Have a corporate account)</p>
","7269736",""
"70278426","70278241","2021-12-08 16:28:06","0","<p>An infinite loop will happen if there is a push to master branch. And build part will be run.</p>
<p>In build part it will push again to master so an infinite loop happenning.</p>
<p>Remove this part from build stage:</p>
<pre><code>- name: commit changed files
  run: git commit -m &quot;Auto adding config files&quot;
- name: fetch from master
  run: git fetch origin master
- name: push code to master
  run: git push origin HEAD:master
</code></pre>
","4144042",""
"74970055","70278241","2022-12-31 14:08:47","0","<p>You may find this comment helpful on how the GITHUB_TOKEN generated during workflows is created to avoid loops: <a href=""https://github.com/orgs/community/discussions/26970"" rel=""nofollow noreferrer"">https://github.com/orgs/community/discussions/26970</a></p>
<p>Based off your code and that comment, if you're using the autogenerated token, then you shouldn't have an issue with loops. I've tested this successfully in our own workflow that has a similar pattern.</p>
","9153824",""
"70966644","70907287","2022-02-03 06:12:18","-1","<p>Based on the above problem statement, we understood that you are looking to clear the web app cache post the deployment.</p>
<p>In order to achieve this, you can add an app settings <strong>WEBSITE_LOCAL_CACHE_OPTION=Always</strong> which help you in clearing the local cache of the web app.</p>
<p>for any App Service, its related contents (code files, resources etc.) are being hosted in a Shared Content Folder in order to provision all the features of the App Service like Load Balancing etc. So, if there are 2 VMs configure for Load Balancing then there would just one shared location where all the content of the App Service is hosted.</p>
<p>When these Web Apps refer to the Content Folder, there might be chances of Latency issues (although, Azure takes care of most of these issues) which might slow down the performance of the websites a bit. In such Performance-critical application, we can leverage the features of “<strong>Azure App Service Local Cache</strong>”.</p>
<p>For more information, you refer to this Azure documentation on  <a href=""https://learn.microsoft.com/en-us/azure/app-service/overview-local-cache"" rel=""nofollow noreferrer"">Azure App Service Local Cache</a> &amp; <a href=""https://www.c-sharpcorner.com/article/azure-app-service-local-cache/"" rel=""nofollow noreferrer"">this</a> blog post as well .</p>
","15968720",""
"71095004","70907287","2022-02-12 19:10:14","0","<p>Right...</p>
<p>It turns out the way to clear the cache is very simple.  Use the cache clear command as the &quot;startup command&quot;</p>
<p><a href=""https://i.sstatic.net/ZU4Ay.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZU4Ay.png"" alt=""Azure webapp configuration"" /></a></p>
<p>So I deploy and SSH into the web app and check /home/site/wwwroot/var/cache/staging and voila! all the file are newly created!</p>
<p>This has occurred to me at the beginning, but it really seemed like a kluge.  I really wanted a cleaner way to do this.  I tried adding the startup command to the deployment script but got this error...</p>
<p><a href=""https://i.sstatic.net/0no1c.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0no1c.png"" alt=""GitHub actions error"" /></a></p>
<p>So I cannot add startup command because there is a publish profile.</p>
<p>So why did such a simple problem take so long to answer on SO? More than one suggested answers that were completely irrelevant.  All these answers had in common with my issue were words like &quot;cache&quot; and &quot;php&quot;.</p>
","7422838",""
"71030112","71030111","2022-02-08 07:40:45","9","<p><a href=""https://argo-cd.readthedocs.io/en/stable/getting_started/#4-login-using-the-cli"" rel=""noreferrer"">The same docs tell us how to extract the password</a> for argo with:</p>
<pre><code>kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo
</code></pre>
<p>Obtaining the ArgoCD server's <code>hostname</code> is also no big deal using:</p>
<pre><code>kubectl get service argocd-server -n argocd --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}'
</code></pre>
<p>And as the <code>argocd login</code> command has the parameters <code>--username</code> and <code>--password</code>, <strong>we can craft our login command like this</strong>:</p>
<pre><code>argocd login $(kubectl get service argocd-server -n argocd --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}') --username admin --password $(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo) --insecure
</code></pre>
<p>Mind the <code>--insecure</code> to prevent the argo CLI from asking things like <code>WARNING: server certificate had error: x509: certificate is valid for localhost, argocd-server, argocd-server.argocd, argocd-server.argocd.svc, argocd-server.argocd.svc.cluster.local, not a5f715808162c48c1af54069ba37db0e-1371850981.eu-central-1.elb.amazonaws.com. Proceed insecurely (y/n)?</code>.</p>
<p>The successful login should somehow look like this in the GitHub Actions UI (see <a href=""https://github.com/jonashackt/tekton-argocd-eks/runs/5105912670?check_suite_focus=true"" rel=""noreferrer"">a full log here</a>):</p>
<pre><code>'admin:login' logged in successfully
Context 'a5f715808162c48c1af54069ba37db0e-1371850981.eu-central-1.elb.amazonaws.com' updated
</code></pre>
<p>Now your GitHub Actions workflow should be able to interact with the ArgoCD server.</p>
<h2>Prevent error <code>FATA[0000] dial tcp: lookup a965bfb530e8449f5a355f221b2fd107-598531793.eu-central-1.elb.amazonaws.com on 8.8.8.8:53: no such host</code></h2>
<p>This error arises if the <code>argocd-server</code> Kubernetes service is freshly installed right before the <code>argocd login</code> command is run. Then the <code>argocd login</code> command failes for some time until it finally will work correctly.</p>
<p>Assuming some DNS propagation issues we can prevent this error from breaking our CI pipeline by wrapping our <code>argocd login</code> command into an <code>until</code> like already done <a href=""https://stackoverflow.com/a/70108997/4964553"">in this answer</a>. The full command will then look like this:</p>
<pre class=""lang-sh prettyprint-override""><code>until argocd login $(kubectl get service argocd-server -n argocd --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}') --username admin --password $(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo) --insecure; do : ; done
</code></pre>
<p>In GitHub Actions this will then look somehow like this:</p>
<pre><code>--- Login argocd CLI - now wrapped in until to prevent FATA[0000] dial tcp: lookup 12345.eu-central-1.elb.amazonaws.com on 8.8.8.8:53: no such host
time=&quot;2022-02-21T12:57:32Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:57:35Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:57:37Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
[...]
time=&quot;2022-02-21T12:58:27Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:58:30Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:58:32Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
'admin:login' logged in successfully
Context 'a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com' updated
</code></pre>
<p><a href=""https://github.com/jonashackt/tekton-argocd-eks/runs/5274400263?check_suite_focus=true"" rel=""noreferrer"">Here's also a log</a>.</p>
","4964553",""
"77578567","71030111","2023-11-30 12:49:23","1","<p>Alternatively you can exec to running argocd-server kubernetes pod:</p>
<pre><code>kubectl exec -it argocd-server-669c567686-886np -n argocd -- /bin/bash
</code></pre>
<p>Your pod name will be different due to the hash at the end. Then login to the local argocd using:</p>
<pre><code>argocd login localhost:8080 --insecure
</code></pre>
<p>it will prompt you for a username and password. If this is your first login you can find the initial password in the secret</p>
<pre><code>kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo
</code></pre>
","4673301",""
"71212906","71179099","2022-02-21 20:53:19","4","<p>If you want to set a variable <strong>only for one run</strong>, you can add an <code>export</code> command when you configure the self-hosted runner on the Github repository, before running the <code>./run.sh</code> command:</p>
<p><strong>Example (linux) with a <code>TEST</code> variable:</strong></p>
<pre class=""lang-sh prettyprint-override""><code># Create the runner and start the configuration experience
$ ./config.sh --url https://github.com/owner/repo --token ABCDEFG123456
# Add new variable
$ export TEST=&quot;MY_VALUE&quot;
# Last step, run it!
$ ./run.sh
</code></pre>
<p>That way, you will be able to access the variable by using <code>$TEST</code>, and it will also appear when running <code>env</code>:</p>
<pre class=""lang-yaml prettyprint-override""><code>  job:
    runs-on: self-hosted
    steps:
      - run: env
      - run: echo $VAR
</code></pre>
<p><a href=""https://i.sstatic.net/F2qjg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/F2qjg.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>If you want to set a variable <strong>permanently</strong>, you can add a file to the <code>etc/profile.d/&lt;filename&gt;.sh</code>, as suggested by @frennky above, but you will also have to update the shell for it be aware of the new env variables, <strong>each time</strong>, before running the <code>./run.sh</code> command:</p>
<p><strong>Example (linux) with a <code>HTTP_PROXY</code> variable:</strong></p>
<pre class=""lang-sh prettyprint-override""><code># Create the runner and start the configuration experience
$ ./config.sh --url https://github.com/owner/repo --token ABCDEFG123456
# Create new profile http_proxy.sh file
$ sudo touch /etc/profile.d/http_proxy.sh
# Update the http_proxy.sh file
$ sudo vi /etc/profile.d/http_proxy.sh
# Add manually new line in the http_proxy.sh file
$ export HTTP_PROXY=http://my.proxy:8080
# Save the changes (:wq)
# Update the shell
$ bash
# Last step, run it!
$ ./run.sh
</code></pre>
<p>That way, you will also be able to access the variable by using <code>$HTTP_PROXY</code>, and it will also appear when running <code>env</code>, the same way as above.</p>
<pre class=""lang-yaml prettyprint-override""><code>  job:
    runs-on: self-hosted
    steps:
      - run: env
      - run: echo $HTTP_PROXY
      - run: |
          cd $HOME
          pwd
          cd ../..
          cat etc/profile.d/http_proxy.sh
</code></pre>
<p><em>The <code>etc/profile.d/&lt;filename&gt;.sh</code> will persist, but remember that you will have <strong>to update the shell</strong> each time you want to start the runner, before executing <code>./run.sh</code> command. At least that is how it worked with the EC2 instance I used for this test.</em></p>
<p><a href=""https://i.sstatic.net/Pjj8O.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Pjj8O.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://www.serverlab.ca/tutorials/linux/administration-linux/how-to-set-environment-variables-in-linux/"" rel=""nofollow noreferrer"">Reference</a></p>
","8496462",""
"75201577","71179099","2023-01-22 15:23:03","10","<p>Inside the application directory of the runner, there is a <code>.env</code> file, where you can put all variables for jobs running on this runner instance.</p>
<p>For example</p>
<pre><code>LANG=en_US.UTF-8
TEST_VAR=Test!
</code></pre>
<p>Every time <code>.env</code> changes, restart the runner (assuming running as service)</p>
<pre><code>sudo ./svc.sh stop
sudo ./svc.sh start
</code></pre>
<p>Test by printing the variable</p>
<p><a href=""https://i.sstatic.net/rqGPj.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/rqGPj.png"" alt=""enter image description here"" /></a></p>
","3556176",""
"77112826","71179099","2023-09-15 13:35:39","0","<p>You can change the shebang (the top line) in <code>runsvc.sh</code> to <code>#!/bin/bash --login</code> to ensure the shell picks up any environment variables you may have configured in <code>.profile</code></p>
","480467",""
"71554893","71525489","2022-03-21 08:51:26","2","<p>The <code>::command</code> can be logged to the console by any script or executable. They are special strings the GitHub runner will detect, interpret and then take the appropriate action on.</p>
<p>They are essentially the communication mechanism between the runner and the thing it's currently running. Anything that can write to the console can issue these strings.</p>
<p>It's totally up to you to build these stings, to inject any parameters these 'magic strings' require to function.</p>
<p>The docs you've found are the right docs on these to understand how to log there strings and what commands there are available to you.</p>
<p>If you're building a GitHub action using the JavaScript/Typescript toolkit, then it provides nice wrapper functions for these commands. <a href=""https://github.com/actions/toolkit/blob/main/packages/core/src/core.ts"" rel=""nofollow noreferrer"">The JavaScript SDK also gives you a sneak peak into how to composekthese strings</a>.</p>
<p>If you're building a composite action, container task or are directly issueing commands from a script block in the workflow, then it's up to you to build the correct strings and log these to the console.</p>
<p>More details:</p>
<ul>
<li><a href=""https://github.com/actions/toolkit/blob/main/packages/core/README.md"" rel=""nofollow noreferrer"">https://github.com/actions/toolkit/blob/main/packages/core/README.md</a></li>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions</a> (you had found that already)</li>
</ul>
<p>Communicating through the console is the lowest common denominator between any tools running on just about any platform and requires no interprocess communication if any kind. It's the simplest way to communicate from a child process to it's parent.</p>
<p>You'd use the command to set an output variable.</p>
<pre><code>echo &quot;::set-output name=name::value&quot;
</code></pre>
<p>To be able to reference the value cross at you'd reference any output variable from any action.</p>
<p>Or set an environment variable which will be set for the next job: <code>echo &quot;action_state=yellow&quot; &gt;&gt; $GITHUB_ENV</code></p>
<p>See: <a href=""https://stackoverflow.com/a/57989070/736079"">https://stackoverflow.com/a/57989070/736079</a></p>
","736079",""
"71885439","71885354","2022-04-15 14:43:25","0","<p>use an updated version of the <a href=""https://github.com/actions/setup-java"" rel=""nofollow noreferrer"">actions/setup-java</a> step, like:</p>
<pre><code>    steps:
    - name: checkout
      uses: actions/checkout@v3.0.1
    - name: set up JDK 1.8
      uses: actions/setup-java@
      with:
        distribution: 'zulu' # See 'Supported distributions' for available options
        java-version: '8'

</code></pre>
","2270041",""
"72632303","72353130","2022-06-15 13:25:32","2","<p>Setting 'admin' to true worked for me.</p>
<pre><code>- uses: azure/aks-set-context@v2.0
with:
  resource-group: ${{ secrets.BETA_RESOURCE_GROUP }}
  cluster-name: ${{ secrets.BETA_AKS_CLUSTER }}
  admin: true
</code></pre>
","15373563",""
"72376471","72375995","2022-05-25 11:05:27","8","<p>If you have a look at the <a href=""https://github.com/actions/checkout"" rel=""noreferrer"">actions/checkout</a> repo, you will notice that by default it fetches only a single commit. You can change this using the <code>fetch-depth</code> parameter:</p>
<pre><code> - uses: actions/checkout@v3
   with:
     fetch-depth: 0
</code></pre>
<p>From the checkout's readme:</p>
<blockquote>
<p>0 indicates all history for all branches and tags.</p>
</blockquote>
","10662240",""
"73941762","73018888","2022-10-03 23:31:28","2","<p>As <a href=""https://docs.github.com/en/actions/using-jobs/using-concurrency"" rel=""nofollow noreferrer"">documented</a> &quot;Any previously pending in the concurrency group will be canceled&quot;. In others words, the queue is limited in one. Somewhat useless. To permit parallel execution just not use 'concurrency' term on action.</p>
","1056652",""
"73080089","73080088","2022-07-22 12:06:08","7","<p>After a few researches, I found <a href=""https://github.com/python-poetry/poetry/issues/4210"" rel=""noreferrer"">this thread</a> on the poetry GitHub repository from november 2021.</p>
<p>There is this workaround from <a href=""https://github.com/hoefling"" rel=""noreferrer"">hoefling GitHub user</a>:</p>
<blockquote>
<p><strong>Disabling poetry's experimental new installer may be a workaround for
now:</strong></p>
</blockquote>
<h3>Solution</h3>
<pre class=""lang-bash prettyprint-override""><code>poetry config experimental.new-installer false
</code></pre>
<p><strong>Adding this line in the shell before running the <code>poetry install</code> command resolved my problem!</strong></p>
<hr />
<hr />
<p>Note that in the same thread, another comment from <a href=""https://github.com/ddc67cd"" rel=""noreferrer"">ddc67cd</a> stated that:</p>
<blockquote>
<p>the issue is resolved with the new version of <strong>cachecontrol==0.12.9</strong> (it should be installed automatically).</p>
</blockquote>
<p>But running <code>pip install -U cachecontrol</code> didn't resolve the issue in my specific case (might be worth testing otherwise?).</p>
<hr />
<hr />
<p><em>It also seems the problem came back recently (July 2022) and <a href=""https://github.com/python-poetry/poetry/issues/4210#issuecomment-1178776203"" rel=""noreferrer"">this comment</a> suggested a possible root cause to the issue related to the setuptools library.</em></p>
<p>Anyway, disabling poetry's experimental new installer should resolve the problem for now, until a permanent solution is found.</p>
","8496462",""
"73329852","73327325","2022-08-12 06:08:32","1","<p>If you want to create an environment variable, add it to the file behind <code>$GITHUB_ENV</code> like so:</p>
<pre class=""lang-yaml prettyprint-override""><code>- run: echo &quot;NAME=${{ github.repository }}_$(cat VERSION).zip&quot; &gt;&gt; $GITHUB_ENV
- run: echo ${{ env. NAME }}
</code></pre>
<p>For more information, see the docs on <a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable"" rel=""nofollow noreferrer"">Workflow commands for GitHub Actions / Setting an environment variable</a></p>
","1080523",""
"74141877","73417515","2022-10-20 14:47:56","0","<p>One other alternative is to configure a bare repository on your server, and adding it as a second remote on your local repository.
Now every time you want to deploy code to your server, you push to this remote. You then create a git hook on your server that fires post-push, and automatically executes a script that restarts a service, for example.
Read more <a href=""https://daveceddia.com/deploy-git-repo-to-server/"" rel=""nofollow noreferrer"">here</a></p>
<p>For me, I am having a hard time choosing between these two alternatives because I have some unanswered questions :</p>
<ul>
<li><p>for github actions, how secure is the SSH key being ran from a github runner ? and given that my codebase is huge, isn't it a bit overkill to scp all my files after a hotfix commit where I changed only 1 or 2 files ?</p>
</li>
<li><p>for git bare repo: would the size of the git folder be a problem ? and how to secure my server so it would not serve the .git folder ?</p>
</li>
</ul>
","8410972",""
"77371664","73417515","2023-10-27 05:15:19","0","<p>Your approach of using scp can be secure, but there are some considerations to keep in mind:</p>
<ul>
<li><strong>SSH key handling</strong>: Ensure that you are storing your SSH private key and any other sensitive data as GitHub secrets and not
hard-coding them in your workflow file.</li>
<li><strong>Key Management</strong>: Use a dedicated SSH key pair specifically for this GitHub Action.</li>
<li><strong>Least Privilege Principle</strong>: The SSH account used for copying should have the minimum necessary permissions. It should only be able
to write to the required directories.</li>
<li><strong>Auditing &amp; Logging</strong>: Ensure that both GitHub Actions and your server have proper auditing and logging enabled.</li>
</ul>
<p>Your approach of using a self-hosted runner has security advantages over GitHub hosted runners as you would have control over the self-hosted runner. You can setup ingress filtering on the SSH port with ease with self-hosted runners. Also, you can use private server endpoint for SSH and potentially eliminate the internet exposure for your server.</p>
","21283302",""
"73484136","73483825","2022-08-25 08:17:10","0","<p>Get token with <code>public_repo, repo:status</code> from <a href=""https://github.com/settings/tokens"" rel=""nofollow noreferrer"">settings</a> and create a secret on repository to commit from setting and put</p>
<p><a href=""https://i.sstatic.net/Dfpnu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Dfpnu.png"" alt=""enter image description here"" /></a></p>
<pre class=""lang-yaml prettyprint-override""><code>name: deploy web on github-page
on:
  push:
    branches:
      - master
jobs:
  build:
    name: Build Web
    env:
      my_secret: ${{secrets.commit_secret}}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v1
      - uses: subosito/flutter-action@v1
        with:
          channel: &quot;stable&quot;
      - run: flutter config --enable-web
      - run: flutter clean
      - run: flutter pub get
      - run: flutter build web --release --web-renderer html --base-href /yourRepositoryName/
      - run: |
          cd build/web
          git init
          git config --global user.email yourEmail.com
          git config --global user.name yourUsername
          git status
          git remote add origin https://${{secrets.commit_secret}}@github.com/yourUserName/repository.git
          git checkout -b gh-pages
          git add --all
          git commit -m &quot;update&quot;
          git push origin gh-pages -f
</code></pre>
","10157127",""
"73499601","73497571","2022-08-26 10:28:59","2","<p>I haven't understood the cause yet.</p>
<p>My current workaround is to disable the configuration cache on CI builds adding the option <code>--no-configuration-cache</code> to all gradle commands e.g.</p>
<pre><code>./gradlew test --no-configuration-cache
</code></pre>
<p>This overwrites the setting of <code>gradle.properties</code>.</p>
","2011622",""
"77691574","73497571","2023-12-20 12:24:36","0","<p>Same here, config cache is failing in jenkins pipeline, and working fine in local.</p>
<p>See <a href=""https://stackoverflow.com/a/69113397/7466467"">this comment</a>, it helped. It changes the error to a warning, lets it ignore problems in the config cache (only when it fails) and stores it anyway</p>
<p>Console Output:</p>
<pre><code>3 problems were found storing the configuration cache, 1 of which seems unique.
- Task `:app:buildKotlinToolingMetadata` of type `org.jetbrains.kotlin.gradle.tooling.BuildKotlinToolingMetadataTask$FromKotlinExtension`: invocation of 'Task.project' at execution time is unsupported.
....
...

BUILD SUCCESSFUL in 4m 56s
1779 actionable tasks: 715 executed, 1062 from cache, 2 up-to-date
Configuration cache entry stored with 3 problems.
</code></pre>
<p>I will update about it's impact if there is any.</p>
","7466467",""
"73667912","73626276","2022-09-09 22:10:35","1","<p>As explained by @ianyoung, the problem was with the pip file.  The <a href=""https://realpython.com/lessons/using-requirement-files/#:%7E:text=A%20Beginner%27s%20Guide%20to%20Pip&amp;text=A%20requirements%20file%20is%20a,current%20projects%20dependencies%20to%20stdout%20."" rel=""nofollow noreferrer"">requirements.txt</a> was empty, the requirements file is a list of all of a project’s dependencies. This includes the dependencies needed by the dependencies. It also contains the specific version of each dependency, specified with a double equals sign (==).</p>
","17544312",""
"73811772","73798925","2022-09-22 08:48:15","6","<p>Rather than sending a notification for each job that fails (or succeeds) it is usually possible to 'chain' the jobs together by <a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds"" rel=""noreferrer"">using the <code>needs</code> keyword</a> to create a dependency tree.</p>
<p>To keep the logic separate, you can add a final job just to perform the notification to Slack, and this can be set up as a dependency on all your earlier jobs.</p>
<p>The final job can calculate the overall workflow status using something like <code>${{ job.status == 'success' &amp;&amp; needs.earlierjob1.result == 'success' &amp;&amp; needs.earlierjob2.result == 'success' }</code> to represent a boolean of overall success. This can become easier to maintain by using <code>needs.*.result</code> instead of listing each job by name.</p>
<p>I wrote an article going into <a href=""https://levelup.gitconnected.com/structuring-github-actions-safely-5309e5ee54de?sk=b069c962eea18d65c3c93d24b9a673e7"" rel=""noreferrer"">more detail here</a>, including examples of what works and what doesn't.</p>
<p>In the end, I built a native Slack app to take care of this automatically so you don't need to think about job status or notifications at all.</p>
","2792760",""
"74113575","74112918","2022-10-18 15:26:03","5","<p>The way I've addressed a similar need is to use <code>tee</code>:</p>
<pre class=""lang-yaml prettyprint-override""><code>    steps:
      - name: Run Tool
        run: |
          some_tool | tee output.log
        shell: bash
</code></pre>
<p>That results in you getting the same logs you'd always see in the GitHub Actions console, while also persisting them to disk. If you want stderr too, do</p>
<pre class=""lang-bash prettyprint-override""><code>some_tool 2&gt;&amp;1 | tee output.log
</code></pre>
<p>Then, in a later step in the same job, you can do whatever you like with those logs, using the <a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#failure"" rel=""noreferrer""><code>if: ${{ failure() }}</code> syntax</a>:</p>
<pre class=""lang-yaml prettyprint-override""><code>    steps:
      - name: Persist logs
        if: ${{ failure() }}
        run: |
          cat output.log | do_something_with_logs
        shell: bash
</code></pre>
<p>If you need to persist the logs across a job boundary, you could use <a href=""https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts"" rel=""noreferrer"">artifacts</a>.</p>
","1159783",""
"74117425","74114983","2022-10-18 21:01:06","0","<p>I found that the problem was that after I had moved my file I wasn't committing.</p>
<p>I didn't know you had to commit in the github actions for the file to actually end up in the repo.</p>
","20230484",""
"75162857","75162480","2023-01-18 17:11:21","0","<p>Yes, according to <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule"" rel=""nofollow noreferrer"">schedule</a>:</p>
<blockquote>
<p>Scheduled workflows run on the latest commit on the default or base branch.</p>
</blockquote>
<p>However, it looks like it's doable by configuring the cron job for the default branch and then somehow triggering the workflow for the non-default branch e.g. <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch"" rel=""nofollow noreferrer"">using the GitHub API or CLI</a>.</p>
<p>See <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch"" rel=""nofollow noreferrer"">workflow_dispatch</a> for more details.</p>
<p>Or, via <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run"" rel=""nofollow noreferrer"">workflow_run</a> configuration after completion of the workflow on the default branch. Though, in this case, you might not want to combine both in general scenarios.</p>
","7670262",""
"75237092","75233027","2023-01-25 16:36:36","1","<p>It turned out to be quite similar to your earlier question about the <code>dotnet</code> caching:</p>
<ul>
<li><a href=""https://stackoverflow.com/questions/75180149/how-to-cache-dotnet-installation-in-github-actions"">How to cache dotnet installation in GitHub Actions</a></li>
</ul>
<hr />
<p>The only thing is to cache the correct installed path and set it to <code>GITHUB_PATH</code> when the cache is hit.</p>
<p><code>JAVA_HOME_17_X64</code> will be:</p>
<pre><code>C:\hostedtoolcache\windows\Java_Microsoft_jdk\17.0.3\x64
</code></pre>
<p>And, its <code>bin</code> subdirectory will be added to <code>GITHUB_PATH</code>:</p>
<pre><code>${{ env.JAVA_HOME_17_X64 }}\bin
</code></pre>
<p>Here's the complete workflow:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: cache_java

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-2022

    env:
      JAVA_HOME_17_X64: 'C:\hostedtoolcache\windows\Java_Microsoft_jdk\17.0.3\x64'

    steps:
      - name: Cache JDK
        id: cache-jdk
        uses: actions/cache@v3
        with:
          path: ${{ env.JAVA_HOME_17_X64 }}
          key: ${{ runner.os }}-jdk-17
          restore-keys: ${{ runner.os }}-jdk-

      - name: Install Java
        if: ${{ steps.cache-jdk.outputs.cache-hit != 'true' }}
        uses: actions/setup-java@v3
        with:
          distribution: 'microsoft'
          java-version: '17'

      - name: Check default Java version
        run: java -version

      - name: Set installed/cached Java path [${{ env.JAVA_HOME_17_X64 }}]
        run: echo &quot;${{ env.JAVA_HOME_17_X64 }}\bin&quot; | Out-File -FilePath $ENV:GITHUB_PATH -Encoding utf8 -Append

      - name: Check installed/cached Java version
        run: java -version
</code></pre>
<p>Output:</p>
<p><a href=""https://i.sstatic.net/C4bSU.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/C4bSU.png"" alt=""workflow run"" /></a></p>
","7670262",""
"75377583","75337206","2023-02-07 18:35:36","5","<p>I found documentation that proves this isn't possible. There is no supporting info stating that the <code>uses</code> key has access to any contexts.</p>
<p>See: <a href=""https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability"" rel=""noreferrer"">https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability</a></p>
<p>I believe this is an architectural limitation of GitHub Actions, it appears they want to resolve all workflows/actions at the start of all jobs and thus dynamic resolution isn't possible.</p>
","868321",""
"75445991","75438906","2023-02-14 09:43:47","0","<p>At the bottom of this page...</p>
<p><a href=""https://github.com/b0fgroup/b2/issues/105"" rel=""nofollow noreferrer"">B2 4.7.1 MacOS Armv8 package bundles x86_64 binary</a></p>
<p>...it says:</p>
<pre><code>./b2 architecture=arm address-model=64 -s NO_LZMA=1 -s NO_ZSTD=1 abi=aapcs
</code></pre>
<p>That worked for me.  The entire step that I have on github actions is:</p>
<pre><code>- name: Boost
  run: |
    curl -O -L https://boostorg.jfrog.io/artifactory/main/release/1.80.0/source/boost_1_80_0.tar.gz
    tar xfz boost_1_80_0.tar.gz
    cd boost_1_80_0
    ./bootstrap.sh
    ./b2 architecture=arm address-model=64 -s NO_LZMA=1 -s NO_ZSTD=1 abi=aapcs install
    lipo /usr/local/lib/libboost_*.dylib -info
</code></pre>
","2022499",""
"75489150","75489109","2023-02-17 20:52:39","1","<p>You could use the <a href=""https://github.com/marketplace/actions/slack-send"" rel=""nofollow noreferrer"">slack-send</a> GitHub Action to send data into Slack from your GitHub Workflow.</p>
<p>This Action can:</p>
<ul>
<li>Send data to Slack's Workflow Builder (requires a paid Slack instance).</li>
<li>Send data via a Slack app to post to a specific channel (use an existing custom app or create a new one).</li>
<li>Send data via a Slack Incoming Webhook URL (use an existing custom app or create a new one).</li>
</ul>
<p>There are a <a href=""https://github.com/marketplace?type=actions&amp;query=slack+"" rel=""nofollow noreferrer"">bunch of similar actions</a>, for example, <a href=""https://github.com/marketplace/actions/slack-github-actions-slack-integration"" rel=""nofollow noreferrer"">slack - GitHub Actions Slack integration</a> - also simple and flexible Slack integration with GitHub Actions.</p>
","7328018",""
"75720806","75720649","2023-03-13 10:44:22","-3","<pre><code>def write(filename, text):

    with open(filename, 'w') as file:
        file.write(text)

filename = 'example.txt'

text = '12works!'

write(filename, text)
</code></pre>
<p>The text is what you going to write into the file</p>
","21388440",""
"75735736","75733616","2023-03-14 16:13:58","14","<p>According to the <a href=""https://docs.github.com/en/actions/using-workflows/reusing-workflows#calling-a-reusable-workflow"" rel=""noreferrer"">GitHub official documentation</a>:</p>
<blockquote>
<p>You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps.</p>
</blockquote>
<p>Therefore, <strong>you can't call a reusable workflow from a job <code>step</code></strong>.</p>
<hr />
<p>A workaround in your case could be using a <a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#example-using-a-public-action-in-a-subdirectory"" rel=""noreferrer"">local action</a>, which basically allows you to use an action in the same repository as the workflow.</p>
<p><strong>Example of a local action call:</strong></p>
<pre><code>jobs:
  my_first_job:
    steps:
      - name: Check out repository
        uses: actions/checkout@v3
      - name: Use local my-action
        uses: ./.github/actions/my-action
</code></pre>
<p><em>Note that you need to inform the path to the directory that contains the action in your workflow's repository. Therefore, to access the action file, you must check out your repository before using the action with the <code>actions/checkout</code>.</em></p>
<p>This local action could be a <a href=""https://docs.github.com/en/actions/creating-actions/creating-a-composite-action"" rel=""noreferrer"">composite action</a>, similar to what a reusable workflow could achieve using actions, scripts or shell commands. I recommend <a href=""https://dev.to/n3wt0n/composite-actions-vs-reusable-workflows-what-is-the-difference-github-actions-11kd"" rel=""noreferrer"">this article to understand the difference between composite actions and reusable workflows</a>.</p>
","8496462",""
"76168924","76168022","2023-05-04 01:10:58","1","<p>Every time GitHub runs a workflow it uses a new runner, so you actually cannot delete a terraform state from your previous runner because that was an ephemeral environment and anyways your infrastructure on Azure was deployed on success. So, instead, you must store the terraform state in Azure Blob Storage.</p>
<p>First, create an <strong>Storage Account</strong> and a <strong>Blob Container</strong> either with Azure Portal, CLI or any other method you want.</p>
<p>Second (optional), understand how remote state works on Azure before implementing it in your GitHub Action workflow. Follow this <a href=""https://github.com/alfonsof/terraform-azure-examples/tree/master/code/07-terraform-state"" rel=""nofollow noreferrer"">tutorial</a> to handle and use the terraform state in your local development (i.e. your terminal with Terraform and Azure CLI installed).</p>
<p>Basically you will need to pass the storage account and blob container information to Terraform</p>
<pre><code>terraform {
# Update this block with the location of your terraform state file
  backend &quot;azurerm&quot; {
    resource_group_name  = &quot;rg-terraform-github-actions-state&quot;
    storage_account_name = &quot;terraformgithubactions&quot;
    container_name       = &quot;tfstate&quot;
    key                  = &quot;terraform.tfstate&quot;
  }
}
</code></pre>
<p>This block may have more parameters, since, there are several ways to authenticate and authorize Terraform to create resources for you. Some if not all options are described <a href=""https://developer.hashicorp.com/terraform/language/settings/backends/azurerm"" rel=""nofollow noreferrer"">here</a>. In your example you used OpenID Connect (OIDC) therefore keep</p>
<pre><code>use_oidc             = true
</code></pre>
<p>just below the <em>key</em> parameter or somewhere at the backend azurerm block.</p>
<p>I am assuming you are already using <a href=""https://github.com/marketplace/actions/hashicorp-setup-terraform"" rel=""nofollow noreferrer"">hashicorp/setup-terraform@v2 action</a> and most likely you will only need to add some GitHub secrets to pass sensitive values from your authentication.</p>
<p>For OpenID Connect (OIDC), follow <a href=""https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#use-the-azure-login-action-with-openid-connect"" rel=""nofollow noreferrer"">these steps</a> and add this code before your workflow jobs</p>
<pre><code>#Special permissions required for OIDC authentication
permissions:
  id-token: write
  contents: read

#These environment variables are used by the terraform azure provider to setup OIDD authenticate. 
env:
  ARM_CLIENT_ID: &quot;${{ secrets.AZURE_CLIENT_ID }}&quot;
  ARM_SUBSCRIPTION_ID: &quot;${{ secrets.AZURE_SUBSCRIPTION_ID }}&quot;
  ARM_TENANT_ID: &quot;${{ secrets.AZURE_TENANT_ID }}&quot;
</code></pre>
<p>A complete example with all of what I mentioned can be found <a href=""https://github.com/Azure-Samples/terraform-github-actions"" rel=""nofollow noreferrer"">here</a>.</p>
<hr>
<p><strong>EDIT</strong></p>
<p>If all workflows should be really using a different state, then instead of deleting the state and lose track of your infra. I suggest you to use workspaces.</p>
<p>Below I provided an example that will create a different state file within your blob container for each of the runs. So, none of your runs will update your previous infrastructure, unless you select the workspace of it.</p>
<pre><code>- name: Terraform Workspace New
  run: |
    workspace_name=&quot;jumpbox${{ github.run_number }}&quot;
    terraform workspace new $workspace_name
    terraform workspace select $workspace_name
</code></pre>
<blockquote>
<p>After this step, simply continue with the rest of your terraform
commands.</p>
</blockquote>
<p>You can totally replace ${{ github.run_number }} by any variable you want. In your example, if you dynamically change the name of the resource group and include a number at the end to identify the jumpbox, you can use that same number at the workspace name. Therefore, a state file for each of your jumpboxes. This will allow you to create infra seamlessly without modifying any of your previous work.</p>
","21808280",""
"77398914","76168022","2023-10-31 20:29:58","0","<p>Here is a feature request to be able to delete statefiles from within CI actions after you've run <code>terraform destroy</code></p>
<p><a href=""https://github.com/hashicorp/terraform/issues/34172"" rel=""nofollow noreferrer"">https://github.com/hashicorp/terraform/issues/34172</a></p>
","124486",""
"76203486","76202754","2023-05-08 18:46:06","1","<p>I would suggest you to use the <a href=""https://github.com/c-py/action-dotenv-to-setenv"" rel=""nofollow noreferrer"">action-dotenv-to-setenv</a> GitHub Action, as example you could have one env files for each environment and use like:</p>
<pre><code>- name: Configure ${{ inputs.myenv }} environment
  uses: c-py/action-dotenv-to-setenv@v2
  with:
    env-file: ./env/env.${{ inputs.myenv }}
</code></pre>
<p>with the following files</p>
<p><kbd>./env/env.dev</kbd></p>
<pre><code>hostname: &quot;mydevhost&quot;
port: &quot;1885&quot;
</code></pre>
<p><kbd>./env/env.qa</kbd></p>
<pre><code>hostname: &quot;myqahost&quot;
port: &quot;1881&quot;
</code></pre>
","2270041",""
"76204423","76202754","2023-05-08 21:19:05","0","<p>for GitHub Actions you have several levels for environment variables, you could have an organization, Repository, or environment level, this is the most secure one.</p>
<p>The nice part about it is that it is handled securely on GitHub and you can call it using $REPOSITORY_VAR in the workflow.<br />
In your case, I would create a list of repository variables.</p>
<p>Please refer to this link of documentation for examples and more clarity:
<a href=""https://docs.github.com/en/actions/learn-github-actions/variables"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/learn-github-actions/variables</a></p>
","15540632",""
"76235877","76235374","2023-05-12 11:32:37","3","<p>The <code>branches</code> and <code>branches-ignore</code> filters work on the following events:</p>
<ul>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore"" rel=""nofollow noreferrer""><code>pull_request</code>, <code>pull_request_target</code></a></li>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore"" rel=""nofollow noreferrer""><code>push</code></a></li>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_runbranchesbranches-ignore"" rel=""nofollow noreferrer""><code>workflow_run</code></a></li>
</ul>
<p>The <code>pull_request_review</code> is not among those. You can use the <code>if</code> to conditionally execute jobs. In this case, check if the &quot;base&quot; (merge target) is &quot;production&quot;:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: PR_review

on:
  pull_request_review:
    types: [submitted, edited]

jobs:
  test:
    if: ${{ github.event.pull_request.base.ref == 'production' }}
    runs-on: ubuntu-latest
    steps:
      - name: Debug
        run: |
          echo ${{ github.event_name }}
          echo ${{ github.ref }}
          echo ${{ github.event.pull_request.head.ref }}
          echo ${{ github.event.pull_request.base.ref }}
</code></pre>
<p>Now when a review is submitted to another branch, this workflow will run - but its job will be marked as &quot;skipped&quot;.</p>
","266143",""
"78443337","76259462","2024-05-07 14:46:46","1","<p>Recently, I found out that <a href=""https://github.com/actions/runner-images/issues/1519#issuecomment-683790054"" rel=""nofollow noreferrer"">ping doesn't work in GitHub actions</a> at all because the hosted runner uses a specific type of Azure machine that doesn't allow it by design :(</p>
","9124072",""
"76263041","76262960","2023-05-16 12:28:16","1","<p>It won't work like that you have to Go with <strong>placeholder</strong> option, add one <strong>step</strong> into your <strong>Github Action</strong></p>
<p><strong>Job.yaml</strong></p>
<pre><code>apiVersion: batch/v1
kind: Job
metadata:
  name: pi01
spec:
  template:
    spec:
      containers:
      - name: pi01
        image: xx:version
        command: [&quot;node&quot;, &quot;schedule/schedule.js&quot;]
        env:
          - name: DB_HOST
            value: VAL_DB_HOST
          - name: DB_PORT
            value: VAL_DB_PORT
</code></pre>
<p><strong>Run command</strong></p>
<pre><code>sed -i &quot;s,VAL_DB_HOST,$secrets.DB_HOST,&quot; job.yaml
sed -i &quot;s,VAL_DB_PORT,$secrets.DB_PORT,&quot; job.yaml
</code></pre>
<p>You can write <strong>shell script</strong> or further <strong>optimize</strong> it as per need. Above command will replace <strong>VAL_DB_HOST</strong> in <strong>Job.yaml</strong> with <strong>environment</strong> variable <strong>value</strong> saved.</p>
<p>Once your file <strong>job.yaml</strong> is ready, apply the changes</p>
<pre><code>kubectl apply -f job.yaml 
</code></pre>
<p>You can use the different method, <strong>Helm</strong>, <strong>Skafold</strong> also for <strong>templating</strong> if you are looking for that else above will be simple method.</p>
","5525824",""
"78481666","76262960","2024-05-15 04:50:55","0","<p>Instead of using <code>sed</code>, I used <code>yq</code>:</p>
<pre class=""lang-bash prettyprint-override""><code>yq e '(select(.metadata.name==&quot;app-deployment&quot;) | .spec.template.spec.containers[] | select(.name==&quot;php&quot;) | .env) += [{&quot;name&quot;: &quot;DB_PASSWORD&quot;, &quot;value&quot;: &quot;${{ secrets.DB_PASSWORD }}&quot;}]' k8s/app.yaml -i
</code></pre>
<p>The secret does still show if I view the YAML via kubectl or k9s, so I'm not sure this is optimal, but if someone makes it in that far they probably also have access to my ENV.</p>
","65387",""
"76431708","76431545","2023-06-08 12:07:48","0","<p>This sounds like a typical network problem. Discuss the issue with the appropriate department running the enterprise Github and find out which policies you have to match and rules you have to follow to become able to send emails from within Github Actions workflow workloads on those systems. They should be able to tell you.</p>
<hr />
<p>The action <strong>dawidd6/action-send-mail</strong> is well accepted for sending emails in Github Actions and I do not see a reason why it should - by the action itself - not work on Github Enterprise.</p>
<p>When you browse the development documentation online, you can also learn about users running that action on internal infrastructure that have contributed changes to it (#59/60).</p>
<hr />
<p>And if you'd like to dabble yourself a bit trouble-shooting from within the workflow, there is <a href=""https://github.com/jetmore/swaks"" rel=""nofollow noreferrer"">swaks</a> and <a href=""https://tunshell.com/"" rel=""nofollow noreferrer"">tunshell</a> might be of use. Perhaps you're able to find the correct SMTP configuration this way. But just asking the admin for the correct settings is likely easier, especially if network traffic is actually blocked.</p>
","367456",""
"76516794","76512235","2023-06-20 16:40:55","0","<p>I could solve it:
I had to adapt my Dockerfile and write &quot;COPY dbt .&quot;, because this is the subfolder where the actual dbt code is located</p>
","4904027",""
"76615304","76611427","2023-07-04 19:06:01","0","<p>There can be multiple aspects to the question</p>
<blockquote>
<p>How to verify if the github syntax variables actually exist in github actions workflow yaml?</p>
</blockquote>
<p>This is especially with <code>${{ env.some_variable }}</code>, as the parameter expressed here by the Github Actions Expression syntax is also an environment parameter that can be expressed in POSIX Shell Command Language syntax well at other places of the Microsoft Github Actions Workflow YAML, namely <code>run:</code>.</p>
<p>Which is an aspect you can easily make use of, as the Shell Command Language parameter substitution rules outline how to error – even with an optional message – when a parameter is unset or empty (null) or both.</p>
<p>Considering the string value of the property named &quot;run&quot; to be part of the workflow YAML (which it obviously is), it would already fall in this category. However, adding power to the shell does not yield this force:</p>
<pre class=""lang-yaml prettyprint-override""><code>    run: echo &quot;thou shall error on non-existence ${some_variable:?}!&quot;
</code></pre>
<p><em>(The default shell, not the <em>powershell</em>; just writing. <a href=""https://pubs.opengroup.org/onlinepubs/009604499/utilities/xcu_chap02.html#tag_02_06_02"" rel=""nofollow noreferrer"" title=""2.6.2 Parameter Expansion"">ref</a>)</em></p>
<p>That is, the expression with the Github Actions Expressions syntax in question, <code>${{ env.some_variable }}</code>, it expresses what is the environment variable named &quot;some_variable&quot; within the string value of the run property given its syntax.</p>
<p>Now, such convenient substitution features you may only find in syntax of expressions of greater age and given that the Github Actions Expressions syntax has not yet aged, in comparison, you may find its properties limited, however there <em>is</em> an operator that at least can provide a default value.</p>
<p>Javascript-esque as it may be intended, the operators' syntax character sequence of two times the pipe symbol: <code>||</code>, also listening to the name &quot;OR operator&quot;.</p>
<p>Now Github Actions Expressions do not have any concept of error handling apart from their syntax – there <em>are</em> syntax errors as you noticed – so they are by their definition error free otherwise. Therefore, this operator may only be used to provide a default value and not express an error condition per-se:</p>
<pre><code>${{ env.some_variable || &quot;if you can read me, some_variable does not exists&quot; }}
</code></pre>
<p><em>(<a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#operators"" rel=""nofollow noreferrer"" title=""Operators"">ref</a>)</em></p>
<p>So, while you can make the expression half-way self-asserting, you would then need to take care of the second half your own.</p>
<hr />
<p>There is something dirty you could do to provoke a real error and that is to provide an object instead of a string/scalar (<a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#literals"" rel=""nofollow noreferrer"">literal</a>), as IIRC this does not compute the expression at that level of the Github Actions YAML executor/runner and errors as the data type is incompatible.</p>
<p>It's a bit of living on the razors edge, so try before buy.</p>
<p>The <a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#fromjson"" rel=""nofollow noreferrer"" title=""fromJSON()"">fromJSON()</a> function allows you to return an object and that data type should be <em>incompatible</em> within string context (inferred from <em>literal</em>), and perhaps already the function call errors with syntax-error-like, as <em>not</em> being JSON Text:</p>
<pre><code>${{ env.some_variable || fromJSON('{&quot;some_variable does not exists&quot;}') }}
</code></pre>
<p>That is intentionally not JSON Text (wrong JSON) so hopefully it suffices to provoke an error with fromJSON(). If not (as this is intended, but also as written, you should try this first), the other approach would be to provide an object in the hope it errors in the string context:</p>
<pre><code>${{ env.some_variable || fromJSON('{&quot;error&quot;: &quot;some_variable does not exists&quot;}') }}
</code></pre>
<hr />
<p>Contexts other than <em>env</em> are better validated, IIRC <em>input</em> for example. So you can make a composite action, define the inputs and if those are missing (while required, unset – not empty) there will be an error. You could then in the workflow map other contexts onto the <code>with:</code> properties resulting in better validation.</p>
","367456",""
"76685576","76681761","2023-07-14 07:31:10","0","<p>When facing the issue of my React app not running in the original path <em>/home/samuel/actions-runner/client/github-actions-example-client/github-actions-example-client/build</em>, I found a solution within my GitHub Actions workflow file to move the build folder to the desired location (<em>/var/www/</em>) using the sudo command.</p>
<p>However, it's important to note that providing the user password as plain text within the workflow is not considered the most secure approach. To address this, I utilized <strong>GitHub Secrets</strong> to securely store and access sensitive information like passwords.</p>
<p>Here's how I modified my workflow file to move the build folder using the sudo command:</p>
<pre><code>    run: echo &quot;${{ secrets.USER_PASSWORD }}&quot; | sudo -S rm -R /var/www/build

    run: echo &quot;${{ secrets.USER_PASSWORD }}&quot; | sudo -S mv /home/samuel/actions-runner/client/github-actions-example-client/github-actions-example-client/build /var/www
</code></pre>
<p>In this example, I stored my user password as a secret named <strong>USER_PASSWORD</strong> in the GitHub repository's Secrets settings.</p>
","17975403",""
"77498800","76746551","2023-11-17 00:51:06","2","<p>Using the <code>pull_request_target</code> event instead of <code>pull_request</code> in your GitHub Actions workflow is a suitable approach for this scenario.</p>
<p>It allows workflows to access repository secrets when triggered by pull requests from forks, addressing the limitation you've encountered. However, it's crucial to handle this feature with care due to its security implications.</p>
","5127522",""
"76750640","76749213","2023-07-23 23:08:03","1","<p>The issues with the code example above were:</p>
<ul>
<li><a href=""https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs"" rel=""nofollow noreferrer"">job-level outputs</a>
<ul>
<li>When using outputs across different jobs, the required outputs should be defined on job level and not step level only.</li>
</ul>
</li>
<li><a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#fromjson"" rel=""nofollow noreferrer"">fromJSON</a>
<ul>
<li><code>matrix_values</code> output then needs to be used in <a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix"" rel=""nofollow noreferrer""><code>strategy.matrix</code></a> which requires <code>fromJSON</code> to convert the value to an array.</li>
</ul>
</li>
</ul>
<p>Detailed discussion and generic example available in this answer: <a href=""https://stackoverflow.com/a/62953566/17490003"">Github Actions: How use strategy/matrix with script</a></p>
<p>Based on the <a href=""https://github.com/knowyrtech/matrix/actions/runs/5639102625/workflow"" rel=""nofollow noreferrer"">url provided</a> in comments, here is the updated version with correctly setting and exporting the required output for matrix usage:</p>
<pre><code>jobs:
  convert-to-matrix:
    runs-on: ubuntu-latest

    steps:
      - name: Get LS Output
        id: matrix_step
        run: |
          list=$(ls -1 /etc/*.conf);
          matrix_values=$(echo '[ &quot;'&quot;$(echo &quot;$list&quot; | sed ':a;N;$!ba;s/\n/&quot;, &quot;/g')&quot;'&quot; ]')
          echo &quot;Matrix values: $matrix_values&quot;
          echo &quot;matrix_values=$matrix_values&quot; &gt;&gt; $GITHUB_OUTPUT
    outputs:
      matrix-combination: ${{ steps.matrix_step.output.matrix_values }}   
  build:
    runs-on: ubuntu-latest
    needs: convert-to-matrix
    
    strategy:
      matrix: 
        filename: ${{ fromJSON(needs.setup-matrix.outputs.matrix-combinations) }}
</code></pre>
<hr />
","17490003",""
"76797940","76797766","2023-07-30 13:20:20","1","<p>Giving GitHub Actions permission to create and/or approve pull requests can introduce a number of security issues, so there is a seperate policy in your actions setting that restricts Actions from Creating and Approving pull requests that must be enabled seperately.</p>
<p>See:</p>
<ul>
<li><a href=""https://docs.github.com/en/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#preventing-github-actions-from-creating-or-approving-pull-requests"" rel=""nofollow noreferrer"">https://docs.github.com/en/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#preventing-github-actions-from-creating-or-approving-pull-requests</a></li>
</ul>
<blockquote>
<p>You can choose to allow or prevent GitHub Actions workflows from creating or approving pull requests.</p>
<p>By default, when you create a new enterprise, workflows are not allowed to create or approve pull requests.</p>
<ol>
<li><p>In the top-right corner of GitHub.com, click your profile photo, then click Your enterprises.</p>
</li>
<li><p>In the list of enterprises, click the enterprise you want to view.</p>
</li>
<li><p>In the enterprise account sidebar, click Policies. Under &quot;Policies&quot;, click Actions.</p>
</li>
<li><p>Under &quot;Workflow permissions&quot;, use the Allow GitHub Actions to create and approve pull requests setting to configure whether GITHUB_TOKEN can create and approve pull requests.</p>
</li>
<li><p>Click <kbd>Save</kbd> to apply the settings.</p>
</li>
</ol>
</blockquote>
<p>The same setting can be found in the organization settings and the repository settings:</p>
<p><a href=""https://i.sstatic.net/inmZy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/inmZy.png"" alt=""Go to Settings, Actions"" /></a></p>
<p><a href=""https://i.sstatic.net/9JiDi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9JiDi.png"" alt=""Scroll down to set the permissions for the token"" /></a></p>
<p>And when doing a pull request across branches, you may have to provide your own PAT token or Oauth App Token because the token created for Actions is only authorized in the repo hosting the workflow.</p>
","736079",""
"77007901","76952023","2023-08-30 12:09:40","1","<p>Unlike <code>pull_request</code>, <code>pull_request_target</code> run the workflow in the context of the target repository, so you have access to the secrets. You can reduce this vulnerability by adding <code>labeled</code> type, however it doesn't really make this a safe approach</p>
<p>From <a href=""https://securitylab.github.com/research/github-actions-preventing-pwn-requests/"" rel=""nofollow noreferrer"">Keeping your GitHub Actions and workflows secure</a></p>
<blockquote>
<p>As such this approach should only be used as a temporary solution,
until a proper fix from the options above is applied. Since external
users do not have the permission to assign labels, this effectively
requires repository owners to manually review changes first and is
also prone to human error.</p>
<p>Note that there is an important “gotcha” to any remediation put in
place for a vulnerable workflow. All PRs that were opened before a fix
was made to the vulnerable workflow will use the version of the
workflow as it existed at the time the PR was opened. That means that
if there is a pending PR, any updates to the PR may still abuse the
vulnerable workflow. It is advisable to either close or rebase such
PRs if untrusted commits may be added to them after a vulnerable
workflow is fixed.</p>
<p>You may ask yourself: if the pull_request_target workflow only checks
out and builds the PR, i.e. runs untrusted code but doesn’t reference
any secrets, is it still vulnerable?</p>
<p>Yes it is, because a workflow triggered on pull_request_target still
has the read/write repository token in memory that is potentially
available to any running program. If the workflow uses
actions/checkout and does not pass the optional parameter
persist-credentials as false, it makes it even worse. The default for
the parameter is true. It means that in any subsequent steps any
running code can simply read the stored repository token from the
disk. If you don’t need a repository write access or secrets, just
stick to the pull_request trigger.</p>
</blockquote>
<p>If you still want to go that way add the <code>pull_request_target</code> trigger with <code>labeled</code> type</p>
<pre><code>on:
  pull_request_target:
    types: [labeled]
</code></pre>
<p>Create a label via <code>Pull requests -&gt; Labels -&gt; new label</code> and apply it to the pull request from Labels section in the right side menu when you are ready to merge the PR, this will trigger the workflow.</p>
","5168011",""
"77010688","76952023","2023-08-30 18:34:23","6","<p>By default, all first-time contributors require approval to run workflows if they use the pull_request event. They no longer need approval for the same repository after the first contribution. The workflows will be triggered automatically. According to GitHub's official documentation, workflows for PRs against forked repos using <strong>pull_request events do not have access to the base repository secrets.</strong></p>
<p>As a result, you will not be able to access the secrets in the workflow for PR against forked repository.
You can obtain the secrets using pull_request_target, but a <strong><a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target:%7E:text=Warning%3A%20For,with%20this%20event."" rel=""noreferrer"">risk</a></strong> is involved. According to the official GitHub documentation, if you use pull_request_target event, you should not check out, build, or run untrusted code from the pull request. That is exactly what your workflow is doing.</p>
<p>There is a alternative, You can have a separate workflow with event <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run"" rel=""noreferrer"">workflow_run</a> that will be triggered after the completion of CI pipeline. workflow_run  allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not.</p>
<p>Still in both the cases (pull_request_target,workflow_run) there is risk associated. <strong>Please proceed with caution!</strong></p>
<p>Hope this helps!</p>
","8898011",""
"77025082","77009521","2023-09-01 17:35:50","0","<p>I found out the reason from <a href=""https://github.com/kivy/buildozer/issues/1357"" rel=""nofollow noreferrer"">this question</a>, which would solve enough to change buildozer -v android debug to echo y | buildozer -v android debug.
New file yml:</p>
<p>name: CI</p>
<pre><code>on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 1,15 * *'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Get Date
        id: get-date
        run: |
          echo &quot;::set-output name=date::$(/bin/date -u &quot;+%Y%m%d&quot;)&quot;
        shell: bash

      - name: Cache Buildozer global directory
        uses: actions/cache@v2
        with:
          path: .buildozer_global
          key: buildozer-global-${{ hashFiles('buildozer.spec') }}

      - uses: actions/cache@v2
        with:
          path: .buildozer
          key: ${{ runner.os }}-${{ steps.get-date.outputs.date }}-${{ hashFiles('buildozer.spec') }}

      - name: Build with Buildozer
        uses: ArtemSBulgakov/buildozer-action@v1
        id: buildozer
        with:
          command: echo y | buildozer -v android debug
          buildozer_version: master

      - name: Upload artifacts
        uses: actions/upload-artifact@v2
        with:
          name: package
          path: ${{ steps.buildozer.outputs.filename }}
</code></pre>
","22460542",""
"77395417","77395114","2023-10-31 11:17:29","3","<p>You have a <code>gh-action-test</code> <strong>directory</strong> in which there is a <code>gh-action-test</code> file, that's what the <code>d</code> in <code>dr-xr-xr-x</code> stands for. The <code>ls -l .</code> command shows the <code>gh-action-test</code> directory which is inside the current directory. The <code>ls -l gh-action-test</code> command shows the <code>gh-action-test/gh-action-test</code> file.</p>
<p>If you do <code>ls -ld gh-action-test</code>, you should see the same permissions as in <code>ls -l .</code></p>
","5397009",""
"77520793","77519735","2023-11-21 06:42:33","3","<p>I deleted the following code from my <code>package.json</code>.</p>
<p>And all code works normal.</p>
<pre class=""lang-js prettyprint-override""><code>&quot;packageManager&quot;: &quot;yarn@3.6.1&quot; &lt;--- remove
</code></pre>
<p>I don't know the exact reason.</p>
<p>It is necessary to confirm that checking in <code>Github Actions's policy</code> has changed.</p>
<p>Please let me know if there is a more certain way. thank you</p>
","20892191",""
"77818136","77519735","2024-01-15 07:09:22","0","<p>I think issue is with npm version . try  using v20.10.0</p>
","12661223",""
"77941440","77519735","2024-02-05 13:51:49","0","<p>So the reason is that yarn has changed how the cli works, we used to install it with <code>npm install -g yarn</code>, but they are now moving away from this approach, meaning each project would have its own yarn and yarn version. Checkout <a href=""https://yarnpkg.com/corepack"" rel=""nofollow noreferrer"">https://yarnpkg.com/corepack</a>,</p>
<p>So, to fix this, either follow the steps on the link to enable corepack, or alternatively, if you disagree with them, just remove the key and value <code>&quot;packageManager&quot;</code> inside the project's <code>package.json</code></p>
","9907360",""