AnswerId,QuestionId,AnswerCreationDate,AnswerScore,AnswerBody,AnswerAuthorId,AnswerAuthorName
"58004257","57503578","2019-09-19 05:30:33","17","<p>I made a GitHub Action that I think will help you with this use case.
<a href=""https://github.com/peter-evans/create-pull-request"" rel=""nofollow noreferrer"">https://github.com/peter-evans/create-pull-request</a></p>
<p><code>create-pull-request</code> action needs to be run in conjunction with other actions or steps that modify or add files to your repository. The changes will be automatically committed to a new branch and a pull request created.</p>
<p>Here is an example that sets most of the main inputs.</p>
<pre><code>on:
  repository_dispatch:
    types: [create-pull-request]
name: Create Pull Request
jobs:
  createPullRequest:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Create report file
        run: date +%s &gt; report.txt
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          commit-message: Add report file
          committer: Peter Evans &lt;peter-evans@users.noreply.github.com&gt;
          body: |
            New report
            - Contains *today's* date
            - Auto-generated by [create-pull-request][1]

            [1]: https://github.com/peter-evans/create-pull-request
          title: '[Example] Add report file'
          labels: report, automated pr
          assignees: peter-evans
          reviewers: peter-evans
          milestone: 1
          branch: example-patches
</code></pre>
<p>To make it bot-like you can trigger the workflow periodically.</p>
<pre><code>on:
 schedule:
   - cron: '*/5 * * * *'
</code></pre>
<p>Alternatively, you can set the workflow to trigger via webhook, as in the example above.</p>
<pre><code>on:
  repository_dispatch:
    types: [create-pull-request]
</code></pre>
<p>To trigger the workflow call the following. <code>[username]</code> is a GitHub username. <code>[token]</code> is a <code>repo</code> scoped token. <code>[repository]</code> is the name of the repository the workflow resides in.</p>
<pre><code>curl -XPOST -u &quot;[username]:[token]&quot; -H &quot;Accept: application/vnd.github.everest-preview+json&quot; -H &quot;Content-Type: application/json&quot; https://api.github.com/repos/[username]/[repository]/dispatches --data '{&quot;event_type&quot;: &quot;create-pull-request&quot;}'
</code></pre>
<p>For further examples check out the <a href=""https://github.com/peter-evans/create-pull-request/blob/main/docs/examples.md"" rel=""nofollow noreferrer"">documentation here</a>.</p>
","11934042",""
"57639714","57639507","2019-08-24 16:29:54","4","<p>You need to pass the name of the service (<code>&quot;postgres&quot;</code>) as <code>POSTGRES_HOST</code> to the application <em>and</em> set the port <code>POSTGRES_PORT: ${{ job.services.postgres.ports[5432] }}</code> (spaces matter.)</p>
<p>Github CI dynamically routes port and host to it.</p>
<p>I wrote a <a href=""http://rocket-science.ru/hacking/2019/08/19/use-github-ci-for-elixir-projects"" rel=""nofollow noreferrer"">blog post</a> on the subject a couple of days ago.</p>
","2035262",""
"58025355","57889719","2019-09-20 09:13:54","44","<p><strong>Second Update:</strong>
I got an answer in the <a href=""https://github.com/NuGet/Home/issues/8580#issuecomment-714501802"" rel=""noreferrer"">GitHub issue</a> from <code>jcansdale</code> that says (haven't tested this):</p>
<blockquote>
<p>Support for the dotnet nuget push --api-key option has now been added to GitHub Packages. For some reason this works consistently, but using basic auth (password in nuget.config file) fails randomly!</p>
</blockquote>
<p>Example:</p>
<pre><code>  - name: Publish Nuget to GitHub registry
    run: dotnet nuget push ./&lt;project&gt;/out/*.nupkg -k ${GITHUB_TOKEN} -s https://nuget.pkg.github.com/&lt;organization&gt;/index.json --skip-duplicate --no-symbols 
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</code></pre>
<p><strong>Update:</strong>
Based on <a href=""https://github.com/NuGet/Home/issues/8580#issuecomment-599056152"" rel=""noreferrer"">Dids answer on GitHub</a> my configuration works now like this:</p>
<pre><code>name: NuGet Generation

on:
  push:
    branches:
      - master
  pull_request:
    types: [closed]
    branches:
      - master

jobs:
  build:
    runs-on: ubuntu-18.04
    name: Update NuGet package
    steps:

      - name: Checkout repository
        uses: actions/checkout@v1

      - name: Setup .NET Core @ Latest
        uses: actions/setup-dotnet@v1
        with:
          source-url: https://nuget.pkg.github.com/&lt;organization&gt;/index.json
        env:
          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}        
          
      - name: Build solution and generate NuGet package
        run: |  
          cd &lt;project&gt;
          dotnet pack -c Release -o out  

      - name: Push generated package to GitHub registry
        run: dotnet nuget push ./&lt;project&gt;/out/*.nupkg --skip-duplicate --no-symbols true

</code></pre>
<p><strong>Note:</strong> At the time of writing I needed to use <code>--no-symbols true</code> instead of <code>--no-symbols</code> to prevent exceptions in the dotnet NuGet client.</p>
<hr />
<p><strong>Old answer:</strong></p>
<p>I switched to the Windows image and got it to work based on the example of <a href=""https://github.com/NuGet/Home/issues/8580#issuecomment-531997703"" rel=""noreferrer"">@anangaur</a>. This is my final code:</p>
<pre><code>name: NuGet Generation

on:
  push:
    branches:
      - master

jobs:
  build:
    runs-on: windows-latest
    name: Update NuGet 
    steps:

      - name: Checkout repository
        uses: actions/checkout@master

#  latest image has .NET already installed!
#      - name: Setup .NET environment
#        uses: actions/setup-dotnet@v1
#        with:
#          dotnet-version: '2.2.105' 
          
      - name: Build solution and generate NuGet package
        run: |  
          cd SOLUTION_FOLDER
          dotnet pack -c Release -o out  

      - name: Install NuGet client
        uses: warrenbuckley/Setup-Nuget@v1
        
      - name: Add private GitHub registry to NuGet
        run: nuget sources add -name &quot;GPR&quot; -Source https://nuget.pkg.github.com/ORGANIZATION_NAME/index.json -Username ORGANIZATION_NAME -Password ${{ secrets.GITHUB_TOKEN }}
        
      - name: Push generated package to GitHub registry
        run: nuget push .\SOLUTION_FOLDER\PROJECT_FOLDER\out\*.nupkg -Source &quot;GPR&quot; -SkipDuplicate

</code></pre>
","639367",""
"58943251","57889719","2019-11-19 21:43:36","6","<p>Here is a workaround that works on all platforms:</p>

<pre><code>name: prerelease NuGet

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    # also works with windows-latest and macos-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v1
    - name: Build with dotnet
      run: dotnet build --configuration Release --version-suffix prerelease-$(date +%Y%m%d%H%M%S)
      shell: bash
    - name: Publish nuget
      run: |
           for f in ./[repository]/bin/Release/*.nupkg
           do
             curl -vX PUT -u ""[user]:${{ secrets.GHPackagesToken }}"" -F package=@$f https://nuget.pkg.github.com/[user]/
           done
      shell: bash
</code></pre>

<p>Notes:</p>

<ul>
<li>this creates a datestamped prerelease build for every git push and uploads it to nuget

<ul>
<li>for the suffix to work, you need to set <code>&lt;VersionPrefix&gt;</code> instead of <code>&lt;Version&gt;</code> in your <a href=""https://github.com/vslee/IEXSharp/blob/master/IEXSharp/IEXSharp.csproj"" rel=""nofollow noreferrer"">.csproj</a></li>
<li>if you don't want the prerelease suffix, remove the --version-suffix parameter</li>
</ul></li>
<li>the shell is explicitly set as bash in order to allow compatibility with building on windows</li>
<li>you will need to replace [user] and [repository] above with your own specific values

<ul>
<li>you will need to create a <a href=""https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line"" rel=""nofollow noreferrer"">personal access token</a> with the permissions of write:packages</li>
<li>then create a <a href=""https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets"" rel=""nofollow noreferrer"">GitHub Secret</a> named GHPackagesToken and put the token created above in there</li>
<li>using GitHub Secrets eliminates the need for a separate file containing your token</li>
</ul></li>
<li>this assumes you're have <code>&lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;</code> in your .csproj

<ul>
<li>if you don't, then you will need an additional step running <code>dotnet pack</code></li>
</ul></li>
<li>make sure to specify <code>&lt;RepositoryUrl&gt;...&lt;/RepositoryUrl&gt;</code> in your .csproj</li>
<li>for a working example if you can't get the above code working, see <a href=""https://github.com/vslee/IEXSharp/blob/master/.github/workflows/dotnetcore.yml"" rel=""nofollow noreferrer"">https://github.com/vslee/IEXSharp/blob/master/.github/workflows/dotnetcore.yml</a>, which pushes to <a href=""https://github.com/vslee/IEXSharp/packages"" rel=""nofollow noreferrer"">https://github.com/vslee/IEXSharp/packages</a> (ignore all of my extraneous comments there)

<ul>
<li>I posted this bc I tried both the examples from jwillmer above, as well as @anangaur and @marza91 on the GH issue thread but neither worked for me (on any platform)</li>
</ul></li>
<li>once GitHub fixes the issue of not being able to use the API key directly in the <code>dotnet nuget push</code> command (see <a href=""https://github.com/NuGet/Home/issues/8580#issue-492651409"" rel=""nofollow noreferrer"">initial post of GH issue</a>), then we won't need this workaround anymore</li>
</ul>
","2847567",""
"60692976","57889719","2020-03-15 12:40:01","1","<p>My working solution:</p>

<ul>
<li>replace 'usernamecompanyname' with a valid value for your repo</li>
<li>I kept the build and pack separated to allow for easier debugging if something goes wrong</li>
<li>you can set <code>ACTIONS_RUNNER_DEBUG</code> variable in your github secrets to <code>true</code> to allow for more detailed debuging</li>
<li>Change <code>dotnet-version</code> to your desired dotnet-sdk version</li>
<li>No need to specify <code>GITHUB_TOKEN</code> in your github repo secrests, this token is present by default</li>
</ul>

<p><strong>build_and_publish_nuget.yml:</strong></p>

<pre><code>name: Build and publish package

# Controls when the action will run. Triggers the workflow on push or pull request 
# events but only for the master branch
on:
  push:
    branches: [ master ]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called ""build""
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@master

      - name: Setup .NET environment
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: '3.1.102'
          source-url: https://nuget.pkg.github.com/usernamecompanyname/index.json
        env:
          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}

      - name: Build project
        run: dotnet build -c Release

      - name: Generate a NuGet package
        run: dotnet pack --no-build -c Release -o .

      - name: Push to GitHub package registry
        run: dotnet nuget push *.nupkg
</code></pre>
","3084793",""
"61263264","57889719","2020-04-17 02:39:42","5","<p>Make sure you project file has the following</p>

<pre><code>&lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;PackageId&gt;Example.PackageName&lt;/PackageId&gt;
    &lt;Version&gt;1.0.0&lt;/Version&gt;
    &lt;Authors&gt;Author Engineering&lt;/Authors&gt;
    &lt;Company&gt;Company Inc&lt;/Company&gt;
    &lt;PackageDescription&gt;This package for ...!&lt;/PackageDescription&gt;
    &lt;RepositoryUrl&gt;
https://github.com/YOUR_ACCOUNT/Example.PackageName&lt;/RepositoryUrl&gt;
  &lt;/PropertyGroup&gt;
</code></pre>

<p>This should be your main.yaml for building, packaging, publishing, and versioning:</p>

<pre><code>name: Continuous Integration

on:
  push:
    branches:
      - master

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v1
    - name: Setup Dotnet Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.100
        source-url: https://nuget.pkg.github.com/YOUR_ACCOUNT/index.json
      env:
        NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}

    - name: Setup Nuget Config
      run: sed 's/GITHUB_TOKEN/${{ secrets.GITHUB_TOKEN }}/g' .nuget.config &gt; nuget.config

    - name: Build
      run: dotnet build --configuration Release

    - name: Version and Tag
      id: bump_version
      uses: mathieudutour/github-tag-action@v1
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}

    - name: Prep Version String
      run: echo ::set-env name=VERSION_NUMBER::$(echo ${{ steps.bump_version.outputs.new_tag }} | sed 's/[v]//g')

    - name: Define Package Name
      run: echo ::set-env name=PACKAGE_NAME::$""Example.PackageName/bin/Release/Example.PackageName.${{ env.VERSION_NUMBER }}.nupkg""

    - name: Set Nuget Package Version
      uses: roryprimrose/set-vs-sdk-project-version@v1
      with:
        version: ${{ env.VERSION_NUMBER }}

    - name: Pack
      run: dotnet pack --configuration Release Example.PackageName

    - name: Publish Package
      run: dotnet nuget push Example.PackageName/bin/Release/*.nupkg --source https://nuget.pkg.github.com/YOUR_ACCOUNT/index.json

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.bump_version.outputs.new_tag }}
        release_name: Release ${{ github.ref }}

</code></pre>
","6068528",""
"63175926","57889719","2020-07-30 14:59:21","6","<p>You can use the <a href=""https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-nuget-add-source"" rel=""noreferrer""><code>dotnet nuget add source</code> command</a>:</p>
<pre><code>    - name: NuGet push
      run: |
        dotnet nuget add source https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json --name github --username ${{ github.repository_owner }} --password ${{ github.token }} --store-password-in-clear-text
        dotnet nuget push **/*.nupkg --source github
</code></pre>
<p>The <code>--store-password-in-clear-text</code> option was required for me when running in a linux environment.</p>
<p>With this method, there's no need to modify the <code>actions/setup-dotnet</code> task.
Also, this method would allow you to push to multiple NuGet streams if needed.</p>
","1250319",""
"63943965","57889719","2020-09-17 18:11:44","1","<p>GitHub has been having intermittent issues with publish NuGet Packages to GitHub Packages.  I reached out to support and they gave me two options.</p>
<p><strong>Option 1: CURL</strong></p>
<pre><code>curl -vX PUT -u &quot;&lt;username&gt;:&lt;TOKEN&gt;&quot; -F package=@PATH-TO-PKG-FILE.nupkg https://nuget.pkg.github.com/&lt;OWNER&gt;/
</code></pre>
<p><strong>Option 2: DOTNET GPR TOOL</strong><br />
<a href=""https://github.com/jcansdale/gpr"" rel=""nofollow noreferrer"">https://github.com/jcansdale/gpr</a></p>
<pre><code>dotnet tool install gpr -g
gpr push PATH-TO-PKG-FILE.nupkg -k &lt;TOKEN&gt;
</code></pre>
<p>I went with <strong>Option 2</strong> in my GitHub Action Workflow:</p>
<pre><code>$file = Get-ChildItem -Path &lt;where I output my nupkg file to&gt; -Recurse -Filter *.nupkg | Select -First 1
gpr push $file.FullName -k ${{secrets.GITHUB_TOKEN}}          
</code></pre>
","229897",""
"70626630","57889719","2022-01-07 20:08:10","4","<p>The other answers were so long, I don't know why. This is what I do:</p>
<h1>For NuGet.org:</h1>
<pre><code>- name: Push Package to NuGet.org
  run: dotnet nuget push *.nupkg -k ${{ secrets.NUGET_ORG_API_KEY }} -s https://api.nuget.org/v3/index.json
</code></pre>
<h1>For GitHub.com:</h1>
<pre><code>- name: Push Package to GitHub.com
  run: dotnet nuget push *.nupkg -k ${{ secrets.GITHUB_TOKEN }} -s https://nuget.pkg.github.com/USERNAME/index.json
</code></pre>
","1275774",""
"58636619","58630097","2019-10-31 03:40:17","11","<p>I think you can resolve it by associating <code>master</code> with <code>origin master</code> like this:</p>

<pre><code>git fetch origin master:master
git diff --name-only master
</code></pre>

<p>Be aware that events that trigger <code>on: pull_request</code> workflows are not associated with a branch, they are associated with a merge commit SHA. So <code>actions/checkout@v1</code> by default will checkout the merge commit specified by <code>GITHUB_SHA</code>, not the branch that is merging into the base. See the <a href=""https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows#pull-request-event-pull_request"" rel=""noreferrer"">documentation here</a>. </p>

<p>You can override this default behaviour and checkout the branch merging into the base like this:</p>

<pre><code>      - uses: actions/checkout@master
        with:
          ref: ${{ github.head_ref }}
</code></pre>

<p>I'm not sure if this will be necessary for your use case, but there might be unintended effects when running <code>diff</code> on the merge commit.</p>
","11934042",""
"58964728","58933795","2019-11-20 22:59:53","1","<p>I cannot comment to ask questions due to my reputation but I'll try to answer.</p>

<p>I don't know your workflow but if I understand well, you can use args keyword and also entrypoint like that : </p>

<pre><code>steps:
  - name: It does something 
    uses: circleci/android:api-28
    with:
      entrypoint: /entrypoint.sh
      args: |
         COPY entrypoint.sh /entrypoint.sh
         RUN sudo chmod +x entrypoint.sh
</code></pre>

<p>I really don't know if it will work like that, but maybe <a href=""https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswithargs"" rel=""nofollow noreferrer"">this documentation can help you</a>.</p>
","7087644",""
"58975914","58975112","2019-11-21 13:13:23","1","<p>To use --release to have to set up the key store and signingConfigs on android. That was done? I've and app setup with Actions and kind-of-work (it fails because the app is using flutter dev channel and the image of actions use stable).</p>

<p>Try first using 'build apk --debug'</p>

<p>Also, use ls to look into a directory:</p>

<pre><code>    - run: ls android/build/app/outputs/apk/release/
</code></pre>
","3773452",""
"59242962","59236611","2019-12-09 05:23:11","4","<p>As <a href=""https://stackoverflow.com/a/59238828/2089675"">another (deleted) answer</a> mentioned, this is a PATH issue.</p>

<p>Use this workflow instead:</p>

<pre><code>name: test
on:
  push:
    branches:
    - ""**""
jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os:
        - ubuntu-latest
        - macOS-latest
        - windows-latest
    steps:
    - name: setup go
      uses: actions/setup-go@v1
      with:
        go-version: 1.x
    - name: setup env
      run: |
        echo ""::set-env name=GOPATH::$(go env GOPATH)""
        echo ""::add-path::$(go env GOPATH)/bin""
      shell: bash
    - name: checkout
      uses: actions/checkout@v1
      with:
        fetch-depth: 1
        path: src/github.com/${{ github.repository }}
    - name: golint
      run: |
        go env
        go install golang.org/x/lint/golint
        golint ./...
</code></pre>
","2089675",""
"59242979","59240304","2019-12-09 05:25:54","0","<p>The <a href=""https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners#windows-server-2019"" rel=""nofollow noreferrer"">windows environment</a> comes with <a href=""https://chocolatey.org/"" rel=""nofollow noreferrer""><code>chocolatey</code></a> package manager. So just do:</p>

<pre><code>run: choco --yes install k6
</code></pre>

<p>See: <a href=""https://chocolatey.org/packages/k6"" rel=""nofollow noreferrer"">https://chocolatey.org/packages/k6</a></p>
","2089675",""
"59869619","59474920","2020-01-22 23:21:51","0","<ol>
<li>Try and validate your code using <a href=""https://yamlvalidator.com/"" rel=""nofollow noreferrer"">yaml validator</a>.  </li>
<li>Make sure you've added your azure-devops-token onto your GitHub project settings for Secrets page. </li>
<li>Try and lower case the <code>Azure/pipelines@v1</code> to <code>azure/pipelines@v1</code>. </li>
</ol>

<p>Otherwise, your code looks very similar to the same code I run and it's working for me.  </p>
","7988162",""
"59567187","59566458","2020-01-02 17:00:43","1","<p>Using <a href=""https://github.com/marketplace/actions/github-push"" rel=""nofollow noreferrer"">GitHub Push by ad-m</a> fixed my issue. I'm pretty sure that I already tested this action.</p>
","5663348",""
"69006543","59759353","2021-09-01 00:24:32","0","<p>Not sure if you are still having trouble with this, but if so, I had to add the workspace prefix to get this to work correctly.</p>
<pre><code>-workspace ${GITHUB_WORKSPACE}/MyApp.xcworkspace
</code></pre>
","6592100",""
"60826105","60176044","2020-03-24 06:46:48","-4","<p>You need to define your environment variables in ""Secrets"" section of your repository. Then you can simply use your secrets in your workflow.</p>

<p>Example usage:</p>

<pre><code>- uses: some-action@v1
  env:
    API_KEY: ${{ secrets.API_KEY }}
    SECRET_ID: ${{ secrets.SECRET_ID }}
  with:
    password: ${{ secrets.MY_PASSWORD }}

</code></pre>

<p>Here is the documentation:</p>

<p><a href=""https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets"" rel=""nofollow noreferrer"">https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets</a></p>
","470214",""
"61734454","60176044","2020-05-11 16:24:06","10","<p>Edit:
You were using Circleci Contexts, so with that you had a set of secrets of each env. I know they are working to bring secrets to org level, and maybe team level... there is no info if they will create sort of contexts like we have in CCI.</p>

<p>I have thought on adding the env as prefix of the secret name like STAGE_GITHUB_KEY or INTEGRATION_GITHUB_KEY using ${env}_GITHUB_KEY on the yml as a workaround for now... What do you think?</p>

<p>--- Original answer:
If I understand you well, you already have the dotenv files stored somewhere and you want to inject all those secrets into the steps, without having to manually add them to github secrets and do the mapping in each workflow you migrate... right?</p>

<p>There is an action made by someone that reads a dotenv file and put its values into ouputs, so you can use them linked in further steps. Here is the link: <a href=""https://github.com/marketplace/actions/dotenv-action"" rel=""noreferrer"">https://github.com/marketplace/actions/dotenv-action</a></p>

<p>Whatever is present in the .env file will be converted into an output variable. For example .env file with content:</p>

<pre><code>VERSION=1.0
AUTHOR=Mickey Mouse
</code></pre>

<p>You do:</p>

<pre><code>id: dotenv
uses: ./.github/actions/dotenv-action
</code></pre>

<p>Then later you can refer to the alpine version like this ${{ steps.dotenv.outputs.version }}</p>
","7358206",""
"63350136","60176044","2020-08-11 01:13:32","231","<p>A quick solution here could be having a step to manually create the <code>.env</code> file before you need it.</p>
<pre><code>      - name: 'Create env file'
        run: |
          touch .env
          echo API_ENDPOINT=&quot;https://xxx.execute-api.us-west-2.amazonaws.com&quot; &gt;&gt; .env
          echo API_KEY=${{ secrets.API_KEY }} &gt;&gt; .env
          cat .env
</code></pre>
","2444877",""
"64452700","60176044","2020-10-20 20:13:19","41","<p>The easiest way to do this is to create the .env file as a github secret and then create the .env file in your action.<br />
So step 1 is to create the .env files as a secret in github as a base64 encoded string:<br>
<code>openssl base64 -A -in qa.env -out qa.txt</code><br>
or<br>
<code>cat qa.env | base64 -w 0 &gt; qa.txt</code><br>
Then in you action, you can do something like</p>
<pre><code>- name: Do Something with env files
  env:
    QA_ENV_FILE: ${{ secrets.QA_ENV_FILE }}
    PROD_ENV_FILE: ${{ secrets.PROD_ENV_FILE }}
  run: |
    [ &quot;$YOUR_ENVIRONMENT&quot; = qa ] &amp;&amp; echo $QA_ENV_FILE | base64 --decode &gt; .env
    [ &quot;$YOUR_ENVIRONMENT&quot; = prod ] &amp;&amp; echo $PROD_ENV_FILE | base64 --decode &gt; .env
</code></pre>
<p>There are a number of ways for determining <code>$YOUR_ENVIRONMENT</code> but usually this can be extracted from the <code>GITHUB_REF</code> object.  You applications should be able to read from the .env files as needed.</p>
","6895064",""
"65899220","60176044","2021-01-26 10:01:39","4","<p>Another alternative is to use the <a href=""https://docs.github.com/en/actions/reference/environments"" rel=""nofollow noreferrer"">Environments</a> feature from github. Although that isn't available on private repos in the free plan.
You could have scoped variables, at repository, profile/organization level and environment. The configuration variables closer to the repository takes precedence over the others.</p>
","3746240",""
"67543246","60176044","2021-05-15 04:24:30","43","<p>I would suggest 3 pretty simple ways to engage your <code>.env</code> file variables in the GitHub Actions workflow. They differ based on whether you store the file in your repository (the worst practice) or keep it out of it (the best practice).</p>
<ol>
<li><p>You keep your <code>.env</code> file in the repository:</p>
<ul>
<li>There are some <a href=""https://duckduckgo.com/?q=github+actions+dotenv&amp;atb=v242-1&amp;ia=web&amp;iai=r1-1&amp;page=1&amp;sexp=%7B%22biaexp%22%3A%22b%22%2C%22msvrtexp%22%3A%22b%22%2C%22earlydeep%22%3A%22a%22%7D"" rel=""nofollow noreferrer"">ready-made actions</a> that allow to read the <code>.env</code> variables (e.g. <a href=""https://github.com/marketplace/actions/dotenv-action"" rel=""nofollow noreferrer"">Dotenv Action</a>,<a href=""https://github.com/marketplace/actions/simple-dotenv"" rel=""nofollow noreferrer"">Simple Dotenv</a>).</li>
</ul>
</li>
<li><p>(<em>simple, manual, annoying when update <code>.env</code> variables</em>) You keep your file out of your repository (keep there and maintain updated <code>.env.example</code> instead):</p>
<ul>
<li><p>You manually copy the content of the respective <code>.env</code>    files (say <code>.env.stage</code>, <code>.env.production</code>) into the respective GitHub Actions <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets"" rel=""nofollow noreferrer"">secret variables</a> (say <code>WEBSITE_ENV_STAGE</code>, <code>WEBSITE_ENV_PRODUCTION</code>).</p>
</li>
<li><p>Then at your GitHub Actions workflow script create the <code>.env</code> file from the desired variable like this <code>echo &quot;${{secrets.WEBSITE_ENV_STAGE }}&quot; &gt; .env</code> and use it in the workflow.</p>
</li>
</ul>
</li>
<li><p>(<em>a bit more involved though prepare it once, then change your <code>.env</code> variables at the local machine, then sync these at GitHub with one click</em>) As in item 2 above, the file is out of the repository.</p>
<ul>
<li>Now you use the GitHub Actions API to <a href=""https://docs.github.com/en/rest/reference/actions#create-or-update-a-repository-secret"" rel=""nofollow noreferrer"">create or update the secrets</a>. On your local machine in the <code>dev</code> environment you write the NodeJS script that calls the API endpoint and write the <code>.env</code> files to the desired GitHub Actions secret variable (say as above into <code>WEBSITE_ENV_STAGE</code> or to both stage and production variables at once);</li>
</ul>
</li>
</ol>
<p>This is pretty wide choice of ways to engage the <code>.env</code> files's variables in the workflow. Use any matching your preference and circumstances.</p>
<p>Just for information, there is the 4th way which engages some 3rd party services like <a href=""https://www.dotenv.org/vault"" rel=""nofollow noreferrer"">Dotenv Vault</a> or <a href=""https://www.vaultproject.io/"" rel=""nofollow noreferrer"">HasiCorp Vault</a> (there are more of the kind) where you keep you secret variables to read these to create <code>.env</code> file at build time with your CI/CD pipeline. Read there for details.</p>
","6597265",""
"68975466","60176044","2021-08-29 17:39:29","0","<p>I was having the same issue. What I wanted was to upload a .env file to my server instead of defining the env variables in my Github repo. Since I was not tracking my .env file so every time my workflow ran the .env file got deleted. So what I did was :</p>
<ol>
<li>Added the <code>.env</code> file in the project root directory in my server.</li>
<li>Added <code>clean: false</code> under <code>with</code> key in my <code>actions/checkout@v2</code> in my workflow</li>
</ol>
<p>eg:</p>
<pre><code>jobs:
  build:

    runs-on: self-hosted

    strategy:
      matrix:
        node-version: [14.x]
       
    - uses: actions/checkout@v2
      with: 
        clean: 'false'
</code></pre>
<p>This prevents git from deleting untracked files like .env. For more info see: <a href=""https://github.com/actions/checkout"" rel=""nofollow noreferrer"">actions/checkout</a></p>
","16781183",""
"71030893","60176044","2022-02-08 08:46:36","13","<p>You can also use a dedicated <code>github action</code> from github-marketplace to create <code>.env</code> files.</p>
<p>Example usage:</p>
<pre><code>name: Create envfile

on: [push]

jobs:

  create-envfile:
 
    runs-on: ubuntu-18.04
 
    steps:
    - name: Make envfile
      uses: SpicyPizza/create-envfile@v1
      with:
        envkey_DEBUG: false
        envkey_SOME_API_KEY: &quot;123456abcdef&quot;
        envkey_SECRET_KEY: ${{ secrets.SECRET_KEY }}
        file_name: .env
</code></pre>
<p>Depending on your values defined for secrets in github repo, this will create a <code>.env</code> file like below:</p>
<pre><code>DEBUG: false
SOME_API_KEY: &quot;123456abcdef&quot;
SECRET_KEY: password123
</code></pre>
<p>More info: <a href=""https://github.com/marketplace/actions/create-env-file"" rel=""noreferrer"">https://github.com/marketplace/actions/create-env-file</a></p>
","2339586",""
"71166556","60176044","2022-02-17 23:15:54","3","<p>I tried using the accepted solution but GitHub actions were complaining about the shell commands. I kept getting this error: <code>line 3: unexpected EOF while looking for matching ``'</code></p>
<p>Instead of referencing the secrets directly in the shell script, I had to pass them in separately.</p>
<pre><code>  - name: Create env file
    run: |
      touch .env
      echo POSTGRES_USER=${POSTGRES_USER} &gt;&gt; .env
      echo POSTGRES_PASSWORD=${POSTGRES_PASSWORD} &gt;&gt; .env
      cat .env
    env: 
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }} 
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }} 
</code></pre>
","7776992",""
"71351918","60176044","2022-03-04 13:08:23","1","<p>One more approach would be doing something as described in <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets#limits-for-secrets"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/security-guides/encrypted-secrets#limits-for-secrets</a></p>
<p>So basically treating your <code>.env</code> file as a &quot;large secret&quot;. In this case, the encrypted <code>.env</code> file is kept commited in your repo, which should be fine. Then in your action have a step to decrypt the <code>.env</code> file.</p>
<p>This removes the overhead of having to create each individual secret inside your <code>.env</code> as a Github secret. The only Github secret to maintain in this case, is one for the encryption password. If you have multiple <code>.env</code> files such as <code>qa.env</code>, <code>prod.env</code>, etc... I would strongly suggest using a different encryption password for each, and then store each encryption passwords as an &quot;environment secret&quot; in Github instead of &quot;repo secret&quot; (if using Github environments is your thing. See <a href=""https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment</a>).</p>
<p>If you don't want to commit the (encrypted) <code>.env</code> file in you repo, then I would go with the base64 approach described in <a href=""https://stackoverflow.com/a/64452700/1806782"">https://stackoverflow.com/a/64452700/1806782</a> (which is simmilar to what's in <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets#storing-base64-binary-blobs-as-secrets"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/security-guides/encrypted-secrets#storing-base64-binary-blobs-as-secrets</a>) and then create a new Github secret to host the encoded contents.</p>
<p>For those like me with aversion to manual repetitive tasks, Github secret creation can these days easily be scripted with the Github CLI tool. See
<a href=""https://cli.github.com/manual/gh_secret_set"" rel=""nofollow noreferrer"">https://cli.github.com/manual/gh_secret_set</a> . It also supports 'batch' creation of secrets from env files (see the <code>-f</code>, <code>--env-file</code> flags)</p>
","1806782",""
"72699083","60176044","2022-06-21 10:20:11","6","<p>You can export all secrets to environment variables and do everything from a script.</p>
<p>I created an action exactly for that - takes all the secrets and exports them to environment variables.</p>
<p>An example would be:</p>
<pre><code>- run: echo &quot;Value of MY_SECRET1: $MY_SECRET1&quot;
  env:
    MY_SECRET1: ${{ secrets.MY_SECRET1 }}
    MY_SECRET2: ${{ secrets.MY_SECRET2 }}
    MY_SECRET3: ${{ secrets.MY_SECRET3 }}
    MY_SECRET4: ${{ secrets.MY_SECRET4 }}
    MY_SECRET5: ${{ secrets.MY_SECRET5 }}
    MY_SECRET6: ${{ secrets.MY_SECRET6 }}
    ...
</code></pre>
<p>You could convert it to:</p>
<pre><code>- uses: oNaiPs/secrets-to-env-action@v1
  with:
    secrets: ${{ toJSON(secrets) }}
- run: echo &quot;Value of MY_SECRET1: $MY_SECRET1&quot;
</code></pre>
<p>Link to the action, which contains more documentation about configuration: <a href=""https://github.com/oNaiPs/secrets-to-env-action"" rel=""noreferrer"">https://github.com/oNaiPs/secrets-to-env-action</a></p>
","1380301",""
"73359709","60176044","2022-08-15 10:26:39","0","<p>inspired by <a href=""https://stackoverflow.com/a/67543246/1238150"">Valentine Shis answer above</a>, I created a GitHub Action for this use-case and the one I had at the time while reading this thread.</p>
<p>GitHub Action: <a href=""https://github.com/marketplace/actions/next-env"" rel=""nofollow noreferrer"">next-env</a></p>
<blockquote>
<p>GitHub Action to read .env.[development|test|production][.local] files in Next.js (but also non Next.js) projects and add variables as secrets to GITHUB_ENV.</p>
</blockquote>
<p>Despite the name, it also works in non-Next.js projects as it uses a decoupled package of the Next ecosystem.</p>
","1238150",""
"77150212","60176044","2023-09-21 12:24:45","3","<p>Btw you can also do <code>gh secret set -f .env</code> if you have the github cli!</p>
","3105372",""
"77376038","60176044","2023-10-27 17:27:44","5","<p>The most modern alternative is to use a <code>.env.vault</code> file.</p>
<p>Here's a <a href=""https://www.dotenv.org/docs/languages/nodejs/github-actions"" rel=""noreferrer"">NodeJS Guide on how to use a <code>.env.vault</code> file with GitHub Actions</a></p>
<p>It boils down to 3 steps:</p>
<ol>
<li>Build your encrypted <code>.env.vault</code> file and commit that safely to code. This contains an encrypted copy of your CI secrets.</li>
<li>Set a single <code>DOTENV_KEY</code> environment variable on GitHub Actions</li>
<li>When the CI runs it will use the <code>DOTENV_KEY</code> to decrypt the contents of your <code>.env.vault</code> and inject your environment variables just in time.</li>
</ol>
<p>This approach is a little more work to initially set up (familiarizing yourself with the new .env.vault file format), but then it has the following benefits:</p>
<ul>
<li>No more scattering your secrets across multiple third parties like GitHub Actions that could leak them someday (like what happened with <a href=""https://techcrunch.com/2023/01/05/circleci-breach/"" rel=""noreferrer"">CircleCi breach</a>)</li>
<li>You can manage and check your secrets from one central place (rather than having to check GitHub Actions UI to see the value of a secret)</li>
<li>If you move CIs everything still just works. You just have to set again that single <code>DOTENV_KEY</code>, not a hundred others on the ci server. All your secrets and config are still encrypted inside your <code>.env.vault</code> file which lives safely in your repository.</li>
<li>An attacker needs access to both your <code>DOTENV_KEY</code> and your <code>.env.vault</code> file to gain access to your secrets/config. So if GitHub Actions ever has a leak of their CI secrets, your secrets will still be safe because the attacker will only have your <code>DOTENV_KEY</code> and not your <code>.env.vault</code> file. This will save you the time and annoyance of having to rotate all your secrets.</li>
</ul>
<p>Hope this is useful. Full disclosure: I am the pioneer of <a href=""https://github.com/motdotla/dotenv"" rel=""noreferrer"">dotenv</a> and also run the <a href=""https://dotenv.org"" rel=""noreferrer"">Dotenv.org</a> service. That said, the mechanism to generate your <code>.env.vault</code> file is completely open, local, and free. It's just a file format that uses AES-256 GCM encryption. I wanted the same (or close to) elegance of a .env file but with added security for production and ci deployments. <a href=""https://github.com/dotenv-org/dotenv-vault#how-do-i-use--locally-managed-dotenv-vault"" rel=""noreferrer"">See here for how to use the local only commands</a> or use <a href=""https://dotenv.org"" rel=""noreferrer"">dotenv.org for the hosted solution</a>.</p>
","18103496",""
"78142067","60176044","2024-03-11 16:13:37","1","<p>I created a GitHub Action specifically designed for utilizing your environment variables within your .env files, eliminating the need to set up secrets in GitHub project settings. Check it out here: <a href=""https://github.com/zdeneklapes/dotenv-vault-action"" rel=""nofollow noreferrer"">https://github.com/zdeneklapes/dotenv-vault-action</a>.</p>
<p>It can download the .env file of your choice and will delete all downloaded .env files as a Post Job (after all jobs are completed)!</p>
<p>You still need to set at least 1 secret, it is your <code>DOTENV_ME</code>.</p>
<h2>How to load <code>.env</code> variables into the environment?</h2>
<p>When the <code>.env</code> file is downloaded don't forget to load your environment variables using the command <code>source .env</code>.</p>
<h4>Example:</h4>
<pre class=""lang-yaml prettyprint-override""><code>- uses: zdeneklapes/dotenv-vault-action@v1
        with:
          dotenvMe: ${{ secrets.DOTENV_ME }}
          stage: &quot;ci&quot;
          move: &quot;false&quot;
- run: |
    source .env.ci
    ssh &quot;${SSH_USER}@${SSH_HOST}&quot; &quot;
    cd ${DIR_SSH_PROJECT_PRODUCTION} || exit
    docker compose -f docker-compose.prod.yml up --build
    cd - || exit
    &quot;
</code></pre>
","14471542",""
"78412095","60176044","2024-05-01 05:06:00","0","<p>Sorry I'm late, but another solution could be to preserve the basic structure of the .env file in your prod branch if you want to avoid setting a large number of variables individually and you want to prevent putting your entire .env content into a single GitHub secret variable.</p>
<p>Example of your basic .env file located in the prod branch:</p>
<pre><code>APP_NAME=App
APP_URL=http://localhost
APP_ENVIROMENT=local
APP_DEBUG=true
DB_DRIVER=mysql
CACHE_DRIVER=redis
SESSION_DRIVER=redis
</code></pre>
<p>Then only edit the variables that you want to change for prod in your actions workflow.</p>
<ul>
<li><p>Remember to add the env variables you want to change to your secrets tab on GitHub for actions.</p>
<pre><code>- name: 'Update env file for prod'
  run: |
    sed -i 's|APP_URL=http://localhost|APP_URL=${{ secrets.APP_URL }}|' .env
    sed -i 's|APP_ENVIROMENT=local/APP_ENVIROMENT=${{ secrets.APP_ENVIROMENT }}|' .env
    sed -i 's|APP_DEBUG=true/APP_DEBUG=${{ secrets.APP_DEBUG }}|' .env
</code></pre>
</li>
</ul>
<p>NOTE: The Linux sed command for editing an .env file has not been tested. You can use your own if it does not work as expected.</p>
","8773111",""
"60303169","60303168","2020-02-19 14:59:18","15","<p>No, don't put the token in the .yaml file.  For use with GitHub Actions, you add the token to the Secrets section of your GitHub repository, then leave the .yaml code above as it is.</p>

<p>Add the secret at the URL (modify with your names): <a href=""https://github.com/USERNAME/REPONAME/settings/secrets"" rel=""noreferrer"">https://github.com/USERNAME/REPONAME/settings/secrets</a> and call it CODECOV_TOKEN.  Then this .yaml code will find it.</p>

<p>(You get the repo's codecov token from <a href=""https://codecov.io/gh/USERNAME/REPONAME"" rel=""noreferrer"">https://codecov.io/gh/USERNAME/REPONAME</a>)</p>
","4470365",""
"63124890","60349533","2020-07-27 23:09:50","0","<p>from <a href=""https://angular.io/cli/e2e"" rel=""nofollow noreferrer"">docs</a> should be not <code>--protractor-config=</code>  ...  but <code>--protractorConfig</code><br />
or better set the config in angular.json by e2e configuration, as e.g. 'ci'.<br />
Then run <code>npm run e2e -- -c=ci</code><br />
<a href=""https://github.com/filipesilva/ng-github-actions/blob/master/.github/workflows/main.yml"" rel=""nofollow noreferrer"">example project</a></p>
","2519073",""
"60380617","60380374","2020-02-24 16:56:21","6","<p>If you want to use the Firebase CLI in a CI/CD environment such as GitHub Action, you'll have to provide a way for the CLI to know the account credentials it should use.  When you run locally, it can get the credentials from your interaction with <code>firebase login</code>.  But when you run elsewhere, there is no UI to prompt you.</p>

<p>You will have to <a href=""https://firebase.google.com/docs/cli#cli-ci-systems"" rel=""noreferrer"">follow the instructions in the documentation on integrating with CI/CD system</a>, and provide a token for the account that should be used to authorize the deployment.</p>
","807126",""
"60913464","60521929","2020-03-29 11:22:59","70","<p>You may add the following action prior to deploying the artifacts to azure.</p>
<p>You can specify multiple files and it is supported with wildcard entries too.</p>
<p>The environment variable key must be specified with dot separated heirarchy.</p>
<pre><code>#substitute production appsettings entries to appsettings json file
- name: App Settings Variable Substitution
  uses: microsoft/variable-substitution@v1
  with:
    files: '${{env.DOTNET_ROOT}}/myapp/appsettings.json'
  env:
    ConnectionStrings.Default: ${{ secrets.SOME_CONNECTION_STRING }}
    App.ServerRootAddress: ${{ env.SERVER_ROOT_ADDRESS }}
</code></pre>
<p>The above action can be used for xml and yaml file changes too.</p>
","12036792",""
"60771530","60768178","2020-03-20 09:30:00","10","<p>Have you tried this: <a href=""https://docs.fastlane.tools/actions/google_play_track_version_codes/"" rel=""noreferrer"">https://docs.fastlane.tools/actions/google_play_track_version_codes/</a> ?</p>

<pre><code>    g = google_play_track_version_codes
    gb = google_play_track_version_codes(track: 'beta')
    ga = google_play_track_version_codes(track: 'alpha')
    max_value = [g[0].to_i, gb[0].to_i, ga[0].to_i].max
    version_updated = max_value + 1
    increment_version_code(app_project_dir: ""./app"", version_code: version_updated.to_i)
</code></pre>

<p>Basically I'm taking all version codes of Google Play and increasing +1 the max one, and then using the versioning plugin to update it on the build.gradle</p>
","10326010",""
"70848110","60768178","2022-01-25 11:47:05","1","<p>You can add a lane to do this as described in <a href=""https://medium.com/@atul.dc/increment-build-number-using-fastlane-c12b4b886ea3"" rel=""nofollow noreferrer"">this Medium post</a> by Atul Anand:</p>
<pre><code>lane:IncrementBuildNumber do

    path = '../app/build.gradle'
    re = /versionCode\s+(\d+)/
    s = File.read(path)
    versionCode = s[re, 1].to_i
    s[re, 1] = (versionCode + 1).to_s
    f = File.new(path, 'w')
    f.write(s)
    f.close

end
</code></pre>
","1209486",""
"61049404","61048334","2020-04-05 20:57:09","1","<p>I found the easiest solution for my issue was to change the account the GitHub Actions service ran under.</p>

<p>I achieved this by using <code>powershell ""(Get-Service actions.runner.*).name""</code>to find the name of the GitHub Actions service.</p>

<p>And then running <code>sc config ""NAME_OF_YOUR_SERVICE"" obj= ""NT AUTHORITY\SYSTEM"" type= own</code> to update it to run as the system.</p>

<p><strong>EDIT:</strong></p>

<p>As @Lex Li says </p>

<blockquote>
  <p>A CI agent (for Azure Pipelines or GitHub Actions) should run under a
  dedicated account (on Windows usually a service account from Active
  Directory), so that you can tune its permissions on various resources.</p>
</blockquote>
","10642173",""
"61748039","61096521","2020-05-12 09:18:31","35","<p>As GitHub Actions is basically a container that runs commands, have you considered <em>define your key as a secret on your project and then importing it in your Github Action definition</em>?</p>
<p>Here are the steps I previously used on a project to publish the generated artifacts to Sonatype's staging repository:</p>
<ul>
<li>Open a terminal window.</li>
<li>If you don't know your key ID, search it by e-mail: <code>gpg --list-secret-keys user@example.com</code></li>
<li>Export your key as Base64: <code>gpg --export-secret-keys YOUR_ID_HERE | base64 &gt; private.key</code></li>
<li>In your Github project, create a new Secret named <strong>GPG_SIGNING_KEY</strong> and paste the Base64 content of your key.</li>
<li>In your yml workflow file, include a step to import the key from your just defined secret.</li>
</ul>
<pre><code>- name: Configure GPG Key
  run: |
    echo -n &quot;$GPG_SIGNING_KEY&quot; | base64 --decode | gpg --import
  env:
    GPG_SIGNING_KEY: ${{ secrets.GPG_SIGNING_KEY }}
</code></pre>
<p>So far, it works very well although there are a few limitations I couldn't solve:</p>
<ul>
<li>Your GPG Key should not be protected by a password. I couldn't figure out a way to import the protected keys without being asked for their secret.</li>
<li>I couldn't find a way to use my GitHub GPG Key for this process.</li>
</ul>
<p>Just in case, <a href=""https://github.com/Skullabs/injector/blob/master/.github/workflows/release.yml"" rel=""noreferrer"">here</a> is a working example of a project using this approach to publish Maven <em>artifacts</em>. The only difference from the steps above, though, is that the commands were externalized into <a href=""https://github.com/Skullabs/injector/blob/master/builder.sh#L38"" rel=""noreferrer"">a bash script file</a>.</p>
","548685",""
"65658014","61096521","2021-01-10 20:13:09","2","<p>You can also use another plugin <a href=""https://www.simplify4u.org/sign-maven-plugin/"" rel=""nofollow noreferrer"">https://www.simplify4u.org/sign-maven-plugin/</a> for signing artifacts.</p>
<p><code>sign-maven-plugin</code> simply takes signing key and rest configuration items from environment variables without special configuration.</p>
<p>Another advantage of <code>sign-maven-plugin</code> is that you need not use profiles for activate or deactivate plugin, because when signing key is not preset for plugin, plugin skip execution without error.</p>
","3149528",""
"66218731","61096521","2021-02-16 04:34:02","25","<p>Adding a new answer, since this question is about using the GPG key in maven deployments in particular.</p>
<h1>No Manual Import is Required when Using Maven</h1>
<h2>Either use <code>maven-gpg-plugin</code> 3.2.0 or Newer</h2>
<p><a href=""https://issues.apache.org/jira/browse/MGPG-106"" rel=""nofollow noreferrer"">Since version 3.2.0</a>, you can configure the plugin to use a Bouncy Castle based signer that does not depend on external gpg processes. You can configure the plugin to use this signer like so:</p>
<pre class=""lang-xml prettyprint-override""><code>&lt;plugin&gt;
    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.4&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;sign-artifacts&lt;/id&gt;
            &lt;phase&gt;verify&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;sign&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;signer&gt;bc&lt;/signer&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>Now, all you need to do in you GitHub Actions is to define a couple of environment variables:</p>
<pre class=""lang-yaml prettyprint-override""><code>- name: Publish to Apache Maven Central
  run: mvn deploy
  env:
    OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
    OSSRH_TOKEN: ${{ secrets.OSSRH_TOKEN }}
    MAVEN_GPG_PASSPHRASE: ${{ secrets.RELEASES_GPG_PASSPHRASE }}
    MAVEN_GPG_KEY: ${{ secrets.RELEASES_GPG_PRIVATE_KEY }}
</code></pre>
<h2>Alternatively, the <code>setup-java</code> Action Can Set up Your GPG Agent</h2>
<p>But even when you need to use older versions of the <code>maven-gpg-plugin</code>, the <code>setup-java</code> action supports everything out of the box. There is an <a href=""https://github.com/actions/setup-java/blob/v3.11.0/docs/advanced-usage.md#Publishing-using-Apache-Maven"" rel=""nofollow noreferrer"">example in the docs</a>:</p>
<pre class=""lang-xml prettyprint-override""><code>&lt;plugin&gt;
    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.4&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;sign-artifacts&lt;/id&gt;
            &lt;phase&gt;verify&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;sign&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;gpgArguments&gt;
                    &lt;arg&gt;--pinentry-mode&lt;/arg&gt;
                    &lt;arg&gt;loopback&lt;/arg&gt;
                &lt;/gpgArguments&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<pre class=""lang-yaml prettyprint-override""><code>    - name: Set up Apache Maven Central
      uses: actions/setup-java@v3
      with: # running setup-java again overwrites the settings.xml
        java-version: 21
        distribution: 'temurin'
        cache: 'maven'
        server-id: ossrh # Value of the distributionManagement/repository/id field of the pom.xml
        server-username: OSSRH_USERNAME # env variable for username in deploy
        server-password: OSSRH_TOKEN # env variable for token in deploy
        gpg-private-key: ${{ secrets.MAVEN_GPG_PRIVATE_KEY }} # Value of the GPG private key to import
        gpg-passphrase: MAVEN_GPG_PASSPHRASE # env variable for GPG private key passphrase

    - name: Publish to Apache Maven Central
      run: mvn deploy
      env:
        OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
        OSSRH_TOKEN: ${{ secrets.OSSRH_TOKEN }}
        MAVEN_GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
</code></pre>
<p>Note that the <code>setup-java</code> action configures Maven's <code>settings.xml</code> file for you automatically <em>and</em> imports the GPG key from the given stored secret.</p>
<p>Be aware, that during <code>setup-java</code> you only configure the <em>names</em> of the environment variables. I.e. you need to provide the (secret) values for these env variables in later steps, where you want to use them.</p>
","4014509",""
"66457517","61096521","2021-03-03 12:53:59","22","<p>Thank You everyone for your response. I now use this GitHub actions which makes the process much more simpler:</p>
<p>Step 1: Extract the secret key</p>
<pre><code>gpg --list-secret-keys --keyid-format LONG
gpg --export-secret-keys --armor {your_keyId}
</code></pre>
<p>Step 2: Store the extracted GPG key and passphrase as secrets</p>
<p>step 3: Include this step in your workflow</p>
<pre><code>- name: Import GPG Key
  uses: crazy-max/ghaction-import-gpg@v1
  env:
     GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
     PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
</code></pre>
","9590601",""
"75568891","61096521","2023-02-25 22:42:10","0","<p>I came up with the following solution (see <a href=""https://gist.github.com/vansergen/88eb7e71fea2e3bdaf6aa3e752371eb7"" rel=""nofollow noreferrer"">here</a>)</p>
<pre class=""lang-yaml prettyprint-override""><code>steps:
  - name: Import GPG key
    run: echo $GPG_KEY | base64 --decode | gpg --batch --import
    env:
      GPG_KEY: ${{ secrets.GPG_KEY }}

  - name: Add the custom gpg siging program that passes the passphrase to the gpg CLI
    run: |
      rm -rf /tmp/gpg.sh
      echo '#!/bin/bash' &gt;&gt; /tmp/gpg.sh
      echo 'gpg --batch --pinentry-mode=loopback --passphrase $GPG_KEY_PASSPHRASE $@' &gt;&gt; /tmp/gpg.sh
      chmod +x /tmp/gpg.sh

  - name: Setup git
    run: |
      git config commit.gpgsign true
      git config user.signingkey $GPG_KEY_ID
      git config gpg.program /tmp/gpg.sh
    env:
      GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
</code></pre>
","20644816",""
"61268185","61268184","2020-04-17 09:26:31","1","<p>I've created a simple CLI that can help you achieve that - <a href=""https://github.com/unfor19/githubsecrets"" rel=""nofollow noreferrer"">https://github.com/unfor19/githubsecrets</a> </p>

<p>This CLI is based on the official <a href=""https://developer.github.com/v3/actions/secrets/#secrets"" rel=""nofollow noreferrer"">GitHub Actions Secrets API</a></p>

<p>Install with pip</p>

<pre class=""lang-sh prettyprint-override""><code>$ pip install githubsecrets
...
$ ghs --help
...
</code></pre>

<p>Or use with Docker; you must supply all arguments, prompts are not available in Docker mode</p>

<p>macOS and Linux</p>

<pre class=""lang-sh prettyprint-override""><code>$ docker run -v $HOME:/root unfor19/githubsecrets --help
Usage: ghs [OPTIONS] COMMAND [ARGS]...
</code></pre>

<p>Windows</p>

<pre class=""lang-sh prettyprint-override""><code>$ docker run --rm -v c:/Temp:/root unfor19/githubsecrets --help
Usage: ghs [OPTIONS] COMMAND [ARGS]...
</code></pre>

<p><img src=""https://githubsecrets.s3-eu-west-1.amazonaws.com/githubsecrets-demo.gif"" alt=""Usage-Demo""></p>
","5285732",""
"61268481","61268184","2020-04-17 09:43:29","1","<p>Another one, in ruby:</p>

<pre><code>$ gem install secret_hub
</code></pre>

<p>also using the official Github API, and supports bulk operations.</p>

<p><a href=""https://github.com/dannyben/secret_hub"" rel=""nofollow noreferrer"">https://github.com/dannyben/secret_hub</a></p>

<p>Full disclosure: I wrote it, following <a href=""https://github.community/t5/GitHub-Actions/Secrets-on-Team-and-Organization-level/td-p/29745"" rel=""nofollow noreferrer"">this discussion</a> about the missing feature in GitHub to have organization-level secrets.</p>
","413924",""
"66294974","61289322","2021-02-20 18:12:16","0","<p>Example file below which I managed to use to complete this task.</p>
<pre class=""lang-yaml prettyprint-override""><code>on:
  pull_request:
    types: [closed]
    branches: [master]
  
name: Create Release with merge file

jobs:
  build:
    runs-on: windows-latest
    if: github.event.pull_request.merged == true
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Set up Python 3.7.9
        uses: actions/setup-python@v1
        with:
          python-version: 3.7.9
          architecture: 'x64'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pynsist==2.5
          pip install six==1.14.0
          pip install retrying==1.3.3
          pip install numpy==1.18.1
          pip install requests==2.22.0
          pip install urllib3==1.25.8
          pip install chardet==3.0.4
          pip install certifi==2019.11.28
          pip install idna==2.8
      - name: Install 7Zip
        run: |
          choco install 7zip
      - name: Run the build script
        run: |
          python App001_Build.py
</code></pre>
","12446456",""
"61919791","61919141","2020-05-20 17:59:53","53","<p>Use the built-in <code>fromJson(value)</code> (see here: <a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#fromjson"" rel=""noreferrer"">https://docs.github.com/en/actions/learn-github-actions/expressions#fromjson</a>)</p>
<p>Reading a file depends on the shell you're using. Here's an example for <code>sh</code>:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: Test linux job
on:
  push

jobs:
  testJob:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - id: set_var
        run: |
          content=`cat ./path/to/package.json`
          # the following lines are only required for multi line json
          content=&quot;${content//'%'/'%25'}&quot;
          content=&quot;${content//$'\n'/'%0A'}&quot;
          content=&quot;${content//$'\r'/'%0D'}&quot;
          # end of optional handling for multi line json
          echo &quot;::set-output name=packageJson::$content&quot;
      - run: |
          echo &quot;${{fromJson(steps.set_var.outputs.packageJson).version}}&quot;

</code></pre>
<p>Multi line JSON handling as per <a href=""https://github.com/orgs/community/discussions/26288#discussioncomment-3251220"" rel=""noreferrer"">https://github.com/orgs/community/discussions/26288#discussioncomment-3251220</a>.</p>
<p>GitHub issue about <code>set-env</code> / <code>set-output</code> multi line handling: <a href=""https://github.com/actions/toolkit/issues/403"" rel=""noreferrer"">https://github.com/actions/toolkit/issues/403</a></p>
","3241243",""
"61922402","61919141","2020-05-20 20:34:08","2","<p>I once used this to get the value from the json data. Hope this helps</p>

<pre><code>  - name: fetch the json value
    run: |
         githubjson=`cat $GITHUB_EVENT_PATH`
         echo $githubjson
         number=`echo $(jq -r '.number' &lt;&lt;&lt; ""$githubjson"")`
         PRTitle=`echo $(jq -r '.pull_request.title' &lt;&lt;&lt; ""$githubjson"")`
         PRUrl=`echo $(jq -r '.pull_request.html_url' &lt;&lt;&lt; ""$githubjson"")`
         PRBody=`echo $(jq -r '.pull_request.body' &lt;&lt;&lt; ""$githubjson"")`
</code></pre>
","1237708",""
"64627966","61919141","2020-11-01 01:36:50","12","<p>Below is a version of the example from <a href=""https://github.blog/changelog/2020-04-15-github-actions-new-workflow-features/"" rel=""noreferrer"">Official GHA Docs</a> that includes two changes:</p>
<ol>
<li>Loads json from a file (<code>./your.json</code>)</li>
<li>Removes newline characters (<a href=""https://github.com/actions/toolkit/issues/403#issuecomment-710491683"" rel=""noreferrer"">Source</a>)</li>
<li>Uses <code>fromJson</code> to parse the output and set a matrix variable.</li>
</ol>
<pre><code>name: build
on: push
jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
    - id: set-matrix
      run: |
        JSON=$(cat ./your.json)
        echo &quot;::set-output name=matrix::${JSON//'%'/'%25'}&quot;

  job2:
    needs: job1
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{fromJson(needs.job1.outputs.matrix)}}
    steps:
    - run: build
</code></pre>
","103727",""
"65505945","61919141","2020-12-30 11:04:43","8","<pre><code>on: [push, pull_request] 
name: Build
jobs:
  build:
    name: Example
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with: 
          path: './'      
      - run: |
          echo &quot;`jq '.base_config[0].value=&quot;Alpha-21&quot;' config.json `&quot; &gt; config.json
          echo &quot;`jq '.base_config[1].value=&quot;1.2.14&quot;' config.json`&quot; &gt; config.json
          echo &quot;`jq '.base_config[2].value=&quot;29/12/2020&quot;' config.json `&quot; &gt; config.json
     
      - uses: EndBug/add-and-commit@v6
        with:
          message: 'Add the version and date'
          add: '*.json --force'
          cwd: './' 
          token: ${{ secrets.TOKEN }} 
</code></pre>
","14912793",""
"71758159","61919141","2022-04-05 20:41:48","19","<p>Use a <a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings"" rel=""noreferrer"">multi line environment variable</a>:</p>
<pre><code>- run: |
    echo 'PACKAGE_JSON&lt;&lt;EOF' &gt;&gt; $GITHUB_ENV
    cat ./package.json &gt;&gt; $GITHUB_ENV
    echo 'EOF' &gt;&gt; $GITHUB_ENV
- run: |
    echo '${{ fromJson(env.PACKAGE_JSON).version }}'
</code></pre>
<p>This avoids any need for escaping.</p>
","1458343",""
"73478606","61919141","2022-08-24 19:23:08","0","<p>With Powershell:</p>
<pre class=""lang-yaml prettyprint-override""><code>- name: Read json
  id: read-json
  shell: pwsh
  run: |
    $json = Get-Content yourfile.json | ConvertFrom-Json
    echo &quot;::set-output name=prop::$(echo $json.prop)&quot;

- run: echo ${{ steps.read-json.outputs.prop}}
</code></pre>
","2461040",""
"73639034","61919141","2022-09-07 16:43:25","16","<p>Inspired by answer from @dastrobu <a href=""https://stackoverflow.com/questions/57968497/how-do-i-set-an-env-var-with-a-bash-expression-in-github-actions"">which adds key/val to $GITHUB_ENV</a> and using <code>jq</code> to transform/minify package.json to a single line:</p>
<pre class=""lang-yaml prettyprint-override""><code>- run: echo &quot;PACKAGE_JSON=$(jq -c . &lt; package.json)&quot; &gt;&gt; $GITHUB_ENV
- run: echo '${{ fromJson(env.PACKAGE_JSON).version }}'
</code></pre>
","51398",""
"74296413","61919141","2022-11-02 22:49:11","16","<p>You can easily use the <code>Script</code> action for this.</p>
<pre class=""lang-yaml prettyprint-override""><code>  - name: &quot;Read JSON&quot;
    uses: actions/github-script@v6
    id: check-env
    with:
      result-encoding: string
      script: |
        try {
          const fs = require('fs')
          const jsonString = fs.readFileSync('./dir/file.json')
          var apps = JSON.parse(jsonString)
        } catch(err) {
          core.error(&quot;Error while reading or parsing the JSON&quot;)
          core.setFailed(err)
        }
</code></pre>
","2627018",""
"76393558","61919141","2023-06-02 21:27:12","4","<p>TL;DR</p>
<p>This answer may be helpful to you if you</p>
<ol>
<li>have a multi-line JSON file</li>
<li>are using GitHub-Actions on self-hosted servers</li>
<li>need to read the JSON file to decide which self-hosted server you want your jobs to be executed on.</li>
<li>are trying to share contents of a JSON file between multiple jobs.</li>
</ol>
<p>The code snippet is at the end.</p>
<p>--</p>
<p>I had a somewhat complex scenario where we use several self-hosted GitHub runners. I needed to read from a field in a large configuration JSON file to decide which platform I want the rest of the jobs to be run on.</p>
<p>So the below code starts with a job named <code>configure</code>, which reads from a <code>config.json</code> file in the repository and sets it in the output, the next jobs which depend on this can read from the output.</p>
<p>I tried most of the answers in here and in <a href=""https://github.com/orgs/community/discussions/26313"" rel=""nofollow noreferrer"">this post</a> and combined the ones that worked, so thanks to all these people for their comments.</p>
<pre><code>jobs:
  configure:
    runs-on: ubuntu-latest # at first we still don't know which self-hosted server, so we just use ubuntu latest and read the JSON file
    outputs: # here we use the outputs from steps, and set outputs for the job `configure`
      config: ${{ steps.read-json.outputs.config }}
      platform: ${{ steps.get-attribute.outputs.platform }}
    steps:
      - name: Checkout to repository
        uses: actions/checkout@v3  
      - name: Read JSON file # this puts the whole JSON file in the read-json step output
        id: read-json
        run: | # to read multi-line JSON file and not bother with escaping
          echo &quot;config&lt;&lt;EOF&quot; &gt;&gt; $GITHUB_OUTPUT
          cat ./config.json &gt;&gt; $GITHUB_OUTPUT
          echo &quot;EOF&quot; &gt;&gt; $GITHUB_OUTPUT
      
      - name: Add platform in output # for simpler use, you can add a single field in the output as well.
        id: read-attribute
        run: echo &quot;platform=${{fromJson(steps.read-json.outputs.config).platform}}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;

  job2:
    needs: configure
    runs-on: ${{needs.configure.outputs.platform}}

    steps:
      - name: Log JSON file
        run: echo &quot;${{needs.configure.outputs.config}}&quot;
      - name: Log an attribute in JSON file
        run: echo &quot;${{fromJson(needs.configure.outputs.config).attribute}}&quot;
      
</code></pre>
","7025986",""
"78054401","61919141","2024-02-25 00:00:46","1","<p>Approach using Python:</p>
<pre><code>- name: Reads JSON
  run: |
    import json, os
    try:
      with open(&quot;package.json&quot;, &quot;r&quot;) as file:
        data = json.load(file)
        version = data.get(&quot;version&quot;)
      with open(os.getenv('GITHUB_ENV'), &quot;a&quot;) as file_env:
        file_env.write(f&quot;VERSION={version}\n&quot;)
    except FileNotFoundError:
      print(&quot;Error: File not found.&quot;)
  shell: python
- run: echo &quot;$VERSION&quot;
  shell: bash
</code></pre>
","55075",""
"62105229","62087265","2020-05-30 16:12:41","7","<h1>Real final edit</h1>
<p>A year later, I finally got around to making the tutorial: <a href=""https://github.com/Andrew-Chen-Wang/cookiecutter-django-ec2-github"" rel=""nofollow noreferrer"">https://github.com/Andrew-Chen-Wang/cookiecutter-django-ec2-github</a>.</p>
<p>I found a <a href=""https://medium.com/cloudwithmore/blue-green-deployment-for-autoscaling-groups-with-codepipeline-codebuild-and-codedeploy-part-3-7-9d1d1d1824e7"" rel=""nofollow noreferrer"">Medium tutorial</a> that also deserves some light if anyone wants to use Code Pipeline (there's a couple of differences; I store my files on GitHub while the Medium tutorial is on S3. I create a custom VPC that the other author doesn't).</p>
<hr />
<h1>Earlier final edit</h1>
<p>AWS has finally made a neat tutorial for CodeDeploy w/ GitHub repository: <a href=""https://docs.aws.amazon.com/codedeploy/latest/userguide/tutorials-github-prerequisites.html"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/codedeploy/latest/userguide/tutorials-github-prerequisites.html</a> take a look there and enjoy :)</p>
<p>Like the ECS tutorial, we're using Parameter Store to store our secrets. The way AWS previous wanted us to grab secrets was via a script in a bash script: <a href=""https://aws.amazon.com/blogs/mt/use-parameter-store-to-securely-access-secrets-and-config-data-in-aws-codedeploy/"" rel=""nofollow noreferrer"">https://aws.amazon.com/blogs/mt/use-parameter-store-to-securely-access-secrets-and-config-data-in-aws-codedeploy/</a></p>
<p>For example:</p>
<pre><code>password=$(aws ssm get-parameters --region us-east-1 --names MySecureSQLPassword --with-decryption --query Parameters[0].Value)
password=`echo $password | sed -e 's/^&quot;//' -e 's/&quot;$//'`
mysqladmin -u root password $password
</code></pre>
<hr />
<p>New edit (24 December 2020): I think I've nailed it. Below I pointed to <a href=""https://donate-anything.org"" rel=""nofollow noreferrer"">Donate Anything</a> for AWS ECS. I've moved to a self deploying setting. If you take a look at bin/scripts, I'm taking advantage of supervisord and gunicorn (for Python web development). But in context of EC2, you can simply point your AppSpec.yml to those scripts! Hope that helps everyone!</p>
<p>Before I start:</p>
<p>This is not a full answer. Not a complete walkthrough, but a lot of hints and some code that will help you with setting up certain AWS stuff like ALB and your files in your repo for this to work. This answer is more like several clues jumbled together from my sprint run trying to make ECS work last night.</p>
<p>I also don't have enough points to neither comment nor chat soo... here's the best thing I can offer.</p>
<p>Quick links (you should probably just skip these two points, though):</p>
<ol>
<li>Check this out: <a href=""https://docs.aws.amazon.com/codedeploy/latest/userguide/instances-ec2-configure.html"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/codedeploy/latest/userguide/instances-ec2-configure.html</a></li>
<li>I don't have enough points to comment or chat... This won't be a full answer, as well, though, as I'm trying to first finish an ECS deploy from GH before moving on to EC2 from GH. Anyhow...</li>
<li>One last edit: this will sound like a marketing ploy but a correct implementation with GitHub actions and workflow_dispatch is located at <a href=""https://github.com/Donate-Anything/Donate-Anything"" rel=""nofollow noreferrer"">Donate Anything's GitHub repository</a>. You'll find the same ECS work located below in there. Do note that I changed my GitHub action to use Docker Hub since it was free (and to me cheaper if you're going to use ECS since AWS ECR is expensive).</li>
</ol>
<p>Edit: The ECS deployment works now. Will start working on the EC2 deployment soon.</p>
<p>Edit 2: I added Donate Anything repo. Additionally, I'm not sure if direct EC2 deployment, at least for me, is viable since install scripts would kinda be weird. However, I still haven't found the time to get to EC2. Again, if anyone is willing to share their time, please do so and contribute!</p>
<p>I do want to warn everyone that SECURITY GROUPS are very important. That clogged me for a long time, so make sure you get them right. <a href=""https://github.com/Andrew-Chen-Wang/cookiecutter-django-ecs-github"" rel=""nofollow noreferrer"">In the ECS tutorial</a>, I teach you how I do it.</p>
<hr />
<p>Full non-full answer:</p>
<p>I'm working on this issue right now in <a href=""https://github.com/Andrew-Chen-Wang/cookiecutter-django-ec2-gh-action"" rel=""nofollow noreferrer"">this repo</a> and another for ECS <a href=""https://github.com/Andrew-Chen-Wang/cookiecutter-django-ecs-github"" rel=""nofollow noreferrer"">here</a> using GitHub actions. I haven't started too far on the EC2 one, but the basic rundown for testing is this:</p>
<p><strong>CRUCIAL</strong></p>
<ul>
<li><strong>You need to try and deploy from the AWS CLI first. This is because AWS Actions does not have a dedicated action for deploying to EC2 yet.</strong></li>
<li>Write down each of these statements. We're going to need them later for the GitHub action.</li>
</ul>
<p>Some hints when testing this AWS setup:</p>
<ul>
<li>Before using CodeDeploy, you need an EC2 instance, an Application Load Balancer (you'll find it under Elastic Load Balancer), and a target group (which you create DURING the ALB setup). Go to target groups, right click on the group, and register your instance.</li>
<li>To deploy from CodeDeploy, create a new application. Create a new deployment group. I think, for your setup, you should do the in-place deployment type rather than the Blue/Green deployment type.</li>
<li>Finally, testing on the CLI, you should run the code you see here: <a href=""https://docs.aws.amazon.com/codedeploy/latest/userguide/tutorials-wordpress-deploy-application.html#tutorials-wordpress-deploy-application-create-deployment-cli"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/codedeploy/latest/userguide/tutorials-wordpress-deploy-application.html#tutorials-wordpress-deploy-application-create-deployment-cli</a>
<ul>
<li>Do note, you may want to start from here (using S3 as a location to store your latest code. You can delete it afterwards anyways, as I believe DELETE requests don't incur charges): <a href=""https://docs.aws.amazon.com/codedeploy/latest/userguide/tutorials-wordpress-upload-application.html"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/codedeploy/latest/userguide/tutorials-wordpress-upload-application.html</a> I personally don't know if that GitHub OAuth integration works. I tried once before (very amateur though, i.e. no clue what I was doing before) and nothing happened, soo... I'd just stick with that tutorial.</li>
</ul>
</li>
</ul>
<p>How your test rundown will look like:</p>
<ul>
<li>For me, for my ECS repo, I just went a full 10 hours straight trying to configure everything properly step by step like the GitHub action. For you, you should do the same. Imagine you're the code: figure out where you need to start from.</li>
<li>Aha! I should probably figure out CodeDeploy first. Let's right an appspec.yaml file first! The appspec file is how CodeDeploy will work on the hooks for everything. Unfortunately, I'm current going through that problem <a href=""https://stackoverflow.com/questions/62104760/appspec-yaml-for-aws-ecs-using-github-actions"">here</a> but that's because the EC2 and ECS syntax for AppSpec files are different. Luckily, EC2 doesn't have any special areas. Just get your files and hooks right. An example from my test:</li>
</ul>
<pre><code>version: 0.0
os: linux

files:
  - source: /
    destination: /code

hooks:
  BeforeInstall:
    - location: aws_scripts/install_dependencies
      timeout: 300
      runas: root
  ApplicationStop:
    - location: aws_scripts/start_server
      runas: root
</code></pre>
<p>The GitHub action:</p>
<p>What you'll need at minimum:</p>
<pre><code>jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        # TODO Change your AWS region here!
        aws-region: us-east-2
</code></pre>
<p>The checking out of code is necessary to... well... get the code.</p>
<p>For the configuration of AWS credentials, you'll want to add <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> to your GitHub secrets with a proper IAM credential. For this, I believe the only IAM role needed is for full CodeDeploy stuff.</p>
<p>Deploying the code:</p>
<p>This is when that test code that you should've tried before reaching this step is for. Now that your workflow is setup, let's paste the code from the CLI into your action.</p>
<pre><code>
    - name: Deploying with CodeDeploy
      id: a-task
      env:
        an-environment-variable: anything you want
      run: |
        echo &quot;Your CLI code should be placed here&quot;
</code></pre>
<p>Sorry if this was confusing, not what you're looking for, or wanted a complete tutorial. I, too, haven't actually gotten this to work, but it's also been awhile since I last tried, and the last time I tried, I didn't even know what an EC2 instance was... I just did a standalone EC2 instance and used rsync to transfer my files. Hopefully what I've written was several clues that can guide you very easily to a solution.</p>
<p>If you got it to work, please share it on here: <a href=""https://github.com/Andrew-Chen-Wang/cookiecutter-django-ec2-gh-action"" rel=""nofollow noreferrer"">https://github.com/Andrew-Chen-Wang/cookiecutter-django-ec2-gh-action</a> so that no one else has to suffer the pain of AWS deployment...</p>
","12875823",""
"66661512","62087265","2021-03-16 18:45:14","36","<blockquote>
<p>Is there a way to deploy code to AWS EC2 without using Elastic Beanstalk?</p>
</blockquote>
<p>I found a simple way to deploy to EC2 instance (or to any server that accepts <code>rsync</code> commands over <code>ssh</code>) using <a href=""https://github.com/features/actions"" rel=""noreferrer"">GitHub Actions</a>.</p>
<p>I have a simple file in the repo's <em>.github/workflows</em> folder, which <strong>GitHub Actions</strong> runs to deploy to my EC2 instance whenever a push is made to my GitHub repo.</p>
<p>No muss, no fuss, no special incantations or Byzantine AWS configuration details.</p>
<p>File <em>.github/workflows/pushtoec2.yml</em>:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: Push-to-EC2

on: push

jobs:
  deploy:
    name: Push to EC2 Instance
    runs-on: ubuntu-latest

    steps:
      - name: Checkout the code
        uses: actions/checkout@v1

      - name: Deploy to my EC2 instance
        uses: easingthemes/ssh-deploy@v2.1.5
        env:
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
          SOURCE: &quot;./&quot;
          REMOTE_HOST: &quot;ec2-34-213-48-149.us-west-2.compute.amazonaws.com&quot;
          REMOTE_USER: &quot;ec2-user&quot;
          TARGET: &quot;/home/ec2-user/SampleExpressApp&quot;

</code></pre>
<p>Details of the <a href=""https://github.com/marketplace/actions/ssh-deploy"" rel=""noreferrer"">ssh deploy</a> GitHub Action, used above.</p>
","3113485",""
"66684511","62087265","2021-03-18 03:50:51","6","<p>First, you need to go through this tutorial on AWS to set up your EC2 server, as well as configure the Application and Deployment Group in CodeDeploy: <a href=""https://docs.aws.amazon.com/codedeploy/latest/userguide/tutorials-github.html"" rel=""nofollow noreferrer"">Tutorial: Use CodeDeploy to deploy an application from GitHub</a></p>
<p>Then, you can use the following workflow in GitHub Actions to deploy your code on push. You essentially use the AWS CLI to create a new deployment. Store the AWS credentials for the CLI in GitHub Secrets.</p>
<p>Here is an example for deploying a Node app:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: Deploy to AWS

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    name: Deploy AWS
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [12.x]
        app-name: ['your-codedeploy-application']
        deployment-group: ['your-codedeploy-deploy-group']
        repo: ['username/repository-name']
        
    steps:
      - uses: actions/checkout@v2
      
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
          
      - name: Install dependencies
        run: npm install
      
      - name: Build app
        run: npm run build

      - name: Install AWS CLI 
        run: |
          curl &quot;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip&quot; -o &quot;awscliv2.zip&quot;
          unzip awscliv2.zip
          sudo ./aws/install --update
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1
          
      - name: Deploy to AWS
        run: |
          aws deploy create-deployment \
          --application-name ${{ matrix.app-name }} \
          --deployment-config-name CodeDeployDefault.OneAtATime \
          --deployment-group-name ${{ matrix.deployment-group }} \
          --description &quot;GitHub Deployment for the ${{ matrix.app-name }}-${{ github.sha }}&quot; \
          --github-location repository=${{ matrix.repo }},commitId=${{ github.sha }}
</code></pre>
","6758964",""
"62665586","62547923","2020-06-30 20:22:30","0","<p>Depending on how R is set up, this post might be helpful for you. You might need to configure the .Renviron file.</p>
<p><a href=""https://stackoverflow.com/questions/50145643/unable-to-change-python-path-in-reticulate-r/60048094#60048094"">Unable to change python path in reticulate (R)</a></p>
","4950753",""
"62784946","62784756","2020-07-07 22:39:38","3","<p><code>macOS</code> is what you looking for:</p>
<pre><code>- name: doing something on macOS
  if: runner.os == 'macOS'
</code></pre>
<p>You can refer the different <code>os</code> type in <a href=""https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#runner-context"" rel=""nofollow noreferrer""><code>runner</code> context doc</a>.</p>
","791609",""
"63648621","62908594","2020-08-29 15:22:07","3","<p>Try the --name option</p>
<pre><code>options: &gt;-
  --health-cmd pg_isready
  --health-interval 10s
  --health-timeout 5s
  --health-retries 5
  --name postgres 
</code></pre>
<p><a href=""https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idservices"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idservices</a></p>
<p>jobs.&lt;job_id&gt;.services.options: Additional Docker container resource options. For a list of options, see &quot;docker create options.&quot;</p>
<p>Another solution I've seen is using last created container</p>
<pre><code>docker exec -it $(docker ps --latest --quiet) bash
</code></pre>
","449683",""
"63027615","63012327","2020-07-22 05:38:40","1","<p>First, add a <code>chmod 600 ~/.ssh/known_hosts</code> as well in your entrypoint.</p>
<p>For testing, I would check if <a href=""https://man.openbsd.org/ssh-keyscan.1"" rel=""nofollow noreferrer"">options around ssh-keyscan</a> make any difference:</p>
<pre><code>ssh-keyscan -H &lt;IP&gt;
# or
ssh-keyscan -t rsa -H &lt;IP&gt;
</code></pre>
<p>Check that your key is generated using the default rsa public-key cryptosystems.<br />
The <a href=""https://superuser.com/a/1142569/141""><code>HostKeyAlgorithms</code> used might be set differently</a>, in which case:</p>
<pre><code>ssh-keyscan -H -t ecdsa-sha2-nistp256 &lt;IP&gt;
</code></pre>
","6309",""
"63030126","63012327","2020-07-22 08:37:01","12","<p>So after hours of searching I found out what the issue was.
When force accepting all host keys with the <code>-o &quot;StrictHostKeyChecking no&quot;</code> option no <code>~/.ssh/known_hosts</code> file is created. Meaning that the openssh-client I installed in the container does not seem to read from that file.
So telling the ssh command where to look for the file solved the issue:</p>
<p><code>ssh -i ~/.ssh/private.key -o UserKnownHostsFile=/github/home/.ssh/known_hosts -tt &lt;USER&gt;@&lt;IP&gt; &quot;echo test &gt; testfile1&quot;</code></p>
<p>Apparently one can also change the location of the <code>known_hosts</code> file within the <code>ssh_config</code> permanently (see <a href=""https://stackoverflow.com/questions/10765946/ssh-use-known-hosts-other-than-home-ssh-known-hosts"">here</a>).</p>
<p>Hope this helps someone at some point.</p>
","7038838",""
"76465877","63012327","2023-06-13 14:15:34","9","<p>For the GitHub runner in 2023, the <code>.ssh</code> dir doesn't exist, so you have to create it and <code>known_hosts</code> first:</p>
<pre><code>mkdir -p ~/.ssh/ &amp;&amp; touch ~/.ssh/known_hosts
</code></pre>
<p>Then add the public SSH host key:</p>
<pre><code>ssh-keyscan [hostname] &gt;&gt; ~/.ssh/known_hosts
</code></pre>
<p>And the private key:</p>
<pre><code>eval $(ssh-agent)
ssh-add - &lt;&lt;&lt; &quot;${{ secrets.SSH_PRIVATE_KEY }}&quot;
</code></pre>
","1372202",""
"63229609","63226588","2020-08-03 12:39:36","1","<p>While <a href=""https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem"" rel=""nofollow noreferrer""><code>Get-ChildItem</code></a> does have an <code>-Exclude</code> parameter, it only operates on the <em>file-name</em> part, not on the full path.</p>
<p>Therefore, you must perform the exclusion filtering after the fact, using the negated form of <code>-like</code>, the <a href=""https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Comparison_Operators#-like"" rel=""nofollow noreferrer"">wildcard matching operator</a></p>
<pre><code>pylint ((Get-ChildItem -Recurse -Name -Filter *.py) -notlike 'exclude_dir/*')
</code></pre>
<p><sup>Note the use of <code>-Filter</code> rather than <code>-Include</code>, which speeds up the operation, because filtering happens at the source rather than being applied by PowerShell after the fact.</sup></p>
<p>However, given that you're seemingly only excluding a <em>single top-level</em> folder, you could try:</p>
<pre><code>pylint (Get-ChildItem -Recurse -Path * -Filter *.py -Exclude exclude_dir)
</code></pre>
<p>Note that I've omitted <code>-Name</code> in this case, because it wouldn't work properly in this scenario. As a result, the matching files are implicitly passed as full paths to <code>pylint</code>.</p>
<p>As of PowerShell 7.0, <code>-Name</code> exhibits several problematic behaviors, which are summarized in <a href=""https://stackoverflow.com/a/60040617/45375"">this answer</a>.</p>
","45375",""
"63293712","63288356","2020-08-07 00:51:56","7","<p>I don't think you can use <code>workflow_dispatch</code> to add/update checks on a PR. This seems to be confirmed by <a href=""https://github.community/t/workflow-dispatch-does-not-update-commit-status/125981/2"" rel=""noreferrer"">this response</a> to a similar question on the community forums.</p>
<p>Checks are only added/updated for the following events:</p>
<ul>
<li>pull_request</li>
<li>pull_request_review</li>
<li>pull_request_review_comment</li>
<li>pull_request_target</li>
<li>push</li>
</ul>
<p>So your manual operation needs to trigger one of these events to run. There are probably a number of different ways you can do this, depending on your use case. Just as an example, you could call the API to add a label and allow a <code>pull_request</code> workflow to execute on that type.</p>
<pre><code>on:
  pull_request:
    types: [labeled, opened, synchronize, reopened]
</code></pre>
<p>The other thing to note is that the API call (or git push) must use a PAT instead of <code>GITHUB_TOKEN</code>. This is to <a href=""https://docs.github.com/en/actions/reference/events-that-trigger-workflows#triggering-new-workflows-using-a-personal-access-token"" rel=""noreferrer"">allow further workflows</a> to execute.</p>
","11934042",""
"75510242","63288356","2023-02-20 14:04:56","3","<p>It is possible with some workaround. First, you have to identify the PR that invoked your workflow. If you need to use the <code>workflow_dispatch</code> trigger event, you can pass this PR number as input parameter. Otherwise, you mentioned you trigger this workflow on a specific comment so you could also use the <code>issue_comment</code> event which will give you the PR number as <code>github.event.issue.pull_request</code>.</p>
<p>Next, you have to find out the latest commit of this Pull Request. This depends on how your workflow got invoked:</p>
<ul>
<li>if you use the <code>issue_comment</code> event, you can use the <a href=""https://github.com/xt0rted/pull-request-comment-branch"" rel=""nofollow noreferrer"">xt0rted/pull-request-comment-branch</a> action to determine the right branch and commit</li>
<li>if you use the <code>workflow_dispatch</code> event, you can use the <a href=""https://github.com/actions/github-script"" rel=""nofollow noreferrer"">actions/github-script</a> action to run some query to get the right commit for a given PR number</li>
</ul>
<p>Finally, you can use the <a href=""https://github.com/myrotvorets/set-commit-status-action"" rel=""nofollow noreferrer"">myrotvorets/set-commit-status-action</a> action to attach the workflow result as check on the latest commit of the PR.</p>
<p>I wrote a blog post that describes this process in some more details: <a href=""https://dev.to/zirkelc/trigger-github-workflow-for-comment-on-pull-request-45l2"" rel=""nofollow noreferrer"">Trigger GitHub Workflow for Comments on Pull Request</a></p>
","1967693",""
"63681598","63672189","2020-09-01 04:55:32","3","<p>This is tricky because actions/cache depends on you putting the libraries in a specific folder that then can be cached and retrieved. And system files have a lot of dependencies which makes each library unique when it comes to this process.</p>
<p>Here are three options that you can take to accomplish this</p>
<p><strong>Path 1:</strong></p>
<p>We could look into installing the brew packages into a specific folder but we cannot do that per package but instead for the whole OS. But according to homebrew <a href=""https://github.com/Homebrew/brew/blob/664d0c67d5947605c914c4c56ebcfaa80cb6eca0/docs/Installation.md#untar-anywhere"" rel=""nofollow noreferrer"">https://github.com/Homebrew/brew/blob/664d0c67d5947605c914c4c56ebcfaa80cb6eca0/docs/Installation.md#untar-anywhere</a> it's not a good idea as there could be issues with packages not installing properly. Also this would basically be caching everything which at the end of the day we don't know if it'll be faster than just installing the latest packages you need.</p>
<p><strong>Path 2:</strong></p>
<p>Install the package as you normally would with brew and then copy binaries. The caveat here is that you will need to do this on a per library basis as dependencies some times can get out of hand.
Here is an example <a href=""https://stackoverflow.com/questions/59269850/caching-apt-packages-in-github-actions-workflow"">Caching APT packages in GitHub Actions workflow</a>
by going through this process with apt-get in linux, but you can follow same process with brew</p>
<p><strong>Path 3:</strong></p>
<p>Find or create your own docker file image that for which you keep up to date with the latest packages that you want. This would allow you to always have the latest and this will allow you to initialize your steps inside a container build from your docker image. This will then satisfy your system dependencies.</p>
<pre><code> jobs:
   ci:
     runs-on: ubuntu-latest
     container:
       image: &lt;your-personalized-docker-image&gt;
</code></pre>
","14167216",""
"65056232","63672189","2020-11-29 01:48:21","4","<p>In your workflow job configuration:</p>
<pre class=""lang-yaml prettyprint-override""><code>    steps:
    - name: Update Homebrew
      run: |
        brew update --preinstall
        cat &quot;$(brew --repository)/Library/Taps/homebrew/homebrew-core/Formula/foo.rb&quot; &gt; .github/brew-formulae
    - name: Configure Homebrew cache
      uses: actions/cache@v2
      with:
        path: |
          ~/Library/Caches/Homebrew/foo--*
          ~/Library/Caches/Homebrew/downloads/*--foo-*
        key: brew-${{ hashFiles('.github/brew-formulae') }}
        restore-keys: brew-
    - name: Install Homebrew dependencies
      run: |
        env HOMEBREW_NO_AUTO_UPDATE=1 brew install foo
</code></pre>
<p>Here <code>~/Library/Caches/Homebrew</code> corresponds to the output of <code>brew --cache</code>.</p>
<p>Rather than store the entire directory to the GitHub Actions cache, the above configuration will only store the files related to the &quot;foo&quot; package.  This is because the Homebrew cache directory on the macOS images provided by GitHub already contains files for the base Homebrew install (which you don't need to store again).</p>
<p>You should note that this cache is unlikely to speed up your workflow.  Installing Homebrew bottles (the default) will usually have similar performance to downloading from GitHub/Azure's own storage cache since the bottle files are served on bintray's CDN.</p>
","135385",""
"63678192","63676119","2020-08-31 21:06:40","4","<p>Your service doesn't have access to the local file. Make sure to create a volume and then you will be able to run your command. The below solution assumes file setup.cql exists at the root of your repo directory</p>
<p><strong>Repo Structure Assumption</strong></p>
<pre><code>repo/
  .github/workflows/your-worflow.yaml
  setup.cql
  ... any other files/dirs
</code></pre>
<p><strong>Workflow Update</strong></p>
<pre><code>services:
  cassandra:
    image: cassandra
    ports:
      - 9042:9042
    options: --health-cmd &quot;cqlsh --debug&quot; --health-interval 5s --health-retries 10
    volumes: 
       - ${{ github.workspace }}:/workspace
steps:
  - uses: actions/checkout@v2
  - run: docker exec -i ${{ job.services.cassandra.id }} cqlsh -f /workspace/setup.cql
</code></pre>
","14167216",""
"63692013","63691962","2020-09-01 16:44:18","0","<p>U need to host an external redis database because containers in GitHub Actions are isolated.
For other hand u can prepare a docker container with all you need for testing and then u can run the tests inside.</p>
<p>Un can take a look here <a href=""https://github.com/gonsandia/github-action-deploy"" rel=""nofollow noreferrer"">https://github.com/gonsandia/github-action-deploy</a>
Its a custom action where u define the dockerfile and the scripts to runs</p>
","6140038",""
"63694268","63691962","2020-09-01 19:32:54","2","<p>So I figured out what was the problem.
Docker network works only if you run your job inside container. And I had not.</p>
<p>Here is example <a href=""https://github.com/actions/example-services/blob/989ef69ed164330bee413f11ce9332d76f943af7/.github/workflows/mongodb-service.yml#L19"" rel=""nofollow noreferrer"">https://github.com/actions/example-services/blob/989ef69ed164330bee413f11ce9332d76f943af7/.github/workflows/mongodb-service.yml#L19</a></p>
<p>And a quote:</p>
<blockquote>
<p>runs all of the steps inside the specified container rather than on the VM host.
Because of this the network configuration changes from host based network to a container network.</p>
</blockquote>
","3110970",""
"63817068","63803136","2020-09-09 17:56:36","62","<p>To get event data, you can use a GitHub action to print the event to the log.</p>
<pre><code># change this to the event type you want to get the data for
on:
  pull_request:
    types: [opened, closed, reopened]

jobs:
  printJob:    
    name: Print event
    runs-on: ubuntu-latest
    steps:
    - name: Dump GitHub context
      env:
        GITHUB_CONTEXT: ${{ toJson(github) }}
      run: |
        echo &quot;$GITHUB_CONTEXT&quot;
</code></pre>
<p>Alternatively, you can find example event data in the documentation:
<a href=""https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#webhook-payload-example-30"" rel=""noreferrer"">https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#webhook-payload-example-30</a></p>
","3241243",""
"63955997","63952543","2020-09-18 12:41:25","3","<p>ok finally found solution</p>
<p>first we need to set variable:</p>
<pre><code>- name: Extract Branch Name
      shell: bash
      run: |
        branchName=${GITHUB_REF#refs/heads/}
        if [ $branchName = 'develop' ]; then additionalImageName='-develop'; else additionalImageName=''; fi
        echo &quot;::set-output name=additionalImageName::$(echo $additionalImageName)&quot;
      id: extract_branch
</code></pre>
<p>and then in creating docker container step:</p>
<pre><code>- name: docker
      uses: VaultVulp/gp-docker-action@1.1.6
      with:
        image-name: test-service${{ steps.extract_branch.outputs.additionalImageName }}
</code></pre>
<p>looks like only way to use some variable in image-name is by using steps.
Anyway it works well.</p>
","3244618",""
"64272409","64272276","2020-10-09 00:33:54","1","<p>When you clone a repository with GitHub Actions, by default it clones it in a particular way:</p>
<ul>
<li>First, it uses the <code>--depth=1</code> option to make a shallow clone.</li>
<li>Second, it clones only the single ref that you're using.</li>
</ul>
<p>Both of these result in a much smaller amount of data being cloned which makes runs potentially much faster.  However, in your case, this has a few problems that prevent it from working the way you want it:</p>
<ul>
<li>First, you cannot push from this shallow clone to a new repository because your Actions repository may lack objects needed for the push (resulting in “shallow update not allowed&quot;).</li>
<li>Second, you haven't cloned any branch but the single one you're testing, so you're implicitly trying to delete every other branch.  However, you're not allowed to delete the default branch (in this case, <code>master</code>), so you get the error “refusing to delete the current branch”.</li>
</ul>
<p>What you want to do is fetch all history for all branches and tags, so you should pass an appropriate option:</p>
<pre><code>- uses: actions/checkout@v2
  with:
    fetch-depth: 0
</code></pre>
<p>That will result in a full clone at the expense of increased time, but it will allow you to push your repository elsewhere.</p>
","8705432",""
"65744334","64930068","2021-01-15 22:25:13","1","<p>There is a new Travis feature (in beta) that allows you to share files from one job with subsequent jobs in a build: <a href=""https://docs.travis-ci.com/user/using-workspaces/"" rel=""nofollow noreferrer"">workspaces</a></p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  include:
    - stage: warm_cache
      script:
        - echo &quot;foo&quot; &gt; foo.txt
      workspaces:
        create:
          name: ws1
          paths:
            - foo.txt
    - stage: use_cache
      workspaces:
        use: ws1
      script:
        - cat foo.txt || true
</code></pre>
<p>Also, SBT 1.4 allows you to push build artefacts to a Maven server and fetch then again later: <a href=""https://www.scala-sbt.org/1.x/docs/Remote-Caching.html"" rel=""nofollow noreferrer"">https://www.scala-sbt.org/1.x/docs/Remote-Caching.html</a></p>
","4432837",""
"72918267","65345432","2022-07-09 01:12:48","1","<p>Today I was able to do this with the following YAML (truncated):</p>
<pre class=""lang-yaml prettyprint-override""><code>...
with:
  targets: |
    FolderA/SubfolderA
    FolderB/SubfolderB
</code></pre>
<p>The actual GitHub Action passes this as an argument like the following:</p>
<pre class=""lang-yaml prettyprint-override""><code>runs:
  using: docker
  image: Dockerfile
  args:
    - &quot;${{ inputs.targets }}&quot;
</code></pre>
<p>What this does is simply sends the parameters as a string with the newline characters embedded, which can then be iterated over similar to an array in a POSIX-compliant manner via the following shell code:</p>
<pre class=""lang-bash prettyprint-override""><code>#!/bin/sh -l

targets=&quot;${1}&quot;

for target in $targets
do
  echo &quot;Proof that this code works: $target&quot;
done
</code></pre>
<p>Which should be capable of accomplishing your desired task, if I understand the question correctly. You can always run something like <code>sh ./script.sh $target</code> in the loop if your use case requires it.</p>
","6456163",""
"65472861","65353108","2020-12-28 03:59:24","0","<p>Yes, this technically possible. GitHub Actions has the <code>on.schedule</code> <a href=""https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#onschedule"" rel=""nofollow noreferrer"">event</a> which allows you to essentially set up a cron schedule for execution of your workflow. Your cron schedule for running the workflow every 5 hours would be something like <code>0 0/5 * * *</code> (see <a href=""https://crontab.guru/#0_0/5_*_*_*"" rel=""nofollow noreferrer"">here</a>).</p>
<p>If you just want to open the webpage for 3 minutes, your workflow run step could use the <code>&amp;&amp;</code> chaining the URL-opening command (<code>xdg-open www.example.com</code> can be used to open a URL) with a <code>sleep 360</code>. I leave the actual composition of the workflow file as an exercise to the reader 🙂.</p>
","6310633",""
"65357936","65357083","2020-12-18 13:31:15","0","<p>Looks like adding is the second the step:</p>
<pre><code>    - name: Setting Ghostscript paths (Windows)
      shell: bash
      run: |
        echo &quot;C:/Program Files (x86)/gs/gs9.53.3/bin/&quot; &gt;&gt; $GITHUB_PATH
        echo &quot;C:/Program Files/gs/gs9.53.3/bin/&quot; &gt;&gt; $GITHUB_PATH
        export PATH=&quot;/c/Program Files (x86)/gs/gs9.53.3/bin/:$PATH&quot;
        export PATH=&quot;/c/Program Files/gs/gs9.53.3/bin/:$PATH&quot;
      if: matrix.config.os == 'windows-latest'
</code></pre>
<p>makes gswin64c available.</p>
","1657886",""
"65821159","65820392","2021-01-21 04:21:14","2","<p>Based on the comments.</p>
<p>The solution was that the env variable set were incorrect. The correct ones are <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_DEFAULT_REGION</code> as shown in the <a href=""https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html"" rel=""nofollow noreferrer"">docs</a>.</p>
","248823",""
"65828909","65828544","2021-01-21 13:52:51","4","<p>Judging by everything <a href=""https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix"" rel=""nofollow noreferrer"">the matrix documentation</a> has to say, it seems that as soon as you define a matrix strategy, you get a number of jobs equal to the number of elements in your matrix (even if you don't use the value at all).</p>
<p>This little workflow demonstrates it:</p>
<pre><code>name: Test
on:
  push: { branches: master }

jobs:
  test:
    name: Matrix test
    runs-on: ubuntu-latest
    strategy:
      matrix: { ruby: ['2.4', '2.5'] }

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    # - name: Do something with the matrix value
    #   run: echo Doing it with ${{ matrix.ruby }}
</code></pre>
<p>Output:</p>
<p><a href=""https://i.sstatic.net/U550u.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/U550u.png"" alt=""enter image description here"" /></a></p>
<p>If you want to run consecutive (and not parallel) operations, especially if one step relies on the output of the previous step, it sounds like your best option is to have your build logic tucked away in a shell script, and have a job that runs it.</p>
<p>Since your use case is not described in the question, I would like to propose another approach which I am using for many of my production workflows, and might be suitable for your needs.</p>
<p>I also need to have sort of &quot;loops&quot; in some of my workflows (for example, for deploying multiple docker containers based on the same built image). For this, I am using a templating engine to create a YAML file that has loops in it, and I then generate the final YAML, which is standard and valid, and contains the same steps over and over again.</p>
<p>The tool I am using to do this is open source (full disclosure, I also built it) and is called <a href=""https://github.com/DannyBen/kojo"" rel=""nofollow noreferrer"">Kojo</a>, and was designed specifically for this purpose of configuration templating - but you can do it with any templating engine of your choice.</p>
","413924",""
"78484640","65828544","2024-05-15 14:28:56","0","<p>You have to add <code>max-parallel: 1</code> under <code>strategy</code>.</p>
<p>Source: <a href=""https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs#defining-the-maximum-number-of-concurrent-jobs"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs#defining-the-maximum-number-of-concurrent-jobs</a></p>
","1763602",""
"70453429","65893608","2021-12-22 18:12:06","18","<p>I just tested a <a href=""https://github.com/GuillaumeFalourd/poc-github-actions/blob/main/.github/workflows/workflow-tester19.yml"" rel=""noreferrer"">simple workflow here</a> (same as below) to use the virtual env.</p>
<p>It doesn't seem you need the <code>sudo apt install python3-env</code> command when using the <code>actions/checkout</code> and the <code>setup-python</code> actions to create the virtual env using the <code>python3.8 -m venv env</code> command.</p>
<pre class=""lang-yaml prettyprint-override""><code>on:
  push:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python 3.8
        uses: actions/setup-python@v2
        with:
          python-version: 3.8
      - name: Run Python commands
        run: |
          pip install --upgrade pip
          python3.8 -m venv env
          source env/bin/activate
          echo &quot;VIRTUAL ENV:&quot; $VIRTUAL_ENV
</code></pre>
<p>Returned me <code>VIRTUAL ENV: /home/runner/work/poc-github-actions/poc-github-actions/env</code> on the <a href=""https://github.com/GuillaumeFalourd/poc-github-actions/runs/4610138792?check_suite_focus=true"" rel=""noreferrer"">workflow run logs</a>.</p>
","8496462",""
"65925526","65925430","2021-01-27 18:49:59","1","<p>Try adding this to your DockerFile:</p>
<pre><code>RUN apt-get update &amp;&amp; apt-get install python
</code></pre>
","7890795",""
"66347175","66335124","2021-02-24 08:30:11","0","<p>OK, I found this one out myself. Apparently there's an action you can use that will download the publish profile for you. This means that you don't have to have the publish profile up front. The step looks like this:</p>
<pre><code>- name: Get WebApp/FunctionApp publish profile
  id: webapp-dev
  uses: aliencube/publish-profile-actions@v1
  env:
    AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
  with:
    resourceGroupName: 'your-resource-group-name'
    appName: 'your-app-name'
</code></pre>
<p>This leaves you with an output variable called `profile' which can be used in following steps like so:</p>
<pre><code>- name: 'Run Azure webapp deploy action using publish profile credentials'
  uses: azure/webapps-deploy@v1
  with: 
    app-name: 'your-app-name'
    publish-profile: ${{ steps.webapp-dev.outputs.profile }}
    package: './'
</code></pre>
<p>This means you can now provision resources using ARM templates, get the publish profile (just-in-time) and use that to deploy your system... Everybody happy...</p>
","1211879",""
"66358721","66358482","2021-02-24 20:56:23","1","<p>When you pass a image to a job, it will execute the <code>steps</code> defined in your job inside this container. Your container image only provides the environment in which your steps will be executed. You lose control of the entrypoint and arguments.</p>
<p>If you only want to run your container as a single step you could do something like this instead:</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  my-job:
    runs-on: ubuntu-latest
    steps:
      - uses: docker://myimage:latest
</code></pre>
<p>or if you want to overwrite it:</p>
<pre class=""lang-yaml prettyprint-override""><code>    steps:
      - uses: docker://myimage:latest
        with:
          entrypoint: /run.sh
          args: --help
</code></pre>
","3719845",""
"66485882","66358482","2021-03-05 02:26:57","1","<p>I've settled along the lines below. Not ideal/DRY, as the <code>run.sh</code> entrypoint script has to be duplicated from the Docker container and kept up to date. Also, the <a href=""https://github.com/actions/upload-artifact"" rel=""nofollow noreferrer"">upload-artifact</a> GitHub Actions does not preserve executable bits, so have to zip everything in a tar file.</p>
<pre><code>jobs:
  build:
    container:
      image: XX/compiler:${{ matrix.DOCKER_TAG }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: ./.github/scripts/run.sh ./.github/scripts/build.sh
      - uses: actions/upload-artifact@v2
        with:
          name: build-artifact
          path: 'build-*.tar.bz2'
          retention-days: 7
    strategy:
      fail-fast: false
      matrix:
        DOCKER_TAG: [gcc, nvhpc, intel]
        include:
          - DOCKER_TAG: gcc
            FC: gfortran
          - DOCKER_TAG: nvhpc
            FC: nvfortran
          - DOCKER_TAG: intel
            FC: ifort
</code></pre>
","661775",""
"66478679","66438446","2021-03-04 16:02:21","0","<p>So, I managed to solve the issue myself. The <code>checkout@v2</code> action does only allow relative paths, however, we can just clone the dependency manually.</p>
<pre><code>- name: Checkout dependencies
  run: |
      git clone https://${{ secrets.GIT_ACCESS_TOKEN }}@github.com/myorg/dependency.git ${GOROOT}/src/dependency
</code></pre>
<p>In this way, it will also work with different Go versions yielding in a different GOROOT.</p>
<p>The full pipeline steps:</p>
<pre><code>steps:
## sets up go based on the version
- name: Install Go
  uses: actions/setup-go@v2
  with:
    go-version: ${{ matrix.go-version }}
  env:
    GO111MODULE: &quot;on&quot;
- name: Checkout dependencies
  run: |
    git clone https://${{ secrets.GIT_ACCESS_TOKEN }}@github.com/myorg/dependency.git 

## checks out our code locally so we can work with the files
- name: Checkout code
  uses: actions/checkout@v2

## runs a build
- name: Build
  run: go build src

## runs go test ./...
- name: Test
  run: go test ./...
</code></pre>
","5679455",""
"66880199","66877085","2021-03-31 00:49:29","1","<p>thanks to @GuiFalourd and @riQQ , I was able to put together proof-of-concept set of repositories</p>
<ul>
<li><a href=""https://github.com/smallstepman/github-actions-submodule-test-parent"" rel=""nofollow noreferrer"">https://github.com/smallstepman/github-actions-submodule-test-parent</a></li>
<li><a href=""https://github.com/smallstepman/github-actions-submodule-test-child"" rel=""nofollow noreferrer"">https://github.com/smallstepman/github-actions-submodule-test-child</a></li>
</ul>
<p>Both repo share same <a href=""https://github.com/settings/tokens"" rel=""nofollow noreferrer"">GitHub Personal Access Token</a>. To fill the blanks from the blog.marcnuri.com guide, here is minimal set of permissions required to make this work (given both repositories are public, otherwise you need <code>repo</code> permission:
<a href=""https://i.sstatic.net/moHrt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/moHrt.png"" alt=""enter image description here"" /></a></p>
","7432829",""
"66922092","66918575","2021-04-02 16:09:15","33","<p>When you want to execute files from the current repository, you need to use the <a href=""https://github.com/actions/checkout"" rel=""noreferrer"">actions/checkout</a></p>
<p>This will allow you to access the repository <code>$github_workspace</code> (one of <a href=""https://docs.github.com/en/actions/reference/environment-variables"" rel=""noreferrer"">Github environment variables</a>) in your workflow.</p>
<p>For example, considering that your <code>Makefile</code> file is at the root of the repository, you would use something like this:</p>
<pre><code>   name: python-app

   on:
     push:
       branches: [ master ]
     pull_request:
       branches: [ master ]

   jobs:
    build:
      runs-on: ubuntu-latest
      steps:
      - name: checkout repo
        uses: actions/checkout@main
      - name: build application
        run: make build
</code></pre>
<p><a href=""https://github.com/GuillaumeFalourd/poc-github-actions/blob/main/.github/workflows/03-python-script-workflow.yml"" rel=""noreferrer"">Here</a> is another workflow example from a personal repository, following the same logic if you want to execute a specific script to perform any operation.</p>
","8496462",""
"71418457","70130613","2022-03-10 03:22:05","-1","<p>I've tested the option that you've mentioned but unfortunately it is not working.
Planning to get support from GitHub to try and figure out if it's possible. (Have a corporate account)</p>
","7269736",""
"70233168","70230123","2021-12-05 09:56:00","1","<p>This can be done using protected environments' required reviewers: <a href=""https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#required-reviewers"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#required-reviewers</a></p>
<p>What you would do is setup an environment e.g. <code>production</code> and add yourself as reviewer.</p>
<p>In your workflow, you would then add the environments like so:</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  plan:
    steps:
      - run: terraform plan
  apply:
    environment: production
    steps:
      - run: terraform apply
</code></pre>
<p>This means that as soon as the workflow reaches the job <code>apply</code>, it is going to stop and you'll need to manually click a button to approve.</p>
","1080523",""
"70309957","70230123","2021-12-10 20:18:07","1","<p>My solution ended up being the following:</p>
<p>When the PR is approved and merged, a Terraform plan is created and pushed to an S3 bucket with the commit hash in the path. Then when the apply workflow is triggered via workflow dispatch it looks for a plan for the commit hash of the code it's running and applies it.</p>
<p>Using pull requests as suggested wasn't the right solution for me because of the following:</p>
<ol>
<li><p>How do you know that the plan that was run for the pull request was run with the latest changes on the base branch? The plan could be invalid in this case. The way I solved this was by having the plan workflow run on push of a specific branch that corresponds to the environment being Terraformed. This way the plan is always generated for the state the Terraform says the specific environment should be in.</p>
</li>
<li><p>How do you know that an apply is applying the exact plan that was generated for the pull request? All the examples I saw actually ended up re-running the plan in the apply workflow, which breaks the intended use of Terraform plans. The way I solved this was by having the apply workflow look for a specific commit hash in cloud storage.</p>
</li>
</ol>
","2378567",""
"70278426","70278241","2021-12-08 16:28:06","0","<p>An infinite loop will happen if there is a push to master branch. And build part will be run.</p>
<p>In build part it will push again to master so an infinite loop happenning.</p>
<p>Remove this part from build stage:</p>
<pre><code>- name: commit changed files
  run: git commit -m &quot;Auto adding config files&quot;
- name: fetch from master
  run: git fetch origin master
- name: push code to master
  run: git push origin HEAD:master
</code></pre>
","4144042",""
"74970055","70278241","2022-12-31 14:08:47","0","<p>You may find this comment helpful on how the GITHUB_TOKEN generated during workflows is created to avoid loops: <a href=""https://github.com/orgs/community/discussions/26970"" rel=""nofollow noreferrer"">https://github.com/orgs/community/discussions/26970</a></p>
<p>Based off your code and that comment, if you're using the autogenerated token, then you shouldn't have an issue with loops. I've tested this successfully in our own workflow that has a similar pattern.</p>
","9153824",""
"70333581","70332762","2021-12-13 11:02:09","2","<p>Currently, it seems as though deleting <code>node_modules/</code> <s>as well as <code>package-lock.json</code></s> and regenerating them with <code>npm install</code> remedies this issue.</p>
<pre><code>&lt;in root&gt;
rm -rf node_modules/
npm install
</code></pre>
","17439239",""
"70398791","70386041","2021-12-17 20:52:27","3","<p>You actually need to explicitly give the Repo's Actions permission: <a href=""https://docs.github.com/en/packages/managing-github-packages-using-github-actions-workflows/publishing-and-installing-a-package-with-github-actions#upgrading-a-workflow-that-accesses-ghcrio"" rel=""nofollow noreferrer"">https://docs.github.com/en/packages/managing-github-packages-using-github-actions-workflows/publishing-and-installing-a-package-with-github-actions#upgrading-a-workflow-that-accesses-ghcrio</a></p>
<p>Necessary steps are:</p>
<ul>
<li><p>Navigate to your package landing page.</p>
</li>
<li><p>In the left sidebar, click Actions access. &quot;Actions access&quot; option in left menu</p>
<p>To ensure your container package has access to your workflow, you must add the repository where the workflow is stored to your container. Click Add repository and search for the repository you want to add.</p>
</li>
<li><p>&quot;Add repository&quot; button</p>
<p>Note: Adding a repository to your container through the Actions access menu option is different than connecting your container to a repository. For more information, see &quot;Ensuring workflow access to your package&quot; and &quot;Connecting a repository to a package.&quot;</p>
</li>
<li><p>Optionally, using the &quot;role&quot; drop-down menu, select the default access level that you'd like the repository to have to your container image.
Permission access levels to give to repositories</p>
</li>
<li><p>Open your workflow file. On the line where you log in to ghcr.io, ensure to use <code>${{ secrets.GITHUB_TOKEN }}</code> (replace PAT).</p>
</li>
</ul>
<p><strong>Note</strong>: Just linking the Package with the Repo is not enough.</p>
","725937",""
"70478511","70478320","2021-12-25 07:11:54","22","<p>It was indeed quite simple to do. All I have to do is the following:</p>
<pre><code>on:
  push:
    paths-ignore:
      - 'README.md'
      - 'backup/**'
      - '**/*.draft.md'
</code></pre>
<p>As a reference, here is the documentation in detail: <a href=""https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#patterns-to-match-file-paths"" rel=""noreferrer"">https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#patterns-to-match-file-paths</a></p>
<p>As it can be seen from the documentation that the wildcard matches any file in any folder that contains a .draft.md match.</p>
","3102968",""
"77620053","70478320","2023-12-07 12:36:15","0","<p>I have tried this in my workflows and it's working fine for me. please follow the below code.</p>
<pre><code>on:
   push:
      paths-ignore:
         - '**/&lt;dir-path&gt;/**'
</code></pre>
","23059281",""
"70574054","70556460","2022-01-04 04:18:53","1","<blockquote>
<p>I would like to have a copy of the github repository on my account, and not just in the runner's &quot;container&quot;.</p>
</blockquote>
<p>That would be better address by a <em>mirroring</em> GitHub Action, like <a href=""https://github.com/wearerequired/git-mirror-action"" rel=""nofollow noreferrer""><code>wearerequired/git-mirror-action</code></a>, or better, in your case (using tokens): <a href=""https://github.com/pkgstore/github-action-mirror"" rel=""nofollow noreferrer""><code>pkgstore/github-action-mirror</code></a></p>
<pre class=""lang-yaml prettyprint-override""><code>name: &quot;Repository Mirror: GitHub&quot;

on:
  schedule:
    - cron:  &quot;*/5 * * * *&quot;
  workflow_dispatch:

jobs:
  mirror:
    runs-on: ubuntu-latest
    name: &quot;Mirror&quot;
    steps:
      - uses: pkgstore/github-action-mirror@main
        with:
          source_repo: &quot;https://github.com/${{ github.repository }}.git&quot;
          source_user: &quot;${{ secrets.MIRROR_SOURCE_USER_GITHUB }}&quot;
          source_token: &quot;${{ secrets.MIRROR_SOURCE_TOKEN_GITHUB }}&quot;
          target_repo: &quot;${{ secrets.MIRROR_TARGET_URL_GITHUB }}&quot;
          target_user: &quot;${{ secrets.MIRROR_TARGET_USER_GITHUB }}&quot;
          target_token: &quot;${{ secrets.MIRROR_TARGET_TOKEN_GITHUB }}&quot;
</code></pre>
<p>That way, you can send the source repository to a <em>private</em> repository of yours.</p>
","6309",""
"70613414","70610678","2022-01-06 20:43:48","3","<p>You should be able to get URL as output parameter from <code>Azure/static-web-apps-deploy</code>:</p>
<pre><code>...
- name: Build And Deploy
  id: builddeploy
  uses: Azure/static-web-apps-deploy@v1
...
- name: Print Deployment URL
  run: echo ${{ steps.builddeploy.outputs.static_web_app_url }}
</code></pre>
<p>Here's a <a href=""https://github.com/Azure/static-web-apps-deploy/blob/0407e359a606e89151694428fa2457e4ef646693/action.yml#L44"" rel=""nofollow noreferrer"">link</a> to action yml where it's defined.</p>
","576752",""
"71759752","70610678","2022-04-06 00:14:15","0","<p>In my case, it was giving an empty string like below.</p>
<p><code>Environment URL '' is not a valid http(s) URL, so it will not be shown as a link in the workflow graph.</code></p>
<p>I solved this by restarting my Azure AppService.</p>
<p>Be sure to check the failed build step, as this error might also be indication of an error.</p>
","8921643",""
"72014373","70619765","2022-04-26 12:57:03","0","<p>You can put the value into the GitHub organization secret. Check the following link to get further details:
<a href=""https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/managing-encrypted-secrets-for-your-repository-and-organization-for-codespaces#adding-secrets-for-an-organization"" rel=""nofollow noreferrer"">https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/managing-encrypted-secrets-for-your-repository-and-organization-for-codespaces#adding-secrets-for-an-organization</a></p>
","4427980",""
"75847873","70619765","2023-03-26 12:53:39","1","<p><em>Posting this as I missed the EDIT section of the question and couldn't find the answer in the answers section.</em></p>
<p>As <a href=""https://stackoverflow.com/users/8794667/dulvui"">dulvui</a> states in the EDIT section of the question, this is supported since January 10th 2023 as <a href=""https://github.blog/changelog/2023-01-10-github-actions-support-for-configuration-variables-in-workflows/"" rel=""nofollow noreferrer"">posted by Github</a>.</p>
<p>Specifically at <a href=""https://docs.github.com/en/actions/learn-github-actions/variables#creating-configuration-variables-for-an-organization"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/learn-github-actions/variables#creating-configuration-variables-for-an-organization</a>, it states:</p>
<blockquote>
<p>You can create configuration variables for use across multiple workflows, and can define them at either the organization, repository, or environment level.</p>
</blockquote>
<p>And the documentation specifically for the <code>organization</code> level: <a href=""https://docs.github.com/en/actions/learn-github-actions/variables#creating-configuration-variables-for-an-organization"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/learn-github-actions/variables#creating-configuration-variables-for-an-organization</a></p>
","7653022",""
"71030112","71030111","2022-02-08 07:40:45","9","<p><a href=""https://argo-cd.readthedocs.io/en/stable/getting_started/#4-login-using-the-cli"" rel=""noreferrer"">The same docs tell us how to extract the password</a> for argo with:</p>
<pre><code>kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo
</code></pre>
<p>Obtaining the ArgoCD server's <code>hostname</code> is also no big deal using:</p>
<pre><code>kubectl get service argocd-server -n argocd --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}'
</code></pre>
<p>And as the <code>argocd login</code> command has the parameters <code>--username</code> and <code>--password</code>, <strong>we can craft our login command like this</strong>:</p>
<pre><code>argocd login $(kubectl get service argocd-server -n argocd --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}') --username admin --password $(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo) --insecure
</code></pre>
<p>Mind the <code>--insecure</code> to prevent the argo CLI from asking things like <code>WARNING: server certificate had error: x509: certificate is valid for localhost, argocd-server, argocd-server.argocd, argocd-server.argocd.svc, argocd-server.argocd.svc.cluster.local, not a5f715808162c48c1af54069ba37db0e-1371850981.eu-central-1.elb.amazonaws.com. Proceed insecurely (y/n)?</code>.</p>
<p>The successful login should somehow look like this in the GitHub Actions UI (see <a href=""https://github.com/jonashackt/tekton-argocd-eks/runs/5105912670?check_suite_focus=true"" rel=""noreferrer"">a full log here</a>):</p>
<pre><code>'admin:login' logged in successfully
Context 'a5f715808162c48c1af54069ba37db0e-1371850981.eu-central-1.elb.amazonaws.com' updated
</code></pre>
<p>Now your GitHub Actions workflow should be able to interact with the ArgoCD server.</p>
<h2>Prevent error <code>FATA[0000] dial tcp: lookup a965bfb530e8449f5a355f221b2fd107-598531793.eu-central-1.elb.amazonaws.com on 8.8.8.8:53: no such host</code></h2>
<p>This error arises if the <code>argocd-server</code> Kubernetes service is freshly installed right before the <code>argocd login</code> command is run. Then the <code>argocd login</code> command failes for some time until it finally will work correctly.</p>
<p>Assuming some DNS propagation issues we can prevent this error from breaking our CI pipeline by wrapping our <code>argocd login</code> command into an <code>until</code> like already done <a href=""https://stackoverflow.com/a/70108997/4964553"">in this answer</a>. The full command will then look like this:</p>
<pre class=""lang-sh prettyprint-override""><code>until argocd login $(kubectl get service argocd-server -n argocd --output=jsonpath='{.status.loadBalancer.ingress[0].hostname}') --username admin --password $(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo) --insecure; do : ; done
</code></pre>
<p>In GitHub Actions this will then look somehow like this:</p>
<pre><code>--- Login argocd CLI - now wrapped in until to prevent FATA[0000] dial tcp: lookup 12345.eu-central-1.elb.amazonaws.com on 8.8.8.8:53: no such host
time=&quot;2022-02-21T12:57:32Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:57:35Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:57:37Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
[...]
time=&quot;2022-02-21T12:58:27Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:58:30Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
time=&quot;2022-02-21T12:58:32Z&quot; level=fatal msg=&quot;dial tcp: lookup a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com on 127.0.0.53:53: no such host&quot;
'admin:login' logged in successfully
Context 'a071bed7e9ea14747951b04360133141-459093397.eu-central-1.elb.amazonaws.com' updated
</code></pre>
<p><a href=""https://github.com/jonashackt/tekton-argocd-eks/runs/5274400263?check_suite_focus=true"" rel=""noreferrer"">Here's also a log</a>.</p>
","4964553",""
"77578567","71030111","2023-11-30 12:49:23","1","<p>Alternatively you can exec to running argocd-server kubernetes pod:</p>
<pre><code>kubectl exec -it argocd-server-669c567686-886np -n argocd -- /bin/bash
</code></pre>
<p>Your pod name will be different due to the hash at the end. Then login to the local argocd using:</p>
<pre><code>argocd login localhost:8080 --insecure
</code></pre>
<p>it will prompt you for a username and password. If this is your first login you can find the initial password in the secret</p>
<pre><code>kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -d; echo
</code></pre>
","4673301",""
"71554893","71525489","2022-03-21 08:51:26","2","<p>The <code>::command</code> can be logged to the console by any script or executable. They are special strings the GitHub runner will detect, interpret and then take the appropriate action on.</p>
<p>They are essentially the communication mechanism between the runner and the thing it's currently running. Anything that can write to the console can issue these strings.</p>
<p>It's totally up to you to build these stings, to inject any parameters these 'magic strings' require to function.</p>
<p>The docs you've found are the right docs on these to understand how to log there strings and what commands there are available to you.</p>
<p>If you're building a GitHub action using the JavaScript/Typescript toolkit, then it provides nice wrapper functions for these commands. <a href=""https://github.com/actions/toolkit/blob/main/packages/core/src/core.ts"" rel=""nofollow noreferrer"">The JavaScript SDK also gives you a sneak peak into how to composekthese strings</a>.</p>
<p>If you're building a composite action, container task or are directly issueing commands from a script block in the workflow, then it's up to you to build the correct strings and log these to the console.</p>
<p>More details:</p>
<ul>
<li><a href=""https://github.com/actions/toolkit/blob/main/packages/core/README.md"" rel=""nofollow noreferrer"">https://github.com/actions/toolkit/blob/main/packages/core/README.md</a></li>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions</a> (you had found that already)</li>
</ul>
<p>Communicating through the console is the lowest common denominator between any tools running on just about any platform and requires no interprocess communication if any kind. It's the simplest way to communicate from a child process to it's parent.</p>
<p>You'd use the command to set an output variable.</p>
<pre><code>echo &quot;::set-output name=name::value&quot;
</code></pre>
<p>To be able to reference the value cross at you'd reference any output variable from any action.</p>
<p>Or set an environment variable which will be set for the next job: <code>echo &quot;action_state=yellow&quot; &gt;&gt; $GITHUB_ENV</code></p>
<p>See: <a href=""https://stackoverflow.com/a/57989070/736079"">https://stackoverflow.com/a/57989070/736079</a></p>
","736079",""
"71741274","71741116","2022-04-04 17:20:36","0","<p>The easiest solution would be to trigger the GitHub action workflow from the CircleCI Workflow by <a href=""https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event"" rel=""nofollow noreferrer"">create a workflow dispatch event</a>. You can use the following curl command to trigger the workflow or you could also use <a href=""https://cli.github.com/manual/gh_api"" rel=""nofollow noreferrer""><code>gh api</code></a>:</p>
<pre class=""lang-sh prettyprint-override""><code>curl \
  -X POST \
  -H &quot;Accept: application/vnd.github.v3+json&quot; \
  https://api.github.com/repos/&lt;owner&gt;/&lt;repo_name&gt;/actions/workflows/&lt;workflow&gt;/dispatches \
  -d '{&quot;ref&quot;:&quot;ref&quot;}'
</code></pre>
","10951752",""
"71885439","71885354","2022-04-15 14:43:25","0","<p>use an updated version of the <a href=""https://github.com/actions/setup-java"" rel=""nofollow noreferrer"">actions/setup-java</a> step, like:</p>
<pre><code>    steps:
    - name: checkout
      uses: actions/checkout@v3.0.1
    - name: set up JDK 1.8
      uses: actions/setup-java@
      with:
        distribution: 'zulu' # See 'Supported distributions' for available options
        java-version: '8'

</code></pre>
","2270041",""
"72057177","72038527","2022-04-29 11:22:49","1","<p>The deploy action needs write access to your repository.</p>
<p>Or upgrade to a newer version of the action, i.e. 4.3.3</p>
","2137416",""
"72478754","72478547","2022-06-02 15:33:07","0","<p>Well, I actually answered it almost myself when phrasing the question.</p>
<p>Simply create 2 builds and 2 images. One incrementing (so that you always could roll-back to an older version) and update the latest version.</p>
<p>Prioritize the latest so that it is available faster.</p>
<pre><code>- name: Build the Docker image
  run: docker build . -t me/myrepo:latest    

- name: Build the Docker image
  run: docker build .
</code></pre>
<p>-t me/myrepo:${{github.run_number}}</p>
<p>and then push it twice.</p>
<pre><code>- name: Push the also the latest Tag to Docker Hub
  run: |
    docker push me/myrepo:latest

- name: Push the new Tag to Docker Hub
  run: |
    docker push me/myrepo:${{github.run_number}}
</code></pre>
","2815264",""
"72994654","72994320","2022-07-15 13:19:31","0","<p>Not an answer but a fragment to try. My <code>Github</code> action runner for <code>ubuntu-latest</code> looks as follows (you probably want to replace the <code>install</code> target in <code>CMake</code> build command with <code>all</code>.</p>
<pre><code>jobs:
  ubuntu-build:
    name: Ubuntu Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Checkout submodules
        run: git submodule update --init --recursive
      - name: Create build directory and run CMake
        run: |
          sudo apt-get -y update
          sudo apt-get -y install libboost-dev
          cmake -S . -B cmake_build_dir -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=cmake_install_dir
      - name: Build project
        run: cmake --build cmake_build_dir --target install --config Release -- -j4
      - name: Run tests
        run:  ctest -C Release -VV
        working-directory: cmake_build_dir
      - name: Create Artifacts
        uses: actions/upload-artifact@v1
        with:
          name: Ubuntu-Artifacts
          path: cmake_install_dir/
        if: always()
</code></pre>
","5251059",""
"72994790","72994320","2022-07-15 13:29:29","2","<p>github.com will give you a fresh runner for every job.</p>
<p>See here <a href=""https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#using-a-github-hosted-runner"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#using-a-github-hosted-runner</a> for details.</p>
<p>Thus it is not possible to prepare the machine in one job and use it in a later job.</p>
<p>You should move the installation of the needed packages inside your build job.</p>
<p>In case you need to exchange artifacts, like binaries from one job to a later job, you should take a look at the github actions <a href=""https://github.com/actions/upload-artifact"" rel=""nofollow noreferrer"">upload-artifact</a> and <a href=""https://github.com/actions/download-artifact"" rel=""nofollow noreferrer"">download-artifact</a>.</p>
","8281848",""
"73941762","73018888","2022-10-03 23:31:28","2","<p>As <a href=""https://docs.github.com/en/actions/using-jobs/using-concurrency"" rel=""nofollow noreferrer"">documented</a> &quot;Any previously pending in the concurrency group will be canceled&quot;. In others words, the queue is limited in one. Somewhat useless. To permit parallel execution just not use 'concurrency' term on action.</p>
","1056652",""
"73143764","73143492","2022-07-27 19:39:28","0","<p>AWS Aurora does not support stopping individual instances/nodes. <code>stop-db-cluster</code> is the only option. It looks like you only have a one node cluster anyway, so what would be the difference?</p>
","13070",""
"73180332","73178417","2022-07-31 02:40:22","1","<p>Try:</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  ...
  labels:
    type: nginx  # &lt;-- correct
spec:
  ...
  selector:
    matchLabels:
      type: nginx  # incorrect, remove the '-'
  template:
    metadata:
      labels:
        type: nginx  # incorrect, remove the '-' 
    spec:
      ...
---
apiVersion: v1
kind: Service
...
spec:
  ...
  ports:
  - port: 80  # &lt;-- add '-'
    protocol: TCP
    targetPort: 80
</code></pre>
","14704799",""
"73261753","73255602","2022-08-06 17:02:36","1","<p>I just had to add the argument <code>--exit-code-from</code> while running the Docker container and that helped GitHub actions to identify the exit code properly.</p>
","9801092",""
"73723615","73319566","2022-09-14 22:00:16","0","<p>docker-compose has an option <code>--exit-code-from</code> to wrap it up when one container finishes.</p>
<p><code>docker-compose up --exit-code-from api</code></p>
<p>Also I think you will need to remove <code>restart: always</code>. Maybe creating a separate <code>docker-compose</code> yaml file for this testing purposes is a good idea too.</p>
","324506",""
"73329852","73327325","2022-08-12 06:08:32","1","<p>If you want to create an environment variable, add it to the file behind <code>$GITHUB_ENV</code> like so:</p>
<pre class=""lang-yaml prettyprint-override""><code>- run: echo &quot;NAME=${{ github.repository }}_$(cat VERSION).zip&quot; &gt;&gt; $GITHUB_ENV
- run: echo ${{ env. NAME }}
</code></pre>
<p>For more information, see the docs on <a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable"" rel=""nofollow noreferrer"">Workflow commands for GitHub Actions / Setting an environment variable</a></p>
","1080523",""
"74231975","73394214","2022-10-28 07:31:58","1","<p>You should only need to apt-get the package to install the driver:</p>
<pre><code>    steps:
      - uses: actions/checkout@v3

      - name: Install Microsoft ODBC
        run: sudo ACCEPT_EULA=Y apt-get install msodbcsql18 -y
</code></pre>
<p>that successfully installs for me. Worth pointing out though that when you connect you'll need to use the mapped port to the container:</p>
<pre><code>        env:
          PORT: ${{ job.services.mssql.ports[1433] }}
</code></pre>
<p>this assumes SQL Server was setup like:</p>
<pre><code>      mssql:
        image: mcr.microsoft.com/mssql/server:2022-latest
        ports: [1433]
        env:
          MSSQL_PID: Developer
          SA_PASSWORD: iugeshrigsuerbiwer
          ACCEPT_EULA: Y
</code></pre>
","912408",""
"75276882","73394214","2023-01-29 17:25:24","0","<p>You need to run the commands with elevated privileges.
Simply, add <code>shell</code> with <code>sudo</code> like so:</p>
<pre><code>- name: Install dependencies
  run: |
    python -m pip install --upgrade pip
    ...
    sudo apt-get install -y unixodbc-dev
  shell: sudo bash {0}
</code></pre>
","151641",""
"76351980","73394214","2023-05-28 14:28:23","1","<p>Because all of the above worked for me only sometimes for some reason. I wrote an action that follows the exact instructions from microsoft to install mssql odbc drivers for any distro. Here <a href=""https://github.com/Yarden-zamir/install-mssql-odbc"" rel=""nofollow noreferrer"">https://github.com/Yarden-zamir/install-mssql-odbc</a>. If anyone stumbling onto here like me in the future and finds this useful that would be awesome.</p>
<p>You can use it like</p>
<pre><code>      - uses: Yarden-zamir/install-mssql-odbc@main
</code></pre>
<p>or</p>
<pre><code># all inputs
      - uses: Yarden-zamir/install-mssql-odbc@main
        with:
          ODBC_VERSION: 17
          DISTRO: Alpine
          DOCS_URL: https://yarden-zamir.com/alternate-docs-path.md
          REMOVE_EXITS: true
</code></pre>
","19101016",""
"73667912","73626276","2022-09-09 22:10:35","1","<p>As explained by @ianyoung, the problem was with the pip file.  The <a href=""https://realpython.com/lessons/using-requirement-files/#:%7E:text=A%20Beginner%27s%20Guide%20to%20Pip&amp;text=A%20requirements%20file%20is%20a,current%20projects%20dependencies%20to%20stdout%20."" rel=""nofollow noreferrer"">requirements.txt</a> was empty, the requirements file is a list of all of a project’s dependencies. This includes the dependencies needed by the dependencies. It also contains the specific version of each dependency, specified with a double equals sign (==).</p>
","17544312",""
"73811772","73798925","2022-09-22 08:48:15","6","<p>Rather than sending a notification for each job that fails (or succeeds) it is usually possible to 'chain' the jobs together by <a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds"" rel=""noreferrer"">using the <code>needs</code> keyword</a> to create a dependency tree.</p>
<p>To keep the logic separate, you can add a final job just to perform the notification to Slack, and this can be set up as a dependency on all your earlier jobs.</p>
<p>The final job can calculate the overall workflow status using something like <code>${{ job.status == 'success' &amp;&amp; needs.earlierjob1.result == 'success' &amp;&amp; needs.earlierjob2.result == 'success' }</code> to represent a boolean of overall success. This can become easier to maintain by using <code>needs.*.result</code> instead of listing each job by name.</p>
<p>I wrote an article going into <a href=""https://levelup.gitconnected.com/structuring-github-actions-safely-5309e5ee54de?sk=b069c962eea18d65c3c93d24b9a673e7"" rel=""noreferrer"">more detail here</a>, including examples of what works and what doesn't.</p>
<p>In the end, I built a native Slack app to take care of this automatically so you don't need to think about job status or notifications at all.</p>
","2792760",""
"77893065","73951328","2024-01-27 22:39:18","0","<p>I'm about 15 months late to this post but I have been beating my head against the wall over the same issue, so I wanted to post a solution here in case it helps anyone else that finds this. Take this with a grain of salt since I'm still very green with this stuff, but the yaml code below worked for me</p>
<p>My goal with this was to automatically push an empty commit every day at 3AM (I'm hosting a website on railway.app, and this is seemingly one of the only ways to automate redeployment):</p>
<pre><code>name: cron-schedule-updater
on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '0 3 * * *'
 
jobs:
  empty_commit:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - run: git config user.email &quot;YOUR_EMAIL@EMAIL.COM&quot;
    - run: git config user.name &quot;YOUR NAME&quot;

    - name: Create Empty Commit
      run: git commit --allow-empty -m &quot;Empty commit&quot;

    - name: Push Empty Commit
      run: git push origin main  # Change 'main' to your branch name
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</code></pre>
<p>Some notes, in order of importance:</p>
<p>1.) From the github repo dashboard, go to &quot;Settings&quot; -&gt; &quot;Actions&quot;, then scroll down to &quot;Workflow permissions&quot;, and select &quot;Read and write permissions.&quot; It won't work without selecting this</p>
<p>2.) The secret token is automatically generated with that last line, so nothing extra that you need to do there. Mostly sure that line is necessary but not 100%</p>
<p>3.) In the repo settings, also make sure that you don't have any branch protection rules preventing this, and note that you may have some extra headaches if it's a private repo</p>
<p>Anyways, I think that's everything. Hope that helps!</p>
","19669561",""
"74113575","74112918","2022-10-18 15:26:03","5","<p>The way I've addressed a similar need is to use <code>tee</code>:</p>
<pre class=""lang-yaml prettyprint-override""><code>    steps:
      - name: Run Tool
        run: |
          some_tool | tee output.log
        shell: bash
</code></pre>
<p>That results in you getting the same logs you'd always see in the GitHub Actions console, while also persisting them to disk. If you want stderr too, do</p>
<pre class=""lang-bash prettyprint-override""><code>some_tool 2&gt;&amp;1 | tee output.log
</code></pre>
<p>Then, in a later step in the same job, you can do whatever you like with those logs, using the <a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#failure"" rel=""noreferrer""><code>if: ${{ failure() }}</code> syntax</a>:</p>
<pre class=""lang-yaml prettyprint-override""><code>    steps:
      - name: Persist logs
        if: ${{ failure() }}
        run: |
          cat output.log | do_something_with_logs
        shell: bash
</code></pre>
<p>If you need to persist the logs across a job boundary, you could use <a href=""https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts"" rel=""noreferrer"">artifacts</a>.</p>
","1159783",""
"74117425","74114983","2022-10-18 21:01:06","0","<p>I found that the problem was that after I had moved my file I wasn't committing.</p>
<p>I didn't know you had to commit in the github actions for the file to actually end up in the repo.</p>
","20230484",""
"74419810","74416617","2022-11-13 09:27:44","0","<p>Its it's possible for your use case, you could trigger your workflow on push and then apply your filter to the branch or tag</p>
<pre><code>name: maven-release

on:
  workflow_dispatch:
  push:
    tags:
      - '*-origin/develop'

jobs:
  checkout_code:
    runs-on: [ubuntu-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

  maven_build:
    runs-on: [ubuntu-latest]
    if: ${{ github.ref == 'refs/tags/*-origin/develop' }}
    needs: checkout_code
    steps:
      - name: Run maven build
        run: |
          mvn clean install
</code></pre>
<p>The Github <a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet"" rel=""nofollow noreferrer"">filter pattern cheat sheet</a></p>
","8009593",""
"74774900","74416617","2022-12-12 17:20:48","0","<p>For the workflows for which each task needs to be executed only on a particular tag, then we can make use of below snipped</p>
<pre><code>name: maven_build
on:
  workflow_dispatch:
jobs:
  checkout:
    runs-on: [ubuntu-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
  maven_build:
    runs-on: [ubuntu-latest]
    if: startsWith(github.ref, 'refs/tags/') &amp;&amp; !contains(github.ref')
    needs: checkout
    steps:
      - name: Run maven build command
        run: |
          mvn clean install
</code></pre>
<p>The above snippet will run only when the checkout branch matches a tag</p>
","3609010",""
"76480296","74572309","2023-06-15 07:57:29","0","<p>There exists a reusable workflow that can force runs of a workflow to run consecutively (i.e., in order). This solved my problem.</p>
<p>Here is the reusable workflow: <a href=""https://github.com/mktcode/consecutive-workflow-action"" rel=""nofollow noreferrer"">https://github.com/mktcode/consecutive-workflow-action</a></p>
","4290962",""
"74602497","74601050","2022-11-28 14:58:39","1","<p>I was able to fix it by adding the following in my publish.yml:</p>
<pre><code>jobs:
  tests:
    uses: ./.github/workflows/build.yml

  publish:
    runs-on: ubuntu-latest
    needs: [tests] # See build.yml file where the test job is defined
</code></pre>
<p>In my build.yml, I had to add the following:</p>
<pre><code>on:
  push:
    paths-ignore:
      - 'images/**'
      - README.md
    branches:
      - master
  pull_request:
    branches:
      - master
  release:
    types: [ created ]
  workflow_call:
</code></pre>
<p>Notice that workflow_call: entry that needs to be added explicitly.</p>
","3102968",""
"74602547","74601050","2022-11-28 15:03:07","1","<blockquote>
<p>So basically what I want is, when I push an annotated tag, I want to first run the test job from build.yml and then once that succeeds, I would like to run the publish job. Any suggestions on how to get this straight?</p>
</blockquote>
<p>You almost got it right with your implementation. You just need a few modifications:</p>
<ul>
<li>The <code>build</code> job needs to depends on the <code>publish</code> job:</li>
</ul>
<pre class=""lang-yaml prettyprint-override""><code>name: release my-project

on:
  push:
    # Sequence of patterns matched against refs/tags
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+-[a-zA-Z]*'

jobs:
  publish:
     [ ... ]

  build:
    needs:
      - publish
    uses: ./.github/workflows/build.yml
</code></pre>
<ul>
<li>The <code>build</code> needs the <code>workflow_call</code> trigger (as stated by the error message - <a href=""https://docs.github.com/en/actions/using-workflows/reusing-workflows#creating-a-reusable-workflow"" rel=""nofollow noreferrer"">Reference</a>):</li>
</ul>
<pre class=""lang-yaml prettyprint-override""><code>on:
  workflow_call:
  push:
    [ ... ]
</code></pre>
<hr />
<p>Note: You could even share the <code>tag</code> value from the previous workflow, sending it as input to the second one by using:</p>
<pre class=""lang-yaml prettyprint-override""><code>on:
  workflow_call:
    inputs:
      tag:
        required: true
        type: string
</code></pre>
<p>Calling the reusable workflow that way from the main workflow:</p>
<pre><code>  build:
    needs:
      - publish
    uses: ./.github/workflows/build.yml
    with:
      tag: 'MY TAG'
</code></pre>
","8496462",""
"74788493","74775432","2022-12-13 17:08:51","0","<p>You're sending a <code>dispatch</code> event to the second workflow with 3 inputs (repository, commit and env), but the second workflow <code>workflow_dispatch</code> event isn't configured to receive those 3 inputs.</p>
<p>You should have a similar configuration to the one in the first workflow to be able to receive the inputs.</p>
<p>Like this:</p>
<pre><code>on:
  workflow_dispatch:
    inputs:
      repository:
        description: 'Name of triggered repo'
        required: true
        default: '123re'
        type: string
      commit:
        description: 'Short commit'
        required: true
        type: string
        default: 'e123'
      env:
        description: 'Environment'
        required: true
        type: choice
        options:
        - dev
        - staging
        - prod
</code></pre>
","8496462",""
"75326472","74869907","2023-02-02 16:54:57","1","<p>You are probably missing parameters in the command line, here I would say <code>provisioningProfiles</code> parameter in particular.</p>
<p>To make sure you can run the command correctly you can:</p>
<ol>
<li>Open Xcode on your development machine and disable automatic signing if not already unchecked</li>
<li>Still in Xcode, select your scheme and then run <code>Product</code> &gt; <code>Archive</code> from the menu. Click on <code>Distribute app</code> in the new window and go through the steps. Make sure you select a valid provisioning profile and certificate at this step. Go to the end and just export (don't go to the AppStore), Xcode will generate you an export folder. You should see a file named <code>ExportOptions.plist</code> in this folder, similar to the following:
<pre class=""lang-xml prettyprint-override""><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
    &lt;dict&gt;
        &lt;key&gt;destination&lt;/key&gt;
        &lt;string&gt;export&lt;/string&gt;
        &lt;key&gt;method&lt;/key&gt;
        &lt;string&gt;app-store&lt;/string&gt;
        &lt;key&gt;provisioningProfiles&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;your.bundle.id&lt;/key&gt;
            &lt;string&gt;Provisioning Profile name&lt;/string&gt;
        &lt;/dict&gt;
        &lt;key&gt;signingCertificate&lt;/key&gt;
        &lt;string&gt;Apple Distribution&lt;/string&gt;
        &lt;key&gt;signingStyle&lt;/key&gt;
        &lt;string&gt;manual&lt;/string&gt;
        &lt;key&gt;teamID&lt;/key&gt;
        &lt;string&gt;123ABC12&lt;/string&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
</li>
<li>Open the exported folder and look for a file named <code>ExportOptions.plist</code>. This file basically contain the arguments that you should pass to your CI command line to mimic what Xcode does locally</li>
<li>Encode this file as base64 and store it as a Github Actions secret, e.g. <code>IOS_EXPORT_OPTIONS_PLIST</code></li>
<li>Resolve the file in your Github Action step and decode it from base64, store it somewhere, say $EXPORT_OPTIONS_PATH</li>
<li>Run your command line with with this added option: <code>xcodebuild archive -yourparams -exportOptionsPlist $EXPORT_OPTIONS_PATH</code></li>
</ol>
<p>Note: You can run <code>xcodebuild -h</code> to see all the available options that you can add to the ExportOptions.plist file.</p>
","702954",""
"74888244","74887938","2022-12-22 12:01:57","0","<p>You need to define an identifier for the step in order to be able to refer it as an output for the job. See the relevant part of the <a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-output-parameter"" rel=""nofollow noreferrer"">doc</a>:</p>
<blockquote>
<p>Sets a step's output parameter. Note that the step will need an id to be defined to later retrieve the output value.</p>
</blockquote>
<p>So you should change your code like:</p>
<pre><code>job-a:
    outputs:
      comment: ${{ steps.store-comment.outputs.comment }}
    steps:
    - name: Check if QR already exists
      uses: peter-evans/find-comment@v2
      id: find-comment
      with:
        issue-number: ${{ github.event.number }}
        comment-author: &quot;github-actions[bot]&quot;
        body-includes: Preview Bundle

    - name: Store find-comment output
      id: store-comment
      run: echo &quot;comment=${{ steps.find-comment.outputs.comment-id }}&quot; &gt;&gt; $GITHUB_OUTPUT


</code></pre>
","2270041",""
"74888612","74887938","2022-12-22 12:35:59","0","<p>The answer was to change the <code>outputs</code> variable to take <code>comment-id</code> instead of just <code>comment</code>. I thought the chained property had to match what you put int eh <code>echo</code> command, but apparently it has to match what is in the outputs of <code>peter-evans/find-comment@v2</code>: <a href=""https://github.com/peter-evans/find-comment#outputs"" rel=""nofollow noreferrer"">https://github.com/peter-evans/find-comment#outputs</a></p>
<pre class=""lang-yaml prettyprint-override""><code>job-a:
    outputs:
      comment: ${{ steps.store-comment.outputs.comment-id }}
</code></pre>
","13063136",""
"74951756","74927029","2022-12-29 13:32:15","8","<p>As per my experience, I suggest you to put the Nuget Application into another repository and follow the below instructions.</p>
<p>I've done this many times. Let me walk you through it.</p>
<h3>1. Create API Key:</h3>
<p>Sign in to nuget.org then go to the API Keys management and create a key.</p>
<h3>2. Add the API key to GitHub repository</h3>
<p>Go to GitHub and desired repository settings, then to Secrets. Create a new secret and paste there API key created on the first step.</p>
<p><a href=""https://i.sstatic.net/HA1sL.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/HA1sL.png"" alt=""enter image description here"" /></a></p>
<h3>3. Add workflow instructions:</h3>
<p>Create a file under the root
<code>&lt; YOUR REPO &gt; /.github/workflows/release.yml</code></p>
<pre><code>name: Release to NuGet

on:
  release:
    types: [published]
    
jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v1
    - name: Build
      run: dotnet build -c Release
    - name: Test
      run: dotnet test -c Release --no-build
    - name: Pack nugets
      run: dotnet pack -c Release --no-build --output .
    - name: Push to NuGet
      run: dotnet nuget push &quot;*.nupkg&quot; --api-key ${{secrets.nuget_api_key}} --source https://api.nuget.org/v3/index.json
</code></pre>
<p>It does:</p>
<ul>
<li>triggers on release publish</li>
<li>runs on ubuntu-latest</li>
<li>setup .NET SDK</li>
<li>runs dotnet build then tests</li>
<li>packs nugets and push it nuget.org using the attached nuget key</li>
</ul>
<h3>4. Create release:</h3>
<ul>
<li><p>Find the Releases link on the main page of your repo<br />
<a href=""https://i.sstatic.net/ZYAWB.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/ZYAWB.png"" alt=""enter image description here"" /></a></p>
</li>
<li><p>Then create a new release<br />
<a href=""https://i.sstatic.net/njvlS.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/njvlS.png"" alt=""enter image description here"" /></a></p>
</li>
<li><p>Verify the success of workflow.<br />
<a href=""https://i.sstatic.net/2BWZs.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/2BWZs.png"" alt=""enter image description here"" /></a></p>
</li>
</ul>
<hr />
<p>Helpful Links:</p>
<ol>
<li><a href=""https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-nuget-registry"" rel=""noreferrer"">Github Doc</a></li>
</ol>
","12017533",""
"74953373","74927029","2022-12-29 16:01:41","1","<p>The alternative to <a href=""https://stackoverflow.com/users/12017533/jiya"">Jiya</a>'s <a href=""https://stackoverflow.com/a/74951756"">answer</a> is to use the GitHub action <a href=""https://github.com/linch90/publish-nuget"" rel=""nofollow noreferrer""><code>linch90/publish-nuget</code></a>, which does the same kind of operation, and will do the same <a href=""https://github.com/linch90/publish-nuget/blob/8c0b10adcf4fe617d955c36b0e84d23639a8108a/index.js#L102-L107"" rel=""nofollow noreferrer""><code>dotnet nuget push</code></a>.</p>
<pre class=""lang-yaml prettyprint-override""><code>name: publish to nuget
on:
  push:
    branches:
      - master # Default release branch
jobs:
  publish:
    name: build, pack &amp; publish
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      # - name: Setup dotnet
      #   uses: actions/setup-dotnet@v1
      #   with:
      #     dotnet-version: 6.0.0

      # Publish
      - name: publish on version change
        id: publish_nuget
        uses: alirezanet/publish-nuget@v3.0.0
        with:
          # Filepath of the project to be packaged, relative to root of repository
          PROJECT_FILE_PATH: Core/Core.csproj
          
          # NuGet package id, used for version detection &amp; defaults to project name
          # PACKAGE_NAME: Core
          
          # Filepath with version info, relative to root of repository &amp; defaults to PROJECT_FILE_PATH
          # VERSION_FILE_PATH: Directory.Build.props

          # Regex pattern to extract version info in a capturing group
          # VERSION_REGEX: ^\s*&lt;Version&gt;(.*)&lt;\/Version&gt;\s*$
          
          # Useful with external providers like Nerdbank.GitVersioning, ignores VERSION_FILE_PATH &amp; VERSION_REGEX
          # VERSION_STATIC: 1.0.0

          # Flag to toggle git tagging, enabled by default
          # TAG_COMMIT: true

          # Format of the git tag, [*] gets replaced with actual version
          # TAG_FORMAT: v*

          # API key to authenticate with NuGet server
          # NUGET_KEY: ${{secrets.NUGET_API_KEY}}

          # NuGet server uri hosting the packages, defaults to https://api.nuget.org
          # NUGET_SOURCE: https://api.nuget.org

          # Flag to toggle pushing symbols along with nuget package to the server, disabled by default
          # INCLUDE_SYMBOLS: false

          # Flag to toggle not building the project and letting pack command handle restoring &amp; building, disabled by default
          # NO_BUILD: false
</code></pre>
<blockquote>
<p>Project gets published only if there's a <code>NUGET_KEY</code> configured in the repository (API key to authenticate with NuGet server)</p>
</blockquote>
<p>So you need to register a <code>NUGET_KEY</code> secret in your repository.</p>
","6309",""
"77239274","74927029","2023-10-05 17:17:31","2","<h2>Create the action using actions/setup-dotnet@v3</h2>
<pre><code>name: Publish Bolivia Package
runs-on: ubuntu-latest
permissions:
  contents: read
  packages: write # permission for the github token
steps:
  - uses: actions/checkout@v3
  - uses: actions/setup-dotnet@v3
    with:
      dotnet-version: '3.1.x' # No change it
      source-url: https://nuget.pkg.github.com/&lt;owner|organization&gt;/index.json
    env:
      NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}
  - name: Build project
    run: dotnet build --configuration Release
  - name: Create the package
    run: dotnet pack --configuration Release
  - name: Publish the package to GPR
    run: dotnet nuget push bin/Release/*.nupkg
</code></pre>
","9028384",""
"74973611","74973574","2023-01-01 07:58:59","2","<p>If your modules are on different paths within the same Git repository, you could use a <a href=""https://github.com/dorny/paths-filter"" rel=""nofollow noreferrer"">path-filter action</a>, as <a href=""https://stackoverflow.com/a/67941131/6309"">illustrated here</a>.</p>
<p>Note that you cannot tag just a part of a repository, but, if your changes involves only that one module, you can then decide apply a (global) tag with a naming convention reflecting the nature of the change (IE only module1 or only module2).</p>
","6309",""
"74973794","74973574","2023-01-01 09:04:11","2","<p>If you only ever want to publish <code>module1</code>, you can set <code>publish / skip := true</code> in the project settings in <code>build.sbt</code> for other modules and the root project.</p>
","5389127",""
"75162857","75162480","2023-01-18 17:11:21","0","<p>Yes, according to <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule"" rel=""nofollow noreferrer"">schedule</a>:</p>
<blockquote>
<p>Scheduled workflows run on the latest commit on the default or base branch.</p>
</blockquote>
<p>However, it looks like it's doable by configuring the cron job for the default branch and then somehow triggering the workflow for the non-default branch e.g. <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch"" rel=""nofollow noreferrer"">using the GitHub API or CLI</a>.</p>
<p>See <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch"" rel=""nofollow noreferrer"">workflow_dispatch</a> for more details.</p>
<p>Or, via <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run"" rel=""nofollow noreferrer"">workflow_run</a> configuration after completion of the workflow on the default branch. Though, in this case, you might not want to combine both in general scenarios.</p>
","7670262",""
"75276258","75268325","2023-01-29 15:55:16","1","<p>I found out the Docker in GitHub Actions does not support DNS and behaves fundamentally different than regular Docker on Linux. All network communication must be made over the host network. So I had to specify localhost as the database server.</p>
<p>This would be the correct workflow file:</p>
<pre><code>name: .NET Backend Build and run Unit Tests

on:
  push:
    branches: [ &quot;main&quot; ]
  pull_request:
    branches: [ &quot;main&quot; ]
  workflow_dispatch:

env:
  CI: true

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    services:
      sqlserver:
        image: mcr.microsoft.com/mssql/server:2022-latest
        ports:
          - 1433:1433
        env:
          ACCEPT_EULA: &quot;Y&quot;
          MSSQL_SA_PASSWORD: &quot;redacted&quot;
          MSSQL_PID: &quot;Express&quot;
          MSSQL_COLLATION: &quot;SQL_Latin1_General_CP1_CI_AS&quot;

    steps:
    - name: get Container ID
      run: echo &quot;DATABASE_ID=$(docker ps --all --filter status=running --format &quot;{{.ID}}&quot;)&quot; &gt;&gt; $GITHUB_ENV

    - name: create database
      run: docker exec $DATABASE_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P 'redacted' -Q 'CREATE DATABASE dbname'

    - uses: actions/checkout@v3

    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: dotnet build --no-restore

    - name: Test
      env:
        DATABASE_SERVER: localhost
        DATABASE_PORT: 1433
        DATABASE_NAME: dbname
        DATABASE_USER: sa
        DATABASE_PASSWORD: redacted
      run: dotnet test --no-build --verbosity normal
</code></pre>
","11333318",""
"75329727","75322937","2023-02-02 22:50:15","1","<p>No, you cannot do this. It’s completely locked to that folder.</p>
<p>Only for action.yml files this is allowed (can be put anywhere, but then you do have to reference them differently with the full folder path).</p>
","4395661",""
"75412290","75386396","2023-02-10 14:11:18","0","<p>At the YAML level, single quotes around <code>${{ secrets... }}</code> should fix the syntax error.</p>
<p>But, according to the <a href=""https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability"" rel=""nofollow noreferrer"">Context availability</a>, the <code>secrets</code> context is not allowed under <code>stratey</code>. The allowed contexts are:</p>
<pre><code>jobs.&lt;job_id&gt;.strategy      github, needs, vars, inputs
</code></pre>
<p>You can make use of the <a href=""https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context"" rel=""nofollow noreferrer""><code>vars</code> context</a> for your use case.</p>
<p>Apart from that, linting your workflow with <a href=""https://rhysd.github.io/actionlint/"" rel=""nofollow noreferrer"">https://rhysd.github.io/actionlint/</a> would be much faster to identify potential issues.</p>
<hr />
<p><strong>UPDATE</strong> (by <a href=""https://stackoverflow.com/users/4473386/dmytro-chasovskyi"">Dmytro Chasovskyi</a>)</p>
<p>Here is an example with the <code>vars</code> context:</p>
<p>With a variable <code>DOMAINS</code> having this config:</p>
<pre class=""lang-json prettyprint-override""><code>{
   &quot;v1&quot;: {
     &quot;url&quot;: &quot;http://localhost:80/api/v1&quot;
   },
   &quot;v2&quot;: {
     &quot;url&quot;: &quot;http://localhost:80/api/v2&quot;
   }
}
</code></pre>
<p>the workflow will be:</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  build:
    strategy:
      matrix:
        domain: [['main', 'books-v1', '${{ vars.DOMAINS.v1.url }}'], ['old-main', 'books-v2', '${{ vars.DOMAINS.v2.url }}']]
</code></pre>
","7670262",""
"75489150","75489109","2023-02-17 20:52:39","1","<p>You could use the <a href=""https://github.com/marketplace/actions/slack-send"" rel=""nofollow noreferrer"">slack-send</a> GitHub Action to send data into Slack from your GitHub Workflow.</p>
<p>This Action can:</p>
<ul>
<li>Send data to Slack's Workflow Builder (requires a paid Slack instance).</li>
<li>Send data via a Slack app to post to a specific channel (use an existing custom app or create a new one).</li>
<li>Send data via a Slack Incoming Webhook URL (use an existing custom app or create a new one).</li>
</ul>
<p>There are a <a href=""https://github.com/marketplace?type=actions&amp;query=slack+"" rel=""nofollow noreferrer"">bunch of similar actions</a>, for example, <a href=""https://github.com/marketplace/actions/slack-github-actions-slack-integration"" rel=""nofollow noreferrer"">slack - GitHub Actions Slack integration</a> - also simple and flexible Slack integration with GitHub Actions.</p>
","7328018",""
"75720806","75720649","2023-03-13 10:44:22","-3","<pre><code>def write(filename, text):

    with open(filename, 'w') as file:
        file.write(text)

filename = 'example.txt'

text = '12works!'

write(filename, text)
</code></pre>
<p>The text is what you going to write into the file</p>
","21388440",""
"75752131","75750113","2023-03-16 04:17:37","2","<p>For JavaScript, use <a href=""https://github.com/actions/toolkit"" rel=""nofollow noreferrer"">https://github.com/actions/toolkit</a>.</p>
<p>See <a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#using-workflow-commands-to-access-toolkit-functions"" rel=""nofollow noreferrer"">Using workflow commands to access toolkit functions</a> for more details.</p>
<p>Check <code>core.exportVariable</code>, <code>core.setOutput</code>, etc. according to your use case.</p>
<hr />
<p>For GHA Workflows, see</p>
<ul>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable"" rel=""nofollow noreferrer"">Setting an environment variable</a> (<code>GITHUB_ENV</code>)</li>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-output-parameter"" rel=""nofollow noreferrer"">Setting an output parameter</a> (<code>GITHUB_OUTPUT</code>)</li>
</ul>
<p>There are multiple threads on SO to set these according to the runner OS shell.</p>
","7670262",""
"75846432","75839566","2023-03-26 07:30:01","1","<p>To enable access to your MongoDB database via GitHub Actions, you need to add the IP address and select the <strong>Allow Access from Anywhere</strong> option.</p>
","21485808",""
"78117472","75839566","2024-03-06 21:09:19","-1","<p>Rather than allowing <em>any</em> IP to access the cluster, you can add the runner's IP for the duration of the job:</p>
<ul>
<li><p>As a secret, supply <a href=""https://www.mongodb.com/docs/atlas/configure-api-access/#std-label-create-org-api-key"" rel=""nofollow noreferrer"">API credentials</a> with the Project Owner role. <strong>Note</strong> that you must also permit access to any IP for the Atlas administration API itself (<a href=""https://www.mongodb.com/docs/atlas/configure-api-access/#optional--require-an-ip-access-list-for-the-atlas-administration-api"" rel=""nofollow noreferrer"">docs</a>).</p>
</li>
<li><p>Make a request to e.g. <a href=""https://checkip.amazonaws.com"" rel=""nofollow noreferrer"">https://checkip.amazonaws.com</a> to find out what the specific runner's public IP is:</p>
<pre class=""lang-yaml prettyprint-override""><code>- name: Get the public IP of the runner
  id: get-ip
  shell: bash
  run: |
    echo &quot;ip-address=$(curl https://checkip.amazonaws.com)&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
</code></pre>
</li>
<li><p>Make a request to the MongoDB Atlas API <a href=""https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Project-IP-Access-List/operation/createProjectIpAccessList"" rel=""nofollow noreferrer""><code>POST /groups/{groupId}/accessList</code></a> to permit access to that IP:</p>
<pre class=""lang-yaml prettyprint-override""><code>- name: Permit the runner to access MongoDB Atlas
  id: allow-ip
  shell: bash
  run: |
    curl \
       --data '[{&quot;ipAddress&quot;: &quot;${{ steps.get-ip.outputs.ip-address }}&quot;, &quot;comment&quot;: &quot;GitHub Actions Runner&quot;}]' \
       --digest \
       --header 'Accept: application/vnd.atlas.2023-02-01+json' \
       --header 'Content-Type: application/json' \
       --user &quot;$USERNAME:$PASSWORD&quot; \
       &quot;https://cloud.mongodb.com/api/atlas/v2/groups/$GROUP_ID/accessList&quot;
  env:
    GROUP_ID: ${{ secrets.ATLAS_GROUP_ID }}
    PASSWORD: ${{ secrets.ATLAS_PRIVATE_KEY }}
    USERNAME: ${{ secrets.ATLAS_PUBLIC_KEY }}
</code></pre>
</li>
<li><p>After the access has happened, on success <em>or</em> failure, make a request to <a href=""https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Project-IP-Access-List/operation/deleteProjectIpAccessList"" rel=""nofollow noreferrer""><code>DELETE /groups/{groupId}/accessList/{entryValue}</code></a> to revoke access:</p>
<pre class=""lang-yaml prettyprint-override""><code>- name: Revoke the runner's access to MongoDB Atlas
  if: always() &amp;&amp; steps.allow-ip.outcome == 'success'
  shell: bash
  run: |
    curl \
       --digest \
       --header 'Accept: application/vnd.atlas.2023-02-01+json' \
       --request 'DELETE' \
       --user &quot;$USERNAME:$PASSWORD&quot; \
       &quot;https://cloud.mongodb.com/api/atlas/v2/groups/$GROUP_ID/accessList/${{ steps.get-ip.outputs.ip-address }}&quot;
  env:
    GROUP_ID: ${{ secrets.ATLAS_GROUP_ID }}
    PASSWORD: ${{ secrets.ATLAS_PRIVATE_KEY }}
    USERNAME: ${{ secrets.ATLAS_PUBLIC_KEY }}
</code></pre>
</li>
</ul>
<p>Another way to do this, including automatically applying the post-job step, is in a <a href=""https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action"" rel=""nofollow noreferrer"">custom JavaScript action</a> (using <a href=""https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runspost"" rel=""nofollow noreferrer""><code>runs.post</code></a> to make the <code>DELETE</code> request). I have <a href=""https://github.com/marketplace/actions/allow-mongodb-atlas-ip"" rel=""nofollow noreferrer"">published</a> such an action to the marketplace.</p>
","3001761",""
"78593379","75839566","2024-06-07 17:42:14","0","<p>Just to add to the answer by @jonrsharpe, this approach can be simplified by using the <a href=""https://github.com/mongodb/atlas-github-action"" rel=""nofollow noreferrer"">MongoDB Atlas CLI github action</a>.</p>
<pre><code>  # Grant temporary MongoDB access to this Github Action runner ip address
  - name: Get the public IP of this runner
    id: get_gh_runner_ip
    shell: bash
    run: |
      echo &quot;ip_address=$(curl https://checkip.amazonaws.com)&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
  - name: Setup MongoDB Atlas cli
    uses: mongodb/atlas-github-action@v0.2.0
  - name: Add runner IP to MongoDB access list
    shell: bash
    run: |
      atlas accessLists create ${{ steps.get_gh_runner_ip.outputs.ip_address }} --type ipAddress --projectId ${{ env.MONGODB_ATLAS_PROJECT_ID }} --comment  &quot;Temporary access for GH Action&quot;
</code></pre>
<p>At the end of your workflow:</p>
<pre><code>    - name: Remove GH runner IP from MongDB access list
    shell: bash
    run: |
      atlas accessLists delete ${{ steps.get_gh_runner_ip.outputs.ip_address }} --projectId ${{ env.MONGODB_ATLAS_PROJECT_ID }} --force
</code></pre>
","9822967",""
"76809543","75884083","2023-08-01 07:53:36","0","<p>Here is an example from a working GitHub Action</p>
<pre><code>    - name: Deploy with AWS CloudFormation
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: service-name
        template: stack.yaml
        parameter-overrides: &gt;-
          FirstParameter=stg,            
          SecondParameter=something
</code></pre>
","4061047",""
"75997281","75996853","2023-04-12 15:27:23","2","<p>There are 2 issues in play:</p>
<ol>
<li>You need to declare the output variable at the step as well as at the job level</li>
<li>Bash will stop processing when a command returns an error.</li>
</ol>
<h2>Declare the output variable at the job level</h2>
<p>Your 2nd job can't access the step output without you also declaring it as a job output:</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
  check-for-changes:
    # Map a step output to a job output
    outputs:
      exit_code: ${{ steps.check.outputs.exit_code}}

    steps:
      - name: Check Black Formatting
        id: check
        run: |
          echo &quot;exit_code=1&quot; &gt;&gt; $GITHUB_OUTPUT
</code></pre>
<p>Then reference that in the 2nd job:</p>
<pre class=""lang-yaml prettyprint-override""><code>jobs: 
  black-formatting:
    runs-on: ubuntu-latest
    needs: [check-for-changes]
    if: ${{ needs.check-for-changes.outputs.exit_code == 1 }}
</code></pre>
<h2>Bash stops processing when a command returns a non-0 exit code.</h2>
<p>Your script <code>black black_test.py --check</code> returns a non-0 exit code, bash will stop processing the rest of the script. The code to set the <code>exit_code</code> variable and the code to set the output variable are skipped, so the value of the output variable will either be <code>0</code> or <code> </code>.</p>
<p>You can capture the exit code and continue processing, you can add <code>|| exit_code=$?</code> after the failing command:</p>
<pre class=""lang-yaml prettyprint-override""><code>      - name: Check Black Formatting
        id: check
        continue-on-error: true
        run: |
          black black_test.py --check || exit_code=$?
          echo &quot;exit_code=$exit_code&quot; &gt;&gt; $GITHUB_OUTPUT
</code></pre>
<p>The <code>continue-on-error: true</code> doesn't let bash keep processing, it just doesn't cause the job to fail if anything fails in the script, even if the script is terminated half-way.</p>
<h2>Final script:</h2>
<pre class=""lang-yaml prettyprint-override""><code>jobs:
    
  check-for-changes:
    outputs:
      exit_code: ${{ steps.check.outputs.exit_code }}

    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2
        
      - name: Install Black
        run: python -m pip install black
        
      - name: Check Black Formatting
        id: check
        run: |
          black black_test.py --check || exit_code=$?
          echo &quot;exit_code=$exit_code&quot; &gt;&gt; $GITHUB_OUTPUT

  black-formatting:
    runs-on: ubuntu-latest
    needs: [check-for-changes]
    if: ${{ needs.check-for-changes.outputs.exit_code == 1 }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2
        
      - name: Install Black
        run: python -m pip install black
        
      - name: Apply Black Formatting
        run: black black_test.py
</code></pre>
","736079",""
"76203486","76202754","2023-05-08 18:46:06","1","<p>I would suggest you to use the <a href=""https://github.com/c-py/action-dotenv-to-setenv"" rel=""nofollow noreferrer"">action-dotenv-to-setenv</a> GitHub Action, as example you could have one env files for each environment and use like:</p>
<pre><code>- name: Configure ${{ inputs.myenv }} environment
  uses: c-py/action-dotenv-to-setenv@v2
  with:
    env-file: ./env/env.${{ inputs.myenv }}
</code></pre>
<p>with the following files</p>
<p><kbd>./env/env.dev</kbd></p>
<pre><code>hostname: &quot;mydevhost&quot;
port: &quot;1885&quot;
</code></pre>
<p><kbd>./env/env.qa</kbd></p>
<pre><code>hostname: &quot;myqahost&quot;
port: &quot;1881&quot;
</code></pre>
","2270041",""
"76204423","76202754","2023-05-08 21:19:05","0","<p>for GitHub Actions you have several levels for environment variables, you could have an organization, Repository, or environment level, this is the most secure one.</p>
<p>The nice part about it is that it is handled securely on GitHub and you can call it using $REPOSITORY_VAR in the workflow.<br />
In your case, I would create a list of repository variables.</p>
<p>Please refer to this link of documentation for examples and more clarity:
<a href=""https://docs.github.com/en/actions/learn-github-actions/variables"" rel=""nofollow noreferrer"">https://docs.github.com/en/actions/learn-github-actions/variables</a></p>
","15540632",""
"76235877","76235374","2023-05-12 11:32:37","3","<p>The <code>branches</code> and <code>branches-ignore</code> filters work on the following events:</p>
<ul>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore"" rel=""nofollow noreferrer""><code>pull_request</code>, <code>pull_request_target</code></a></li>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore"" rel=""nofollow noreferrer""><code>push</code></a></li>
<li><a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_runbranchesbranches-ignore"" rel=""nofollow noreferrer""><code>workflow_run</code></a></li>
</ul>
<p>The <code>pull_request_review</code> is not among those. You can use the <code>if</code> to conditionally execute jobs. In this case, check if the &quot;base&quot; (merge target) is &quot;production&quot;:</p>
<pre class=""lang-yaml prettyprint-override""><code>name: PR_review

on:
  pull_request_review:
    types: [submitted, edited]

jobs:
  test:
    if: ${{ github.event.pull_request.base.ref == 'production' }}
    runs-on: ubuntu-latest
    steps:
      - name: Debug
        run: |
          echo ${{ github.event_name }}
          echo ${{ github.ref }}
          echo ${{ github.event.pull_request.head.ref }}
          echo ${{ github.event.pull_request.base.ref }}
</code></pre>
<p>Now when a review is submitted to another branch, this workflow will run - but its job will be marked as &quot;skipped&quot;.</p>
","266143",""
"78443337","76259462","2024-05-07 14:46:46","1","<p>Recently, I found out that <a href=""https://github.com/actions/runner-images/issues/1519#issuecomment-683790054"" rel=""nofollow noreferrer"">ping doesn't work in GitHub actions</a> at all because the hosted runner uses a specific type of Azure machine that doesn't allow it by design :(</p>
","9124072",""
"76263041","76262960","2023-05-16 12:28:16","1","<p>It won't work like that you have to Go with <strong>placeholder</strong> option, add one <strong>step</strong> into your <strong>Github Action</strong></p>
<p><strong>Job.yaml</strong></p>
<pre><code>apiVersion: batch/v1
kind: Job
metadata:
  name: pi01
spec:
  template:
    spec:
      containers:
      - name: pi01
        image: xx:version
        command: [&quot;node&quot;, &quot;schedule/schedule.js&quot;]
        env:
          - name: DB_HOST
            value: VAL_DB_HOST
          - name: DB_PORT
            value: VAL_DB_PORT
</code></pre>
<p><strong>Run command</strong></p>
<pre><code>sed -i &quot;s,VAL_DB_HOST,$secrets.DB_HOST,&quot; job.yaml
sed -i &quot;s,VAL_DB_PORT,$secrets.DB_PORT,&quot; job.yaml
</code></pre>
<p>You can write <strong>shell script</strong> or further <strong>optimize</strong> it as per need. Above command will replace <strong>VAL_DB_HOST</strong> in <strong>Job.yaml</strong> with <strong>environment</strong> variable <strong>value</strong> saved.</p>
<p>Once your file <strong>job.yaml</strong> is ready, apply the changes</p>
<pre><code>kubectl apply -f job.yaml 
</code></pre>
<p>You can use the different method, <strong>Helm</strong>, <strong>Skafold</strong> also for <strong>templating</strong> if you are looking for that else above will be simple method.</p>
","5525824",""
"78481666","76262960","2024-05-15 04:50:55","0","<p>Instead of using <code>sed</code>, I used <code>yq</code>:</p>
<pre class=""lang-bash prettyprint-override""><code>yq e '(select(.metadata.name==&quot;app-deployment&quot;) | .spec.template.spec.containers[] | select(.name==&quot;php&quot;) | .env) += [{&quot;name&quot;: &quot;DB_PASSWORD&quot;, &quot;value&quot;: &quot;${{ secrets.DB_PASSWORD }}&quot;}]' k8s/app.yaml -i
</code></pre>
<p>The secret does still show if I view the YAML via kubectl or k9s, so I'm not sure this is optimal, but if someone makes it in that far they probably also have access to my ENV.</p>
","65387",""
"76305939","76303782","2023-05-22 11:57:47","0","<p>Using repository_dispatch it works.</p>
<pre><code>name: Suburb Automatic
on: 
  workflow_dispatch:
  repository_dispatch:
    types: [auto-suburb]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Start new workflow
        uses: peter-evans/repository-dispatch@v2
        with:
          event-type: auto-suburb

</code></pre>
","9389353",""
"76323015","76322053","2023-05-24 11:24:42","4","<blockquote>
<p>I want to trigger a GitHub Actions workflow when a release/vX.Y.Z format of PR gets merged into the main branch.</p>
</blockquote>
<p>Here is something similar using the <code>release-vX.Y.Z</code> format:</p>
<pre><code>on:
  pull_request:
    types:
      - closed

jobs:
  tag:
    if: contains(github.head_ref, 'release-') &amp;&amp; contains(github.base_ref, 'main') &amp;&amp; github.event.action == 'closed' &amp;&amp; github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Extract branch tag
        id: tag
        run: |
          BRANCH=${{ github.head_ref }}
          TAG=&quot;${BRANCH//release-/&quot;&quot;}&quot;
          echo $TAG
          echo &quot;tag=$TAG&quot; &gt;&gt; $GITHUB_OUTPUT

  release:
    needs:
      - TAG
    runs-on: ubuntu-latest
    env:
      TAG: ${{ needs.TAG.outputs.tag }}
    steps:
       [ ... ] # use $TAG to do something
</code></pre>
<p>This workflow will trigger when a PR is closed.</p>
<p>However, according to the <code>if</code> expression, the <code>tag</code> job will only be executed when the PR head branch use the <code>release-vX.Y.Z</code> format, and if the PR gets merged into the <code>main</code> branch.</p>
<p>Using this implementation, the <code>tag</code> variable and <code>output</code> will be equal to <code>vX.Y.Z</code>.</p>
<ul>
<li><a href=""https://github.com/GuillaumeFalourd/poc-github-actions/blob/main/.github/workflows/61-create-tag-and-release.yml"" rel=""nofollow noreferrer"">Personal workflow implementation</a></li>
<li><a href=""https://github.com/GuillaumeFalourd/poc-github-actions/actions/workflows/61-create-tag-and-release.yml"" rel=""nofollow noreferrer"">Workflow runs</a></li>
</ul>
","8496462",""
"76488565","76484161","2023-06-16 08:57:16","0","<p>Turns out I needed to actually establish the VPN connection before attempting SSH not use it as part of the script inside the SSH so I just added this step:</p>
<pre><code>      - name: Establish VPN connection
        run: |
            sudo apt update
            sudo apt install -y openvpn openvpn-systemd-resolved
            echo &quot;${{ secrets.VPN_CONFIG }}&quot; &gt; vpn-config.ovpn
            echo &quot;${{ secrets.VPN_USERNAME }}&quot; &gt; vpn-credentials.txt
            echo &quot;${{ secrets.VPN_PASSWORD }}&quot; &gt;&gt; vpn-credentials.txt
            sudo openvpn --config vpn-config.ovpn --auth-user-pass vpn-credentials.txt --daemon
            sleep 15
        
</code></pre>
","20367074",""
"76623297","76484161","2023-07-05 18:55:01","1","<p>Here is an example using a separated OpenVPN action:</p>
<pre><code>name: OpenVPN

on:
  workflow_dispatch:
  
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Install OpenVPN
        run: |
          sudo apt update
          sudo apt install -y openvpn openvpn-systemd-resolved
          
      - name: Setup VPN config
        run: |
          echo &quot;${{ secrets.OVPN_CA }}&quot; &gt; ca.crt
          echo &quot;${{ secrets.OVPN_CERT }}&quot; &gt; user.crt
          
      - name: Connect to VPN
        uses: &quot;kota65535/github-openvpn-connect-action@v2&quot;
        with:
          config_file: .github/workflows/ovpn/client.ovpn
          username: ${{ secrets.OVPN_USERNAME }}
          password: ${{ secrets.OVPN_PASSWORD }}
          client_key: ${{ secrets.OVPN_USER_KEY }}

      - name: multiple command
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SSH_RELAY }}
          username: ${{ secrets.SSH_RELAY_USER }}
          password: ${{ secrets.SSH_RELAY_PWD }}
          port: ${{ secrets.SSH_RELAY_PORT }}
          script: |
            whoami
            ls -al

      - name: Kill VPN connection
        if: always()
        run: |
          sudo killall openvpn          
</code></pre>
","11058128",""
"76516794","76512235","2023-06-20 16:40:55","0","<p>I could solve it:
I had to adapt my Dockerfile and write &quot;COPY dbt .&quot;, because this is the subfolder where the actual dbt code is located</p>
","4904027",""
"76624127","76620272","2023-07-05 21:24:36","1","<p>I think the problem here is that the upstream CMakeLIsts.txt isn't really robust:</p>
<pre><code>    cmake_push_check_state()
        set(CMAKE_REQUIRED_LIBRARIES bcrypt)
        check_symbol_exists(BCryptEncrypt windows.h BCRYPT_AVAILABLE)
    cmake_pop_check_state()
</code></pre>
<p>That symbol has <em>never</em> been in Windows.h, although I'm guessing it just works through the fact that <code>Windows.h</code> is incredibly bloated.</p>
<p>A better version of that line would be <code>check_symbol_exists(BCryptEncrypt bcrypt.h BCRYPT_AVAILABLE)</code></p>
","3780494",""
"77498800","76746551","2023-11-17 00:51:06","2","<p>Using the <code>pull_request_target</code> event instead of <code>pull_request</code> in your GitHub Actions workflow is a suitable approach for this scenario.</p>
<p>It allows workflows to access repository secrets when triggered by pull requests from forks, addressing the limitation you've encountered. However, it's crucial to handle this feature with care due to its security implications.</p>
","5127522",""
"76750640","76749213","2023-07-23 23:08:03","1","<p>The issues with the code example above were:</p>
<ul>
<li><a href=""https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs"" rel=""nofollow noreferrer"">job-level outputs</a>
<ul>
<li>When using outputs across different jobs, the required outputs should be defined on job level and not step level only.</li>
</ul>
</li>
<li><a href=""https://docs.github.com/en/actions/learn-github-actions/expressions#fromjson"" rel=""nofollow noreferrer"">fromJSON</a>
<ul>
<li><code>matrix_values</code> output then needs to be used in <a href=""https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix"" rel=""nofollow noreferrer""><code>strategy.matrix</code></a> which requires <code>fromJSON</code> to convert the value to an array.</li>
</ul>
</li>
</ul>
<p>Detailed discussion and generic example available in this answer: <a href=""https://stackoverflow.com/a/62953566/17490003"">Github Actions: How use strategy/matrix with script</a></p>
<p>Based on the <a href=""https://github.com/knowyrtech/matrix/actions/runs/5639102625/workflow"" rel=""nofollow noreferrer"">url provided</a> in comments, here is the updated version with correctly setting and exporting the required output for matrix usage:</p>
<pre><code>jobs:
  convert-to-matrix:
    runs-on: ubuntu-latest

    steps:
      - name: Get LS Output
        id: matrix_step
        run: |
          list=$(ls -1 /etc/*.conf);
          matrix_values=$(echo '[ &quot;'&quot;$(echo &quot;$list&quot; | sed ':a;N;$!ba;s/\n/&quot;, &quot;/g')&quot;'&quot; ]')
          echo &quot;Matrix values: $matrix_values&quot;
          echo &quot;matrix_values=$matrix_values&quot; &gt;&gt; $GITHUB_OUTPUT
    outputs:
      matrix-combination: ${{ steps.matrix_step.output.matrix_values }}   
  build:
    runs-on: ubuntu-latest
    needs: convert-to-matrix
    
    strategy:
      matrix: 
        filename: ${{ fromJSON(needs.setup-matrix.outputs.matrix-combinations) }}
</code></pre>
<hr />
","17490003",""
"76927879","76924487","2023-08-18 09:01:40","0","<p><em><strong>I created one sample Azure Storage queue trigger with Python v2 Programming model and deployed it via Github actions like below:-</strong></em></p>
<p><strong>My function_app.py code:-</strong></p>
<pre class=""lang-py prettyprint-override""><code>import azure.functions as func
import logging

app = func.FunctionApp()

@app.queue_trigger(arg_name=&quot;azqueue&quot;, queue_name=&quot;myqueue&quot;,
                               connection=&quot;valleystrg129_STORAGE&quot;) 
def queue_trigger(azqueue: func.QueueMessage):
    logging.info('Python Queue trigger processed a message: %s',
                azqueue.get_body().decode('utf-8'))
</code></pre>
<p><strong>host.json:-</strong></p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;version&quot;: &quot;2.0&quot;,
  &quot;logging&quot;: {
    &quot;applicationInsights&quot;: {
      &quot;samplingSettings&quot;: {
        &quot;isEnabled&quot;: true,
        &quot;excludedTypes&quot;: &quot;Request&quot;
      }
    }
  },
  &quot;extensionBundle&quot;: {
    &quot;id&quot;: &quot;Microsoft.Azure.Functions.ExtensionBundle&quot;,
    &quot;version&quot;: &quot;[4.*, 5.0.0)&quot;
  },
  &quot;concurrency&quot;: {
    &quot;dynamicConcurrencyEnabled&quot;: true,
    &quot;snapshotPersistenceEnabled&quot;: true
  }
}
</code></pre>
<p><strong>local.settings.json:-</strong></p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;IsEncrypted&quot;: false,
  &quot;Values&quot;: {
    &quot;FUNCTIONS_WORKER_RUNTIME&quot;: &quot;python&quot;,
    &quot;AzureWebJobsStorage&quot;: &quot;DefaultEndpointsProtocol=https;AccountName=valleystrg129;AccountKey=xxxxxyVIUxxxd0ZrE7BVInRkzDF+AStPI60+Q==;EndpointSuffix=core.windows.net&quot;,
    &quot;AzureWebJobsFeatureFlags&quot;: &quot;EnableWorkerIndexing&quot;,
    &quot;valleystrg129_STORAGE&quot;: &quot;DefaultEndpointsProtocol=https;AccountName=valleystrg129;AccountKey=xxxxyVIUtd15vOnm8wt4xxxxkzDF+AStPI60+Q==;EndpointSuffix=core.windows.net&quot;
  }
}
</code></pre>
<p><img src=""https://i.imgur.com/YxSnKfS.png"" alt=""enter image description here"" /></p>
<p>My Function queue trigger got deployed to Function app successfully like below:-</p>
<p><strong>My github action workflow:-</strong></p>
<pre class=""lang-yaml prettyprint-override""><code>name: Build and deploy Python project to Azure Function App - valleyfunc496

on:
  push:
    branches:
      - master
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: '.' 
  PYTHON_VERSION: '3.10' 

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Setup Python version
        uses: actions/setup-python@v1
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Create and start virtual environment
        run: |
          python -m venv venv
          source venv/bin/activate
      - name: Install dependencies
        run: pip install -r requirements.txt
        
      

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v2
        with:
          name: python-app
          path: |
            . 
            !venv/
  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Production'
      url: ${{ steps.deploy-to-function.outputs.webapp-url }}

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v2
        with:
          name: python-app
          path: .

      - name: 'Deploy to Azure Functions'
        uses: Azure/functions-action@v1
        id: deploy-to-function
        with:
          app-name: 'valleyfunc496'
          slot-name: 'Production'
          package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_4F433CE262C6430E9690DCA16871A27B }}
          scm-do-build-during-deployment: true
          enable-oryx-build: true
</code></pre>
<p><strong>Output:-</strong></p>
<p><img src=""https://i.imgur.com/143EDUj.png"" alt=""enter image description here"" /></p>
","20849135",""
"76992240","76976570","2023-08-28 11:03:27","0","<p>The quality gate value is configured on the <strong>SonarQube UI</strong> for the project.</p>
<p>The <a href=""https://github.com/SonarSource/sonarqube-quality-gate-action"" rel=""nofollow noreferrer"">sonarqube-quality-gate-action</a> sends the report and wait for the feedback from the platform to fail the pipeline or not. <a href=""https://docs.sonarsource.com/sonarqube/latest/devops-platform-integration/github-integration/#failing-the-pipeline-job-when-the-quality-gate-fails"" rel=""nofollow noreferrer"">Reference</a></p>
<p>On the SonarQube platform, if you have access to the project page and the project configuration, you should be able to manage the quality gate through these kinds of setting options:</p>
<p><a href=""https://i.sstatic.net/LzUYm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LzUYm.png"" alt="""" /></a></p>
<p><a href=""https://docs.sonarsource.com/sonarqube/latest/project-administration/project-settings/#default-issue-assignee"" rel=""nofollow noreferrer"">Reference</a></p>
<p>Note that you also will need to create a <code>sonar-project.properties</code> file in your project. <a href=""https://stackoverflow.com/questions/34071879/how-do-i-use-or-set-up-sonar-project-properties-file"">Reference</a></p>
<p>If you have multiple projects in the same repository, you can add different <code>sonar-project.properties</code> file, one for each project (ideally one in each project module package).</p>
","8496462",""
"77080178","77077222","2023-09-11 08:50:36","1","<p>Eventually I overcame the problem. Actually, the issue was not related to the <code>flake8</code> it was related to the <code>black</code> linter by the following line:</p>
<p><code>      - uses: psf/black@stable</code></p>
<p>So to tackle this issue (excluding migration files) I created a <code>pyproject.toml</code> in the project root with the following content:</p>
<pre><code>[tool.black]
exclude = '''
(
  /(
      \.git
    | \.hg
    | \.mypy_cache
    | \.tox
    | \.venv
    | _build
    | buck-out
    | build
    | dist
  )/
| migrations
)
'''
</code></pre>
","20770190",""
"77109971","77109635","2023-09-15 06:03:28","1","<p>Try <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#running-your-pull_request-workflow-when-a-pull-request-merges"" rel=""nofollow noreferrer"">this solution</a></p>
<pre><code>on:
 pull_request:
   types:
     - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
      echo The PR was merged
</code></pre>
<p>Also as described <a href=""https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request"" rel=""nofollow noreferrer"">here</a>, <em>GITHUB_REF</em> will be of format</p>
<blockquote>
<p>refs/pull/:prNumber/merge</p>
</blockquote>
<p>If you are controlling changes to develop branch only via a PR merge, then why not just have a workflow on any PUSH to develop branch?</p>
","1256797",""
"77268917","77268763","2023-10-10 20:57:35","1","<p>There are two issues with your code:</p>
<ol>
<li><p>you do not pass the secret correctly to the action - you'll have to use <code> &quot;MY_PASSWORD=${{ secrets.MY_PASSWORD }}&quot;</code></p>
</li>
<li><p>You need to mount the secret on each <code>RUN</code> statement that you will try to use it.</p>
</li>
</ol>
<p>Here are your fixed files:</p>
<p>the pipeline snippet</p>
<pre class=""lang-yaml prettyprint-override""><code>     - name: build and push base runtime image
        uses: docker/build-push-action@v5
        with:
          file: path/to/Dockerfile 
          build-args: |
            USERNAME=${{ inputs.username }}
          secrets: |
            &quot;MY_PASSWORD=${{ secrets.MY_PASSWORD }}&quot;
</code></pre>
<p>and the Dockerfile</p>
<pre><code>FROM ubuntu:latest

ARG USERNAME

COPY ./test-script.sh .

RUN --mount=type=secret,id=MY_PASSWORD \
  cat /run/secrets/MY_PASSWORD

RUN --mount=type=secret,id=MY_PASSWORD \
  ./test-script.sh ${USERNAME} $(cat /run/secrets/MY_PASSWORD)
</code></pre>
","3248158",""